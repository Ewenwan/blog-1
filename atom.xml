<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦魇小栈</title>
  
  <subtitle>专注于分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ihoey.com/"/>
  <updated>2018-01-31T11:49:32.088Z</updated>
  <id>https://blog.ihoey.com/</id>
  
  <author>
    <name>Ihoey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SED 命令简明教程</title>
    <link href="https://blog.ihoey.com/posts/Linux/2018-01-31-linux-sed-command.html"/>
    <id>https://blog.ihoey.com/posts/Linux/2018-01-31-linux-sed-command.html</id>
    <published>2018-01-31T11:03:52.000Z</published>
    <updated>2018-01-31T11:49:32.088Z</updated>
    
    <content type="html"><![CDATA[<p><code>awk</code>于1977年出生，今年36岁本命年，<code>sed</code>比<code>awk</code>大2-3岁，<code>awk</code>就像林妹妹，sed就是宝玉哥哥了。所以 林妹妹跳了个<code>Topless</code>，他的哥哥<code>sed</code>坐不住了，也一定要出来抖一抖。</p><p><code>sed</code>全名叫<code>stream editor</code>，流编辑器，用程序的方式来编辑文本，相当的<code>hacker</code>啊。<code>sed</code>基本上就是玩正则模式匹配，所以，玩<code>sed</code>的人，正则表达式一般都比较强。</p><a id="more"></a><p>同样，本篇文章不会说<code>sed</code>的全部东西，你可以参看 <a href="http://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener"><code>sed</code>的手册</a> ，我这里主要还是想和大家竞争一下那些从手机指缝间或马桶里流走的时间，用这些时间来学习一些东西。当然，接下来的还是要靠大家自己双手。</p><h2 id="用s命令替换"><a href="#用s命令替换" class="headerlink" title="用s命令替换"></a>用s命令替换</h2><p>我使用下面的这段文本做演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is my dog</span><br><span class="line">  my dog's name is frank</span><br><span class="line">This is my fish</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br></pre></td></tr></table></figure><p>把其中的<code>my</code>字符串替换成<code>Hao Chen’s</code>，下面的语句应该很好理解（<code>s</code>表示替换命令，<code>/my/</code>表示匹配<code>my</code>，<code>/Hao Chen’s/</code>表示把匹配替换成<code>Hao Chen’s</code>，<code>/g</code> 表示一行上的替换所有的匹配）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed "s/my/Hao Chen's/g" pets.txt</span><br><span class="line">"This is Hao Chen's cat</span><br><span class="line">  Hao Chen's cat's name is betty</span><br><span class="line">This is Hao Chen's dog</span><br><span class="line">  Hao Chen's dog's name is frank</span><br><span class="line">This is Hao Chen's fish</span><br><span class="line">  Hao Chen's fish's name is george</span><br><span class="line">This is Hao Chen's goat</span><br><span class="line">  Hao Chen's goat's name is adam"</span><br></pre></td></tr></table></figure><p>注意：如果你要使用单引号，那么你没办法通过<code>\&#39;</code>这样来转义，就有双引号就可以了，在双引号内可以用<code>\&quot;</code>来转义。</p><p>再注意：上面的<code>sed</code>并没有对文件的内容改变，只是把处理过后的内容输出，如果你要写回文件，你可以使用重定向，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed "s/my/Hao Chen's/g" pets.txt &gt; hao_pets.txt</span><br></pre></td></tr></table></figure><p>或使用 <code>-i</code> 参数直接修改文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/my/Hao Chen's/g" pets.txt</span><br></pre></td></tr></table></figure><p>在每一行最前面加点东西：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 's/^/#/g' pets.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">This is my cat</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  my cat<span class="string">'s name is betty</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">This is my dog</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  my dog<span class="string">'s name is frank</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">This is my fish</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  my fish<span class="string">'s name is george</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">This is my goat</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  my goat<span class="string">'s name is adam</span></span></span><br></pre></td></tr></table></figure><p>在每一行最后面加点东西：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 's/$/ --- /g' pets.txt</span><br><span class="line">"This is my cat ---</span><br><span class="line">  my cat's name is betty ---</span><br><span class="line">This is my dog ---</span><br><span class="line">  my dog's name is frank ---</span><br><span class="line">This is my fish ---</span><br><span class="line">  my fish's name is george ---</span><br><span class="line">This is my goat ---</span><br><span class="line">  my goat's name is adam ---"</span><br></pre></td></tr></table></figure><p>顺手介绍一下正则表达式的一些最基本的东西：</p><ul><li><code>^</code> 表示一行的开头。如：<code>/^#/</code> 以<code>#</code>开头的匹配。</li><li><code>$</code> 表示一行的结尾。如：<code>/}$/</code> 以<code>}</code>结尾的匹配。</li><li><code>\&lt;</code> 表示词首。 如：<code>\&lt;abc</code> 表示以 <code>abc</code> 为首的詞。</li><li><code>\&gt;</code> 表示词尾。 如：<code>abc\&gt;</code> 表示以 <code>abc</code> 結尾的詞。</li><li><code>.</code> 表示任何单个字符。</li><li><code>*</code> 表示某个字符出现了0次或多次。</li><li><code>[ ]</code> 字符集合。 如：<code>[abc]</code> 表示匹配a或b或c，还有 <code>[a-zA-Z]</code> 表示匹配所有的<code>26</code>个字符。如果其中有<code>^</code>表示反，如 <code>[^a]</code> 表示非a的字符</li></ul><p>正规则表达式是一些很牛的事，比如我们要去掉某<code>html</code>中的<code>tags</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>This<span class="tag">&lt;/<span class="name">b</span>&gt;</span> is what <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"text-decoration: underline;"</span>&gt;</span>I<span class="tag">&lt;/<span class="name">span</span>&gt;</span> meant. Understand?</span><br></pre></td></tr></table></figure><p>看看我们的<code>sed</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果你这样搞的话，就会有问题</span></span><br><span class="line">sed 's/&lt;.*&gt;//g' html.txt</span><br><span class="line">" Understand?"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要解决上面的那个问题，就得像下面这样。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中的<span class="string">'[^&gt;]'</span> 指定了除了&gt;的字符重复0次或多次。</span></span><br><span class="line">sed 's/&lt;[^&gt;]*&gt;//g' html.txt</span><br><span class="line">"This is what I meant. Understand?"</span><br></pre></td></tr></table></figure><p>我们再来看看指定需要替换的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed "3s/my/your/g" pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is your dog</span><br><span class="line">  my dog's name is frank</span><br><span class="line">This is my fish</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br></pre></td></tr></table></figure><p>下面的命令只替换第<code>3</code>到第<code>6</code>行的文本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed "3,6s/my/your/g" pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is your dog</span><br><span class="line">  your dog's name is frank</span><br><span class="line">This is your fish</span><br><span class="line">  your fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>只替换每一行的第一个s：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 's/s/S/1' my.txt</span><br><span class="line">"ThiS is my cat, my cat's name is betty</span><br><span class="line">ThiS is my dog, my dog's name is frank</span><br><span class="line">ThiS is my fish, my fish's name is george</span><br><span class="line">ThiS is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>只替换每一行的第二个<code>s</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 's/s/S/2' my.txt</span><br><span class="line">"This iS my cat, my cat's name is betty</span><br><span class="line">This iS my dog, my dog's name is frank</span><br><span class="line">This iS my fish, my fish's name is george</span><br><span class="line">This iS my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>只替换第一行的第<code>3</code>个以后的<code>s</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 's/s/S/3g' my.txt</span><br><span class="line">"This is my cat, my cat'S name iS betty</span><br><span class="line">This is my dog, my dog'S name iS frank</span><br><span class="line">This is my fiSh, my fiSh'S name iS george</span><br><span class="line">This is my goat, my goat'S name iS adam"</span><br></pre></td></tr></table></figure><h2 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h2><p>如果我们需要一次替换多个模式，可参看下面的示例：（第一个模式把第一行到第三行的<code>my</code>替换成<code>your</code>，第二个则把第<code>3</code>行以后的<code>This</code>替换成了<code>That</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed '1,3s/my/your/g; 3,$s/This/That/g' my.txt</span><br><span class="line">"This is your cat, your cat's name is betty</span><br><span class="line">This is your dog, your dog's name is frank</span><br><span class="line">That is your fish, your fish's name is george</span><br><span class="line">That is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>上面的命令等价于：（注：下面使用的是<code>sed</code>的<code>-e</code>命令行参数）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e '1,3s/my/your/g' -e '3,$s/This/That/g' my.txt</span><br></pre></td></tr></table></figure><p>我们可以使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 's/my/[&amp;]/g' my.txt</span><br><span class="line">"This is [my] cat, [my] cat's name is betty</span><br><span class="line">This is [my] dog, [my] dog's name is frank</span><br><span class="line">This is [my] fish, [my] fish's name is george</span><br><span class="line">This is [my] goat, [my] goat's name is adam"</span><br></pre></td></tr></table></figure><h2 id="圆括号匹配"><a href="#圆括号匹配" class="headerlink" title="圆括号匹配"></a>圆括号匹配</h2><p>使用圆括号匹配的示例：（圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，<code>sed</code>中使用的是<code>\1,\2…</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 's/This is my \([^,&amp;]*\),.*is \(.*\)/\1:\2/g' my.txt</span><br><span class="line">"cat:betty</span><br><span class="line">dog:frank</span><br><span class="line">fish:george</span><br><span class="line">goat:adam"</span><br></pre></td></tr></table></figure><p>上面这个例子中的正则表达式有点复杂，解开如下（去掉转义字符）：</p><ul><li>正则为：<code>This is my ([^,]*),.*is (.*)</code></li><li>匹配为：<code>This is my (cat),……….is (betty)</code></li></ul><p>然后：<code>\1</code>就是<code>cat</code>，<code>\2</code>就是<code>betty</code></p><h2 id="sed的命令"><a href="#sed的命令" class="headerlink" title="sed的命令"></a>sed的命令</h2><p>让我们回到最一开始的例子<code>pets.txt</code>，让我们来看几个命令：</p><h3 id="N命令"><a href="#N命令" class="headerlink" title="N命令"></a>N命令</h3><p>先来看<code>N</code>命令 —— 把下一行的内容纳入当成缓冲区做匹配。</p><p>下面的的示例会把原文本中的偶数行纳入奇数行匹配，而<code>s</code>只匹配并替换一次，所以，就成了下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 'N;s/my/your/' pets.txt</span><br><span class="line">"This is your cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is your dog</span><br><span class="line">  my dog's name is frank</span><br><span class="line">This is your fish</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is your goat</span><br><span class="line">  my goat's name is adam"</span><br></pre></td></tr></table></figure><p>也就是说，原来的文件成了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is my cat\n  my cat's name is betty</span><br><span class="line">This is my dog\n  my dog's name is frank</span><br><span class="line">This is my fish\n  my fish's name is george</span><br><span class="line">This is my goat\n  my goat's name is adam</span><br></pre></td></tr></table></figure><p>这样一来，下面的例子你就明白了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed 'N;s/\n/,/' pets.txt</span><br><span class="line">This is my cat,  my cat's name is betty</span><br><span class="line">This is my dog,  my dog's name is frank</span><br><span class="line">This is my fish,  my fish's name is george</span><br><span class="line">This is my goat,  my goat's name is adam</span><br></pre></td></tr></table></figure><h3 id="a命令和i命令"><a href="#a命令和i命令" class="headerlink" title="a命令和i命令"></a>a命令和i命令</h3><p><code>a</code>命令就是<code>append</code>， <code>i</code>命令就是<code>insert</code>，它们是用来添加行的。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中的1i表明，其要在第1行前插入一行（insert）</span></span><br><span class="line">sed "1 i This is my monkey, my monkey's name is wukong" my.txt</span><br><span class="line">"This is my monkey, my monkey's name is wukong</span><br><span class="line">This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中的1a表明，其要在最后一行后追加一行（append）</span></span><br><span class="line">sed "1 a This is my monkey, my monkey's name is wukong" my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my monkey, my monkey's name is wukong</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>我们可以运用匹配来添加文本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意其中的/fish/a，这意思是匹配到/fish/后就追加一行</span></span><br><span class="line">sed "/fish/a This is my monkey, my monkey's name is wukong" my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my monkey, my monkey's name is wukong</span><br><span class="line">This is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><p>下面这个例子是对每一行都挺插入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed "/my/a ----" my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">----</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">----</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">----</span><br><span class="line">This is my goat, my goat's name is adam</span><br><span class="line">----"</span><br></pre></td></tr></table></figure><h3 id="c命令"><a href="#c命令" class="headerlink" title="c命令"></a>c命令</h3><p><code>c</code> 命令是替换匹配行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sed "2 c This is my monkey, my monkey's name is wukong" my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my monkey, my monkey's name is wukong</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br><span class="line"></span><br><span class="line">sed "/fish/c This is my monkey, my monkey's name is wukong" my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my monkey, my monkey's name is wukong</span><br><span class="line">This is my goat, my goat's name is adam"</span><br></pre></td></tr></table></figure><h3 id="d命令"><a href="#d命令" class="headerlink" title="d命令"></a>d命令</h3><p>删除匹配行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sed '/fish/d' my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my goat, my goat's name is adam"</span><br><span class="line"></span><br><span class="line">sed '2d' my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br><span class="line"></span><br><span class="line">sed '2,$d' my.txt</span><br><span class="line">"This is my cat, my cat's name is betty"</span><br></pre></td></tr></table></figure><h3 id="p命令"><a href="#p命令" class="headerlink" title="p命令"></a>p命令</h3><p>打印命令</p><p>你可以把这个命令当成<code>grep</code>式的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配fish并输出，可以看到fish的那一行被打了两遍，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是因为sed处理时会把处理的信息输出</span></span><br><span class="line">sed '/fish/p' my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my fish, my fish's name is george</span><br><span class="line">This is my goat, my goat's name is adam"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用n参数就好了</span></span><br><span class="line">sed -n '/fish/p' my.txt</span><br><span class="line">"This is my fish, my fish's name is george"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从一个模式到另一个模式</span></span><br><span class="line">sed -n '/dog/,/fish/p' my.txt</span><br><span class="line">"This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从第一行打印到匹配fish成功的那一行</span></span><br><span class="line">sed -n '1,/fish/p' my.txt</span><br><span class="line">"This is my cat, my cat's name is betty</span><br><span class="line">This is my dog, my dog's name is frank</span><br><span class="line">This is my fish, my fish's name is george"</span><br></pre></td></tr></table></figure><h2 id="几个知识点"><a href="#几个知识点" class="headerlink" title="几个知识点"></a>几个知识点</h2><p>好了，下面我们要介绍四个<code>sed</code>的基本知识点：</p><h3 id="Pattern-Space"><a href="#Pattern-Space" class="headerlink" title="Pattern Space"></a>Pattern Space</h3><p>第零个是关于<code>-n</code>参数的，大家也许没看懂，没关系，我们来看一下<code>sed</code>处理文本的伪代码，并了解一下<code>Pattern Space</code>的概念：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foreach line in file &#123;</span><br><span class="line">    //放入把行Pattern_Space</span><br><span class="line">    Pattern_Space &lt;= line;</span><br><span class="line"></span><br><span class="line">    // 对每个pattern space执行sed命令</span><br><span class="line">    Pattern_Space &lt;= EXEC(sed_cmd, Pattern_Space);</span><br><span class="line"></span><br><span class="line">    // 如果没有指定 -n 则输出处理后的Pattern_Space</span><br><span class="line">    if (sed option hasn\'t "-n")  &#123;</span><br><span class="line">       print Pattern_Space</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>第一个是关于<code>address</code>，几乎上述所有的命令都是这样的（注：其中的<code>!</code>表示匹配成功后是否执行命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address[,address]][!]&#123;cmd&#125;</span><br></pre></td></tr></table></figure><p><code>address</code>可以是一个数字，也可以是一个模式，你可以通过逗号要分隔两个<code>address</code> 表示两个<code>address</code>的区间，参执行命令<code>cmd</code>，伪代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool bexec = false</span><br><span class="line">foreach line in file &#123;</span><br><span class="line">    if ( match(address1) )&#123;</span><br><span class="line">        bexec = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ( bexec == true) &#123;</span><br><span class="line">        EXEC(sed_cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ( match (address2) ) &#123;</span><br><span class="line">        bexec = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>address</code>可以使用相对位置，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中的+3表示后面连续3行</span></span><br><span class="line">sed '/dog/,+3s/^/# /g' pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line"><span class="meta">#</span><span class="bash"> This is my dog</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   my dog<span class="string">'s name is frank</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is my fish</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   my fish<span class="string">'s name is george</span></span></span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br></pre></td></tr></table></figure><h3 id="命令打包"><a href="#命令打包" class="headerlink" title="命令打包"></a>命令打包</h3><p>第二个是<code>cmd</code>可以是多个，它们可以用分号分开，可以用大括号括起来作为嵌套命令。下面是几个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cat pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is my dog</span><br><span class="line">  my dog's name is frank</span><br><span class="line">This is my fish</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对3行到第6行，执行命令/This/d</span></span><br><span class="line">sed '3,6 &#123;/This/d&#125;' pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">  my dog's name is frank</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对3行到第6行，匹配/This/成功后，再匹配/fish/，成功后执行d命令</span></span><br><span class="line">sed '3,6 &#123;/This/&#123;/fish/d&#125;&#125;' pets.txt</span><br><span class="line">"This is my cat</span><br><span class="line">  my cat's name is betty</span><br><span class="line">This is my dog</span><br><span class="line">  my dog's name is frank</span><br><span class="line">  my fish's name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat's name is adam"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从第一行到最后一行，如果匹配到This，则删除之；如果前面有空格，则去除空格</span></span><br><span class="line">sed '1,$&#123;/This/d;s/^ *//g&#125;' pets.txt</span><br><span class="line">"my cat's name is betty</span><br><span class="line">my dog's name is frank</span><br><span class="line">my fish's name is george</span><br><span class="line">my goat's name is adam"</span><br></pre></td></tr></table></figure><h3 id="Hold-Space"><a href="#Hold-Space" class="headerlink" title="Hold Space"></a>Hold Space</h3><p>第三个我们再来看一下 <code>Hold Space</code></p><p>接下来，我们需要了解一下<code>Hold Space</code>的概念，我们先来看几个命令：</p><ul><li><code>g</code>： 将<code>hold space</code>中的内容拷贝到<code>pattern space</code>中，原来<code>pattern space</code>里的内容清除</li><li><code>G</code>： 将<code>hold space</code>中的内容<code>append</code>到<code>pattern space\n</code>后</li><li><code>h</code>： 将<code>pattern space</code>中的内容拷贝到<code>hold space</code>中，原来的<code>hold space</code>里的内容被清除</li><li><code>H</code>： 将<code>pattern space</code>中的内容<code>append</code>到<code>hold space\n</code>后</li><li><code>x</code>： 交换<code>pattern space</code>和<code>hold space</code>的内容</li></ul><p>这些命令有什么用？我们来看两个示例吧，用到的示例文件是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat t.txt</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>第一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed 'H;g' t.txt</span><br><span class="line">one</span><br><span class="line"></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line"></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>是不是有点没看懂，我作个图你就看懂了。</p><p><img src="https://oisha19l0.qnssl.com/blog/sed_demo_00.jpg" alt=""></p><p>第二个示例，反序了一个文件的行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed '1!G;h;$!d' t.txt</span><br><span class="line">three</span><br><span class="line">two</span><br><span class="line">one</span><br></pre></td></tr></table></figure><p>其中的 <code>&#39;1!G;h;$!d&#39;</code> 可拆解为三个命令</p><ul><li><code>1!G</code> —— 只有第一行不执行<code>G</code>命令，将<code>hold space</code>中的内容<code>append</code>回到<code>pattern space</code></li><li><code>h</code> —— 第一行都执行<code>h</code>命令，将<code>pattern space</code>中的内容拷贝到<code>hold space</code>中</li><li><code>$!d</code> —— 除了最后一行不执行<code>d</code>命令，其它行都执行<code>d</code>命令，删除当前行</li></ul><p>这个执行序列很难理解，做个图如下大家就明白了：</p><p><img src="https://oisha19l0.qnssl.com/blog/sed_demo.jpg" alt=""></p><p>就先说这么多吧，希望对大家有用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;awk&lt;/code&gt;于1977年出生，今年36岁本命年，&lt;code&gt;sed&lt;/code&gt;比&lt;code&gt;awk&lt;/code&gt;大2-3岁，&lt;code&gt;awk&lt;/code&gt;就像林妹妹，sed就是宝玉哥哥了。所以 林妹妹跳了个&lt;code&gt;Topless&lt;/code&gt;，他的哥哥&lt;code&gt;sed&lt;/code&gt;坐不住了，也一定要出来抖一抖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;全名叫&lt;code&gt;stream editor&lt;/code&gt;，流编辑器，用程序的方式来编辑文本，相当的&lt;code&gt;hacker&lt;/code&gt;啊。&lt;code&gt;sed&lt;/code&gt;基本上就是玩正则模式匹配，所以，玩&lt;code&gt;sed&lt;/code&gt;的人，正则表达式一般都比较强。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ihoey.com/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://blog.ihoey.com/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://blog.ihoey.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.ihoey.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo博客 NexT主题中部署Wildfire评论系统</title>
    <link href="https://blog.ihoey.com/posts/Linux/2018-01-30-Hexo-NexT-Wildfire.html"/>
    <id>https://blog.ihoey.com/posts/Linux/2018-01-30-Hexo-NexT-Wildfire.html</id>
    <published>2018-01-30T04:14:00.000Z</published>
    <updated>2018-01-30T04:24:18.659Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间，发现了一个评论系统很好用，果断把这个评论系统换到自己的博客里了。</p><p>所以本文主要讲在 <code>Hexo</code> 的 <code>NexT</code> 主题中如何使用 <code>Wildfire</code> ，至于其他的博客以及其他的主题中如何使用的问题，我就不多说了。有需求的朋友可以去项目主页提问，或者在这里提问也可以。如果我懂得话一定会回答的。</p><a id="more"></a><h2 id="修改-NexT-评论模板"><a href="#修改-NexT-评论模板" class="headerlink" title="修改 NexT 评论模板"></a>修改 NexT 评论模板</h2><p>在你的博客项目中，打开./themes/next/layout/_partials/comments.swig 这个文件。<br>将文件尾部的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#123;% elseif theme.livere_uid %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"lv-container"</span> <span class="attr">data-id</span>=<span class="string">"city"</span> <span class="attr">data-uid</span>=<span class="string">"&#123;&#123; theme.livere_uid &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 添加内容的位置在这里 --&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>修改为成下面的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#123;% elseif theme.livere_uid %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"lv-container"</span> <span class="attr">data-id</span>=<span class="string">"city"</span> <span class="attr">data-uid</span>=<span class="string">"&#123;&#123; theme.livere_uid &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% elseif theme.wildfire.enable %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .wildfire_thread a &#123;border-bottom: none&#125;</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wildfire_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> wildfireConfig = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span></span><br><span class="line"><span class="javascript">          databaseProvider: <span class="string">'&#123;&#123; theme.wildfire.database_provider &#125;&#125;'</span>,</span></span><br><span class="line"><span class="undefined">          databaseConfig: &#123;</span></span><br><span class="line"><span class="javascript">          &#123;% <span class="keyword">if</span> (theme.wildfire.database_provider) === <span class="string">'wilddog'</span> %&#125;</span></span><br><span class="line"><span class="javascript">            siteId: <span class="string">'&#123;&#123; theme.wildfire.site_id &#125;&#125;'</span></span></span><br><span class="line"><span class="javascript">          &#123;% elseif (theme.wildfire.database_provider) === <span class="string">'firebase'</span> %&#125;</span></span><br><span class="line"><span class="javascript">            apiKey: <span class="string">'&#123;&#123; theme.wildfire.api_key &#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">            authDomain: <span class="string">'&#123;&#123; theme.wildfire.auth_domain &#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">            databaseURL: <span class="string">'&#123;&#123; theme.wildfire.database_url &#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">            projectId: <span class="string">'&#123;&#123; theme.wildfire.project_id &#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">            storageBucket: <span class="string">'&#123;&#123;theme.wildfire.storage_bucket&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">            messagingSenderId: <span class="string">'&#123;&#123;theme.wildfire.messaging_sender_id&#125;&#125;'</span></span></span><br><span class="line"><span class="undefined">          &#123;% endif %&#125;</span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="javascript">          theme: <span class="string">'&#123;&#123;theme.wildfire.theme&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">          locale: <span class="string">'&#123;&#123;theme.wildfire.locale&#125;&#125;'</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://unpkg.com/wildfire/dist/wildfire.auto.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后保存。</p><h2 id="增加设置内容"><a href="#增加设置内容" class="headerlink" title="增加设置内容"></a>增加设置内容</h2><p>打开主题设置文件 <code>./themes/next/_config.yml</code>，注意：不是站点设置文件。<br>将下面的代码复制到合适的位置（包含全部注释）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wildfire Support</span></span><br><span class="line"><span class="attr">wildfire:</span></span><br><span class="line">  <span class="comment">## 开启Wildfire支持</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">## 主题颜色，目前可选值为light/dark两种，默认为light</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">light</span></span><br><span class="line">  <span class="comment">## 系统语言，目前可选值为en/zh-CN两种，默认为en</span></span><br><span class="line"><span class="attr">  locale:</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="comment">## Wilddog配置</span></span><br><span class="line"><span class="attr">  database_provider:</span> <span class="string">wilddog</span></span><br><span class="line"><span class="attr">  site_id:</span> <span class="string">site_id</span></span><br><span class="line"><span class="attr">  avatarURL:</span> <span class="attr">https://image.flaticon.com/icons/svg/621/621863.svg</span></span><br><span class="line">  <span class="comment">## Firebase配置</span></span><br><span class="line">  <span class="comment"># database_provider: firebase</span></span><br><span class="line">  <span class="comment"># api_key: apiKey</span></span><br><span class="line">  <span class="comment"># auth_domain: authDomain</span></span><br><span class="line">  <span class="comment"># database_url: databaseURL</span></span><br><span class="line">  <span class="comment"># project_id: projectId</span></span><br><span class="line">  <span class="comment"># storage_bucket: storageBucket</span></span><br><span class="line">  <span class="comment"># messaging_sender_id: messagingSenderId</span></span><br></pre></td></tr></table></figure><p>需要注意的是，复制的时候不要修改这个配置的缩进关系。另外 <code>Wilddog</code> 和 <code>Firebase</code> 两者的配置只能选择其一。比如要使用 <code>Wilddog</code> 的话，配置内容就如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wildfire:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">light</span></span><br><span class="line"><span class="attr">  locale:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">  database_provider:</span> <span class="string">wilddog</span></span><br><span class="line"><span class="attr">  site_id:</span> <span class="string">wdg_my_site_id</span></span><br></pre></td></tr></table></figure><p>如果要使用 <code>Firebase</code> 则配置选择为如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wildfire:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">light</span></span><br><span class="line"><span class="attr">  locale:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">  database_provider:</span> <span class="string">firebase</span></span><br><span class="line"><span class="attr">  api_key:</span> <span class="string">your_apiKey</span></span><br><span class="line"><span class="attr">  auth_domain:</span> <span class="string">your_authDomain</span></span><br><span class="line"><span class="attr">  database_url:</span> <span class="string">your_databaseURL</span></span><br><span class="line"><span class="attr">  project_id:</span> <span class="string">your_projectId</span></span><br><span class="line"><span class="attr">  storage_bucket:</span> <span class="string">your_storageBucket</span></span><br><span class="line"><span class="attr">  messaging_sender_id:</span> <span class="string">your_messagingSenderId</span></span><br></pre></td></tr></table></figure><p>上面的值呢，就需要大家从自己建好的 <code>APP</code> 应用中拷贝过来了。</p><h2 id="完成部署"><a href="#完成部署" class="headerlink" title="完成部署"></a>完成部署</h2><p>下面就可以直接 <code>hexo generate</code> 生成就可以了。很简单吧~<br>当然如果还有什么问题，欢迎在这里提问哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间，发现了一个评论系统很好用，果断把这个评论系统换到自己的博客里了。&lt;/p&gt;
&lt;p&gt;所以本文主要讲在 &lt;code&gt;Hexo&lt;/code&gt; 的 &lt;code&gt;NexT&lt;/code&gt; 主题中如何使用 &lt;code&gt;Wildfire&lt;/code&gt; ，至于其他的博客以及其他的主题中如何使用的问题，我就不多说了。有需求的朋友可以去项目主页提问，或者在这里提问也可以。如果我懂得话一定会回答的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ihoey.com/categories/Linux/"/>
    
    
      <category term="comment" scheme="https://blog.ihoey.com/tags/comment/"/>
    
  </entry>
  
  <entry>
    <title>使用 JavaScript 实现简单的拖拽</title>
    <link href="https://blog.ihoey.com/posts/javascript/2018-01-29-use-javascript-to-achieve-simple-drag-and-drop.html"/>
    <id>https://blog.ihoey.com/posts/javascript/2018-01-29-use-javascript-to-achieve-simple-drag-and-drop.html</id>
    <published>2018-01-29T09:12:55.000Z</published>
    <updated>2018-01-30T04:26:02.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>使用 <code>JavaScript</code> 实现拖拽的步骤：</p><ul><li>让元素捕获事件（<code>mousedown</code>, <code>mousemove</code> &amp; <code>mouseup</code>）</li><li>单击并不释放，触发 <code>mousedown</code>，标记开始拖拽，并获取元素和鼠标的位置</li><li>拖动鼠标，触发 <code>mousemove</code>，不断的获取鼠标的位置，并通过计算重新确定元素的位置</li><li>释放师表，触发 <code>mouseup</code>，结束拖拽，确定元素位置并更新</li></ul><a id="more"></a><p><strong>被拖拽的元素必须是相对父元素定位，或者是绝对定位</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>绑定事件</p><p>首先，对拖拽的元素绑定 <code>mousedown</code> 时间，使其触发对应的函数，获取元素与鼠标的位置。在 <code>document</code> 对象上绑定 <code>mousemove</code> 和 <code>mouseup</code> 事件，不在拖拽的元素上绑定是因为当鼠标移动太快而超出元素的范围时会停止拖拽，而绑定在 <code>document</code> 上则可以避免这样的事情发生。拖拽再快都不会超出 <code>document</code> 的范围。</p><p><strong>绑定事件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"></span><br><span class="line">box.onmousedown = down;</span><br><span class="line"><span class="built_in">document</span>.onmousemove = move;</span><br><span class="line"><span class="built_in">document</span>.onmouseup = up;</span><br></pre></td></tr></table></figure><h2 id="获取鼠标位置"><a href="#获取鼠标位置" class="headerlink" title="获取鼠标位置"></a>获取鼠标位置</h2><p>鼠标位置可以在 <code>event</code> 对象中获得，常用的属性有：</p><ul><li><code>clientX / clientY</code> : 相对浏览器窗口坐标</li><li><code>offsetX / offsetY</code> : 相对事件目标对象坐标</li><li><code>pageX / pageY</code> : 相对 <code>document</code> 对象坐标</li></ul><p>一般鼠标的位置使用 <code>pageX / pageY</code> 获取，但是 IE 不支持这两个属性。所以在 IE 中使用 <code>event.clientX + document.body.scrollLeft - document.body.clientLeft;</code>获取鼠标的位置。</p><p><strong>获取鼠标位置的函数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMouseXY</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (e.pageX) &#123;</span><br><span class="line">    x = e.pageX;</span><br><span class="line">    y = e.pageY;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = e.clientX + <span class="built_in">document</span>.body.scrollLeft - <span class="built_in">document</span>.body.clientLeft;</span><br><span class="line">    y = e.clientY + <span class="built_in">document</span>.body.scrollTop - <span class="built_in">document</span>.body.clientTop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件触发函数"><a href="#事件触发函数" class="headerlink" title="事件触发函数"></a>事件触发函数</h2><p><code>mousedown</code><br>当鼠标移动到元素内并点击元素不放时，触发 <code>mousedown</code> 事件。按照上面的步骤，这一步是获取元素与鼠标的位置，用于触发 <code>mousemove</code> 时计算元素的位置。</p><p><strong><code>mousedown</code> 触发的函数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  dragging = <span class="literal">true</span>;</span><br><span class="line">  boxX = box.offsetLeft;</span><br><span class="line">  boxY = box.offsetTop;</span><br><span class="line">  mouseX = <span class="built_in">parseInt</span>(getMouseXY(e).x);</span><br><span class="line">  mouseY = <span class="built_in">parseInt</span>(getMouseXY(e).y);</span><br><span class="line">  offsetX = mouseX - boxX;</span><br><span class="line">  offsetY = mouseY - boxY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boxX / boxY</code> 为元素左上角相对于已定位的父元素（相对或者绝对定位的父元素）的偏移的像素值，即元素左上角的坐标。<br><code>mouseX / mouseY</code> 是通过 <code>getMouseXY</code> 函数获得的鼠标的坐标。<br><code>offsetX/ offsetY</code> 是鼠标相对于元素坐标（左上角坐标）的坐标。<br><code>mousemove</code><br>当鼠标移动时，不断的获取鼠标的位置，并计算元素的新坐标修改元素的位置样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dragging) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = getMouseXY(e).x - offsetX;</span><br><span class="line">    <span class="keyword">var</span> y = getMouseXY(e).y - offsetY;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="built_in">document</span>.documentElement.clientWidth - box.offsetWidth;</span><br><span class="line">    <span class="keyword">var</span> height = <span class="built_in">document</span>.documentElement.clientHeight - box.offsetHeight;</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(<span class="number">0</span>, x), width);</span><br><span class="line">    y = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(<span class="number">0</span>, y), height);</span><br><span class="line"></span><br><span class="line">    box.style.left = x + <span class="string">'px'</span>;</span><br><span class="line">    box.style.top = y + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 <code>width / height</code> 表示可移动的位置的大小，这里是 <code>document</code> 减去元素的大小（元素不会超出可移动的范围）。<br><code>Math.min</code> 使得元素不会超出可移动访问的右边界（元素 <code>x</code> 坐标不会超过 <code>width</code>），<code>Math.max</code> 使得元素不会超出可移动范围的左边界（元素的 x 坐标不小于 0）。<br>最后将改变后的元素 <code>left</code> 与 <code>top</code> 值应用当元素上，即修改元素的样式。<br><code>mouseup</code><br>拖拽结束，取消拖拽的标记。使其触发 <code>mousemove</code> 事件，但不做任何处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  dragging = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><iframe src="//fiddle.jshell.net/Lr73mn89/show/light/" frameborder="0" sandbox="allow-forms allow-scripts allow-same-origin allow-modals allow-popups" allow="midi; geolocation; microphone; camera" width="100%" height="200px"></iframe><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面使用的简单的 <code>JavaScript</code> 代码实现了元素的拖拽，但并没有对兼容性问题全面考虑，也没有对性能优化，有不必要的事件触发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;JavaScript&lt;/code&gt; 实现拖拽的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让元素捕获事件（&lt;code&gt;mousedown&lt;/code&gt;, &lt;code&gt;mousemove&lt;/code&gt; &amp;amp; &lt;code&gt;mouseup&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;单击并不释放，触发 &lt;code&gt;mousedown&lt;/code&gt;，标记开始拖拽，并获取元素和鼠标的位置&lt;/li&gt;
&lt;li&gt;拖动鼠标，触发 &lt;code&gt;mousemove&lt;/code&gt;，不断的获取鼠标的位置，并通过计算重新确定元素的位置&lt;/li&gt;
&lt;li&gt;释放师表，触发 &lt;code&gt;mouseup&lt;/code&gt;，结束拖拽，确定元素位置并更新&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://blog.ihoey.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.ihoey.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Merry Christmas</title>
    <link href="https://blog.ihoey.com/posts/Node/2017-12-25-Merry-Christmas.html"/>
    <id>https://blog.ihoey.com/posts/Node/2017-12-25-Merry-Christmas.html</id>
    <published>2017-12-25T00:05:52.000Z</published>
    <updated>2017-12-24T02:56:01.813Z</updated>
    
    <content type="html"><![CDATA[<p><code>npm</code> 没有写入文档的一个命令：<code>npm xmas</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                    ★</span><br><span class="line">                   ／＼</span><br><span class="line">                  ／  ＼</span><br><span class="line">                 ／i⁂i ＼</span><br><span class="line">                ／      ＼</span><br><span class="line">               ／｡      ⁂＼</span><br><span class="line">              ／  ⸛      ⸮＼</span><br><span class="line">             ／  i⁂ @    ｡⸮＼</span><br><span class="line">            ／i&amp;i ⸛｡ i   ⸮ ｡＼</span><br><span class="line">           ／       ｡ @   @  ＼</span><br><span class="line">          ／ ｡ ｡｡&amp; ｡ i@@    &amp; ＼</span><br><span class="line">         ／&amp;     ｡⸛ @ ⸛@   i ⸮ ＼</span><br><span class="line">        ／  ⸮ i ⸮@    @@⁂ ⁂@  ⸮⸛＼</span><br><span class="line">       ／     &amp;       ｡      i⁂⁂⸮＼</span><br><span class="line">      ／i     ｡  @ @   ⁂  ⸮  i&amp;   ＼</span><br><span class="line">     ／     ⸛    ⸛ ⸮ ｡  &amp;&amp;   @  ⸛ ⸮＼</span><br><span class="line">    ／ ⸛i ⁂｡&amp; ⁂      ｡   ⸛｡@  ⸮@  ⸮ ＼</span><br><span class="line">   ／   &amp; ⸮ ⁂ @    ⸮ ⁂｡ i⸮    ii   ⸛&amp;＼</span><br><span class="line">  ／｡    @⸮        @&amp; ｡⸛⸛ i⸮  ⸮｡｡  ⸛ ｡＼</span><br><span class="line"> ／  ⸮ i ｡ i   ⸮  ｡ i  i ⸮  ⸛   ｡  i   ＼</span><br><span class="line">／｡@        &amp;   i｡⸮⁂｡  i   i i｡  @      ＼</span><br><span class="line">^^^^^^^^^^^^^^^^^^^|  |^^^^^^^^^^^^^^^^^^^</span><br><span class="line">                   |  |</span><br></pre></td></tr></table></figure><p>在终端是很漂亮的，因为是彩色的，大家可以自己试试，我这里就不贴图了，放个<a href="https://juejin.im/pin/5a3c77d06d6def0ae5017d84" target="_blank" rel="noopener">链接</a>吧</p><p>祝大家圣诞节快乐🎄</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;npm&lt;/code&gt; 没有写入文档的一个命令：&lt;code&gt;npm xmas&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="https://blog.ihoey.com/categories/Node/"/>
    
    
      <category term="日常水文" scheme="https://blog.ihoey.com/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JAVASCRIPT生成图形验证码</title>
    <link href="https://blog.ihoey.com/posts/javascript/2017-11-29-javascript-getGverify.html"/>
    <id>https://blog.ihoey.com/posts/javascript/2017-11-29-javascript-getGverify.html</id>
    <published>2017-11-29T11:49:01.000Z</published>
    <updated>2017-11-29T13:07:20.301Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例为大家分享了js生成图形验证码的具体代码，供大家参考，具体内容如下</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">getGVerify: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">GVerify</span>(<span class="params">options</span>) </span>&#123; <span class="comment">//创建一个图形验证码对象，接收options对象为参数</span></span><br><span class="line">        <span class="keyword">this</span>.options = &#123; <span class="comment">//默认options参数值</span></span><br><span class="line">            id: <span class="string">""</span>, <span class="comment">//容器Id</span></span><br><span class="line">            canvasId: <span class="string">"verifyCanvas"</span>, <span class="comment">//canvas的ID</span></span><br><span class="line">            width: <span class="string">"100"</span>, <span class="comment">//默认canvas宽度</span></span><br><span class="line">            height: <span class="string">"30"</span>, <span class="comment">//默认canvas高度</span></span><br><span class="line">            type: <span class="string">"blend"</span>, <span class="comment">//图形验证码默认类型blend:数字字母混合类型、number:纯数字、letter:纯字母</span></span><br><span class="line">            code: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(options) == <span class="string">"[object Object]"</span>) &#123; <span class="comment">//判断传入参数类型</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> options) &#123; <span class="comment">//根据传入的参数，修改默认参数值</span></span><br><span class="line">                <span class="keyword">this</span>.options[i] = options[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.options.id = options;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.options.numArr = <span class="string">"0,1,2,3,4,5,6,7,8,9"</span>.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">this</span>.options.letterArr = getAllLetter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._init();</span><br><span class="line">        <span class="keyword">this</span>.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GVerify.prototype = &#123;</span><br><span class="line">        <span class="comment">/**版本号**/</span></span><br><span class="line">        version: <span class="string">'1.0.0'</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**初始化方法**/</span></span><br><span class="line">        _init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="keyword">this</span>.options.id);</span><br><span class="line">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">            <span class="comment">/*this.options.width = con.offsetWidth &gt; 0 ? con.offsetWidth : "100";</span></span><br><span class="line"><span class="comment">            this.options.height = con.offsetHeight &gt; 0 ? con.offsetHeight : "30";*/</span></span><br><span class="line">            canvas.id = <span class="keyword">this</span>.options.canvasId;</span><br><span class="line">            canvas.width = <span class="keyword">this</span>.options.width;</span><br><span class="line">            canvas.height = <span class="keyword">this</span>.options.height;</span><br><span class="line">            canvas.style.cursor = <span class="string">"pointer"</span>;</span><br><span class="line">            canvas.innerHTML = <span class="string">"您的浏览器版本不支持canvas"</span>;</span><br><span class="line">            con.appendChild(canvas);</span><br><span class="line">            <span class="keyword">var</span> parent = <span class="keyword">this</span>;</span><br><span class="line">            canvas.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                parent.refresh();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**生成验证码**/</span></span><br><span class="line">        refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.options.code = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="keyword">this</span>.options.canvasId);</span><br><span class="line">            <span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">                <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.textBaseline = <span class="string">"middle"</span>;</span><br><span class="line"></span><br><span class="line">            ctx.fillStyle = randomColor(<span class="number">180</span>, <span class="number">240</span>);</span><br><span class="line">            ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.options.width, <span class="keyword">this</span>.options.height);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.options.type == <span class="string">"blend"</span>) &#123; <span class="comment">//判断验证码类型</span></span><br><span class="line">                <span class="keyword">var</span> txtArr = <span class="keyword">this</span>.options.numArr.concat(<span class="keyword">this</span>.options.letterArr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.options.type == <span class="string">"number"</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> txtArr = <span class="keyword">this</span>.options.numArr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> txtArr = <span class="keyword">this</span>.options.letterArr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> txt = txtArr[randomNum(<span class="number">0</span>, txtArr.length)];</span><br><span class="line">                <span class="keyword">this</span>.options.code += txt;</span><br><span class="line">                ctx.font = <span class="string">'20px SimHei'</span>;</span><br><span class="line">                <span class="comment">//ctx.font = randomNum(this.options.height/2, this.options.height) + 'px SimHei'; //随机生成字体大小</span></span><br><span class="line">                ctx.fillStyle = randomColor(<span class="number">50</span>, <span class="number">160</span>); <span class="comment">//随机生成字体颜色</span></span><br><span class="line">                <span class="comment">/* ctx.shadowOffsetX = randomNum(-3, 3);</span></span><br><span class="line"><span class="comment">                ctx.shadowOffsetY = randomNum(-3, 3);*/</span></span><br><span class="line">                ctx.shadowBlur = randomNum(<span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">                ctx.shadowColor = <span class="string">"rgba(0, 0, 0, 0.3)"</span>;</span><br><span class="line">                <span class="keyword">var</span> x = <span class="keyword">this</span>.options.width / <span class="number">5</span> * i;</span><br><span class="line">                <span class="keyword">var</span> y = <span class="keyword">this</span>.options.height / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">var</span> deg = randomNum(<span class="number">-30</span>, <span class="number">30</span>);</span><br><span class="line">                <span class="comment">/**设置旋转角度和坐标原点**/</span></span><br><span class="line">                ctx.translate(x, y);</span><br><span class="line">                ctx.rotate(deg * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line">                ctx.fillText(txt, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">/**恢复旋转角度和坐标原点**/</span></span><br><span class="line">                ctx.rotate(-deg * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line">                ctx.translate(-x, -y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**绘制干扰线**/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                ctx.strokeStyle = randomColor(<span class="number">40</span>, <span class="number">180</span>);</span><br><span class="line">                ctx.beginPath();</span><br><span class="line">                ctx.moveTo(randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.width / <span class="number">2</span>), randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.height / <span class="number">2</span>));</span><br><span class="line">                ctx.lineTo(randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.width / <span class="number">2</span>), randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.height));</span><br><span class="line">                ctx.stroke();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**绘制干扰点**/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.options.width / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                ctx.fillStyle = randomColor(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">                ctx.beginPath();</span><br><span class="line">                ctx.arc(randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.width), randomNum(<span class="number">0</span>, <span class="keyword">this</span>.options.height), <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">                ctx.fill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**验证验证码**/</span></span><br><span class="line">        validate: <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> verifyCode = code.toLowerCase();</span><br><span class="line">            <span class="keyword">var</span> v_code = <span class="keyword">this</span>.options.code.toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (verifyCode == v_code) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**生成字母数组**/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAllLetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> letterStr = <span class="string">"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z"</span>;</span><br><span class="line">        <span class="keyword">return</span> letterStr.split(<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**生成一个随机数**/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**生成一个随机色**/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randomColor</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r = randomNum(min, max);</span><br><span class="line">        <span class="keyword">var</span> g = randomNum(min, max);</span><br><span class="line">        <span class="keyword">var</span> b = randomNum(min, max);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb("</span> + r + <span class="string">","</span> + g + <span class="string">","</span> + b + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GVerify(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> verifyCode = <span class="keyword">new</span> GVerify(id);</span><br></pre></td></tr></table></figure><h2 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyCode.validate(inputCode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">esle &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例为大家分享了js生成图形验证码的具体代码，供大家参考，具体内容如下&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://blog.ihoey.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.ihoey.com/tags/javascript/"/>
    
      <category term="原生Js" scheme="https://blog.ihoey.com/tags/%E5%8E%9F%E7%94%9FJs/"/>
    
      <category term="tools" scheme="https://blog.ihoey.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>笔记：NPM版本号自增，自动化发布NPM包</title>
    <link href="https://blog.ihoey.com/posts/Node/2017-11-24-npm-version.html"/>
    <id>https://blog.ihoey.com/posts/Node/2017-11-24-npm-version.html</id>
    <published>2017-11-24T11:08:43.000Z</published>
    <updated>2017-11-24T11:25:43.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提升一个包的版本号"><a href="#提升一个包的版本号" class="headerlink" title="提升一个包的版本号"></a>提升一个包的版本号</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]</span><br></pre></td></tr></table></figure><p><code>Description</code> 在一个包的目录下执行此命令，会提升版本号，并把这个新的版本号写进<code>package.json</code>文件，如果存在<code>npm-shrinkwrap.json</code>，也会写进去。</p><a id="more"></a><p>参数 <code>newversion</code> 应该是一个有效的semver字符串, 或者是<code>pathch</code>, <code>minor</code>, <code>major</code>等,<code>semver.inc</code>中定义的任意一个有效的。<br><code>major</code>： 版本号中第一段数字自增1 <code>minor</code>: 版本号中第一段数字自增1 <code>patch</code>: 版本号中第三段数字自增1<br>如果<code>package.json</code>中的<code>scripts</code>包含<code>version</code>,<code>preversion</code>,<code>postversion</code>，他们将作为<code>npm version</code>的一部分被执行。</p><p>可以将此放入到npm script流中，自动化构建！</p><h2 id="npm-不常用的命令"><a href="#npm-不常用的命令" class="headerlink" title="npm 不常用的命令"></a>npm 不常用的命令</h2><p><code>npm view</code> 包名 <code>version</code> 相看某个包的最新版本号<br><code>npm ls</code> 列出当前安装的所有包<br><code>npm root</code> 查看当前包的安装路径<br><code>npm root -g</code> 查看全局包的安装路径<br><code>npm config ls</code> 查看 <code>npm</code> 当前配置</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;提升一个包的版本号&quot;&gt;&lt;a href=&quot;#提升一个包的版本号&quot; class=&quot;headerlink&quot; title=&quot;提升一个包的版本号&quot;&gt;&lt;/a&gt;提升一个包的版本号&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm version [&amp;lt;newversion&amp;gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Description&lt;/code&gt; 在一个包的目录下执行此命令，会提升版本号，并把这个新的版本号写进&lt;code&gt;package.json&lt;/code&gt;文件，如果存在&lt;code&gt;npm-shrinkwrap.json&lt;/code&gt;，也会写进去。&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="https://blog.ihoey.com/categories/Node/"/>
    
    
      <category term="Node" scheme="https://blog.ihoey.com/tags/Node/"/>
    
      <category term="NodeJs" scheme="https://blog.ihoey.com/tags/NodeJs/"/>
    
      <category term="npm" scheme="https://blog.ihoey.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>不可不知的Mac OS X专用命令行工具(持续更新中)</title>
    <link href="https://blog.ihoey.com/posts/Mac/2017-11-21-Mac-OS-X-command-line-tool.html"/>
    <id>https://blog.ihoey.com/posts/Mac/2017-11-21-Mac-OS-X-command-line-tool.html</id>
    <published>2017-11-21T05:45:05.000Z</published>
    <updated>2017-12-01T09:43:23.623Z</updated>
    
    <content type="html"><![CDATA[<p><code>OS X</code> 的终端下通用很多 <code>Unix</code> 的工具和脚本。如果从 <code>Linux</code> 迁移到 <code>OS X</code> 会发现很多熟悉的命令和脚本工具，其实并没有任何区别。</p><p>但是 <code>OS X</code> 也提供了很多其他系统所没有的特别的命令行工具。我们推荐 <code>8</code> 个这类的工具，希望有助于提高在 <code>Mac</code> 的命令行环境下的效率。</p><a id="more"></a><h1 id="open"><a href="#open" class="headerlink" title="open"></a>open</h1><p><code>open</code> 命令用于打开文件、目录或执行程序。就等同于在命令行模式下，重复图形界面“双击”的动作。例如这个命令与在 <code>Finder</code> 中双击 <code>Safari</code> 是一样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`open /Applications/Safari.app/`</span><br></pre></td></tr></table></figure><p>如果 <code>open</code> 一个文件，则会使用关联的程序打开之。例如 <code>open screenshot.png</code> 会在 <code>Preview</code> 中查看图片。</p><p>可以使用 <code>-a</code> 选项要求自行选择打开的程序，或使用 <code>-e</code> 强制在 <code>TextEdit</code> 中编辑此文件。</p><p><code>open</code> 一个目录会在 <code>Finder</code> 窗口中打开此目录。一个很有用的技巧是 <code>open .</code> 打开当前目录。</p><p><code>Finder</code> 和终端的交互是双向的——把文件从 <code>Finder</code> 中拖入终端，就等同于把文件的完整路径粘贴到命令行中。</p><h1 id="pbcopy-和-pbpaste"><a href="#pbcopy-和-pbpaste" class="headerlink" title="pbcopy 和 pbpaste"></a>pbcopy 和 pbpaste</h1><p>这两个工具可以打通命令行和剪贴板。当然用鼠标操作复制粘贴也可以——但这两个工具的真正威力，发挥在将其用作Unix工具的时候。意思就是说：可以将这两个工具用作管道、IO重定向以及和其他命令的整合。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls ~ | pbcopy</span><br></pre></td></tr></table></figure><p>可以将主目录的文件列表复制到剪贴板。</p><p>也可以把任意文件的内容读入剪贴板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; blogpost.txt</span><br></pre></td></tr></table></figure><p>做点更疯狂的尝试：获取最新 Google 纪念徽标（doodle）的 URL 并复制到剪贴板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.google.com/doodles#oodles/archive | grep -A5 'latest-doodle on' | grep 'img src' | sed s/.*'&lt;img src="\/\/'/''/ | sed s/'" alt=".*'/''/ | pbcopy</span><br></pre></td></tr></table></figure><p>使用管道语法配合 <code>pbcopy</code> 工具可以简单的抓取命令的输出，而不必向上滚动翻阅终端窗口。可以用于和他人分享命令行的标准和错误输出。 <code>pbcopy</code> 和 <code>pbpaste</code> 也可以用于自动化或加速执行一些事情。例如把一些邮件的主题存为任务列表，就可以先从 <code>Mail.app</code> 中复制主题，再运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbpaste &gt;&gt; tasklist.txt</span><br></pre></td></tr></table></figure><h1 id="mdfind"><a href="#mdfind" class="headerlink" title="mdfind"></a>mdfind</h1><p>许多 <code>Linux</code> 用户都发现 <code>Linux</code> 下查找文件的方法在 <code>OS X</code> 上不好用。当然经典的 <code>Unix find</code> 命令总是可以，但既然 <code>OS X</code> 有杀手级搜索工具 <code>Spotlight</code> ，为什么不在命令行上也使用一下呢？</p><p>这就是mdfind命令了。 <code>Spotlight</code> 能做的查找， <code>mdfind</code> 也能做。包括搜索文件的内容和元数据（<code>metadata</code>）。</p><p><code>mdfind</code>还提供更多的搜索选项。例如<code>-onlyin</code>选项可以约束搜索范围为一个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdfind -onlyin ~/Documents essay</span><br></pre></td></tr></table></figure><p><code>mdfind</code> 的索引数据库在后台自动更新，不过你也可以使用 <code>mdutil</code> 工具诊断数据库的问题，诊断 <code>mdfind</code> 的问题也等同于诊断 <code>Spotlight</code> 。如果 <code>Spotlight</code> 的工作不正确，<code>mdutil -E</code>命令可以强制重建索引数据库。也可以用 <code>mdutil -i</code> 彻底关闭文件索引。</p><h1 id="screencapture"><a href="#screencapture" class="headerlink" title="screencapture"></a>screencapture</h1><p><code>screencapture</code> 命令可以截图。和 <code>Grab.app</code> 与 <code>cmd + shift + 3</code> 或 <code>cmd + shift + 4</code> 热键相似，但更加的灵活。</p><p>抓取包含鼠标光标的全屏幕，并以 <code>image.png</code> 插入到新邮件的附件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screencapture -C -M image.png</span><br></pre></td></tr></table></figure><p>用鼠标选择抓取窗口（及阴影）并复制到剪贴板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screencapture -c -W</span><br></pre></td></tr></table></figure><p>延时10秒后抓屏，并在Preview中打开之：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screencapture -T 10 -P image.png</span><br></pre></td></tr></table></figure><p>用鼠标截取一个矩形区域，抓取后存为pdf文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screencapture -s -t pdf image.pdf</span><br></pre></td></tr></table></figure><p>更多用法请参阅 <code>screencapture --help</code> 。</p><h1 id="launchctl"><a href="#launchctl" class="headerlink" title="launchctl"></a>launchctl</h1><p><code>launchctl</code> 管理 <code>OS X</code> 的启动脚本，控制启动计算机时需要开启的服务。也可以设置定时执行特定任务的脚本，就像 <code>Linux cron</code> 一样。</p><p>例如，开机时自动启动 <code>Apache</code> 服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist</span><br></pre></td></tr></table></figure><p>运行 <code>launchctl list</code> 显示当前的启动脚本。 <code>sudo launchctl unload [path/to/script]</code> 停止正在运行的启动脚本，再加上 <code>-w</code> 选项即可去除开机启动。用这个方法可以一次去除 <code>Adobe</code> 或 <code>Microsoft Office</code> 所附带的所有“自动更新”后台程序。</p><p><code>Launchd</code> 脚本存储在以下位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/Library/LaunchAgents</span><br><span class="line">/Library/LaunchAgents</span><br><span class="line">/Library/LaunchDaemons</span><br><span class="line">/System/Library/LaunchAgents</span><br><span class="line">/System/Library/LaunchDaemons</span><br></pre></td></tr></table></figure><!-- 启动脚本的格式可以参考这篇blog，或苹果开发者中心的文章。你也可以使用Lingon应用来完全取代命令行。 --><h1 id="say"><a href="#say" class="headerlink" title="say"></a>say</h1><p><code>say</code> 是一个文本转语音（<code>TTS</code>）的有趣的工具，引擎和 <code>OS X</code> 使用的一样也是 <code>VoiceOver</code> 。如果不加其他选项，则会简单的语音朗读你给定的字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say "Never trust a computer you can't lift."</span><br><span class="line">用-f选项朗读特定文本文件，-o选项将朗读结果存为音频文件而不是播放：</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say -f mynovel.txt -o myaudiobook.aiff</span><br></pre></td></tr></table></figure><p><code>say</code> 命令可以用于在脚本中播放警告或提示。例如你可以设置 <code>Automator</code> 或 <code>Hazel</code> 脚本处理文件，并在任务完成时用 <code>say</code> 命令语音提示。</p><p>最好玩（不过也负罪感十足）的用法是：通过 <code>SSH</code> 连接到朋友或同事的计算机，然后用 <code>say</code> 命令给他们一个大大大惊喜……</p><p>可以在系统设置 <code>（System Preferences）</code> 的字典和语音 <code>（Dictation &amp; Speech）</code> 选项中调整系统的语音选项甚至是语音的语言。</p><h1 id="diskutil"><a href="#diskutil" class="headerlink" title="diskutil"></a>diskutil</h1><p><code>diskutil</code> 是 <code>OS X</code> 磁盘工具应用的命令行版。既可以完成图形界面应用的所有任务，也可以做一些全盘填0、全盘填随机数等额外的任务。先使用 <code>diskutil list</code> 查看所有磁盘的列表和所在路径，然后对特定的磁盘执行命令。</p><p>警告：不正确使用 <code>diskutil</code> 可能意外的破坏磁盘数据。请小心。</p><h1 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h1><p><code>Homebrew</code> 程序提供的 <code>brew</code> ，严格来讲不是一个 <code>OS X</code> 的原生命令，但任何一个 <code>OS X</code> 的专业用户都不会错过它。“ <code>OS X</code> 缺少的包管理器”这个评价是恰如其分的。如果你曾经在 <code>Linux</code> 上使用过 <code>apt-get</code> （或其他包管理器——译者注），你就会发现 <code>Homebrew</code> 基本上是一样的。</p><p>使用 <code>brew</code> 可以简单的获取数千种开源工具和函数库。例如 <code>brew install imagemagick</code> 就可以安装 <code>ImageMagick</code> （几乎可以处理任何图像问题，转换任何格式的图像工具）， <code>brew install node</code> 可以安装 <code>Node.js</code> （当前大热的服务器端 <code>JavaScript</code> 编程工具）。</p><p>也可以通过 <code>Homebrew</code> 做有趣的事情： <code>brew install archey</code> 会安装 <code>Archey</code> （在启动命令行时显示苹果 <code>LOGO</code> 和计算机硬件参数的小工具）。</p><p><img src="https://oisha19l0.qnssl.com/item2.png" alt="item2"></p><p><code>Homebrew</code> 能安装的工具数量庞大，并且一直保持更新。<code>Homebrew</code> 最棒的一点是：所有的文件都被约束在 <code>/usr/local/</code> 一个位置之下。也就是说可以通过 <code>Homebrew</code> 安装新版软件的同时，保持系统内置的依赖库或其他软件不变。同时如果想彻底删除 <code>Homebrew</code> ，也变得非常简单。</p><p>（注：删除 <code>Homebrew</code> 最好还是不要直接删除 <code>/usr/local/</code> 。应当用这个卸载脚本点击预览。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Just copy and paste the lines below (all at once, it won<span class="string">'t work line by line!)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MAKE SURE YOU ARE HAPPY WITH WHAT IT DOES FIRST! THERE IS NO WARRANTY!</span></span><br><span class="line"></span><br><span class="line">function abort &#123;</span><br><span class="line">  echo "$1"</span><br><span class="line">  exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">/usr/bin/which -s git || abort "brew install git first!"</span><br><span class="line">test -d /usr/local/.git || abort "brew update first!"</span><br><span class="line"></span><br><span class="line">cd `brew --prefix`</span><br><span class="line">git checkout master</span><br><span class="line">git ls-files -z | pbcopy</span><br><span class="line">rm -rf Cellar</span><br><span class="line">bin/brew prune</span><br><span class="line">pbpaste | xargs -0 rm</span><br><span class="line">rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions</span><br><span class="line">test -d Library/LinkedKegs &amp;&amp; rm -r Library/LinkedKegs</span><br><span class="line">rmdir -p bin Library share/man/man1 2&gt; /dev/null</span><br><span class="line">rm -rf .git</span><br><span class="line">rm -rf ~/Library/Caches/Homebrew</span><br><span class="line">rm -rf ~/Library/Logs/Homebrew</span><br><span class="line">rm -rf /Library/Caches/Homebrew</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;OS X&lt;/code&gt; 的终端下通用很多 &lt;code&gt;Unix&lt;/code&gt; 的工具和脚本。如果从 &lt;code&gt;Linux&lt;/code&gt; 迁移到 &lt;code&gt;OS X&lt;/code&gt; 会发现很多熟悉的命令和脚本工具，其实并没有任何区别。&lt;/p&gt;
&lt;p&gt;但是 &lt;code&gt;OS X&lt;/code&gt; 也提供了很多其他系统所没有的特别的命令行工具。我们推荐 &lt;code&gt;8&lt;/code&gt; 个这类的工具，希望有助于提高在 &lt;code&gt;Mac&lt;/code&gt; 的命令行环境下的效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://blog.ihoey.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://blog.ihoey.com/tags/Mac/"/>
    
      <category term="Mac OS" scheme="https://blog.ihoey.com/tags/Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>继多说、网易关停之后该何去何从(网易云跟帖宣布2017年8月1日停止服务)</title>
    <link href="https://blog.ihoey.com/posts/Linux/2017-07-06-comment_ru_he_xuan_ze.html"/>
    <id>https://blog.ihoey.com/posts/Linux/2017-07-06-comment_ru_he_xuan_ze.html</id>
    <published>2017-07-06T10:51:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://oisha19l0.qnssl.com/IHOEY_20170706_184907.png" alt="comment_ihoey"><br>继多说（多说关闭想必大家都已经知道了）关闭之后，很多人包括我，都转移到了网易云跟帖，现在网易云跟帖也正式发出公告宣布于2017年8月1日停止服务。</p><a id="more"></a><p>在多说关闭之后，使用网易云跟帖的站点非常多，昨日宣布停止服务，小编也感到很意外。官方在QQ群内通知并没有说明具体原因，或许还是评论服务的老话题——盈利！</p><p>并且QQ群管理称涉及网易自身评论，开源几乎不大！</p><p>这是提前在官方群得到的通知！<br><img src="https://oisha19l0.qnssl.com/IHOEY_20170706_171445.png" alt="comment_ihoey"></p><p>多说刚挂了两个月，跟帖也跟着去了，刚做的提醒小功能都还没怎么用，好伤心，不知道小伙伴下一步都选择什么呢？有好用的推荐一下啊！<br><img src="https://oisha19l0.qnssl.com/IHOEY_20170706_171444.png" alt="comment_ihoey"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://oisha19l0.qnssl.com/IHOEY_20170706_184907.png&quot; alt=&quot;comment_ihoey&quot;&gt;&lt;br&gt;继多说（多说关闭想必大家都已经知道了）关闭之后，很多人包括我，都转移到了网易云跟帖，现在网易云跟帖也正式发出公告宣布于2017年8月1日停止服务。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ihoey.com/categories/Linux/"/>
    
    
      <category term="comment" scheme="https://blog.ihoey.com/tags/comment/"/>
    
  </entry>
  
  <entry>
    <title>重新介绍 JavaScript（JS全面系列教程）</title>
    <link href="https://blog.ihoey.com/posts/javascript/2017-07-03-A_re-introduction_to_JavaScript.html"/>
    <id>https://blog.ihoey.com/posts/javascript/2017-07-03-A_re-introduction_to_JavaScript.html</id>
    <published>2017-07-03T10:51:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为什么会有这一篇“重新介绍”呢？因为 <code>JavaScript</code> 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 <code>JavaScript</code> 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 <code>JavaScript</code> 就尤有必要。</p><a id="more"></a><p>先从这门语言的历史谈起是有必要的。在<code>1995</code> 年 <code>Netscape</code> 一位名为 Brendan Eich 的工程师创造了 <code>JavaScript</code>，随后在 <code>1996</code> 年初，<code>JavaScript</code> 首先被应用于 <code>Netscape</code> 2 浏览器上。最初的 <code>JavaScript</code> 名为 <code>LiveScript</code>，后来因为 <code>Sun Microsystem</code> 的 <code>Java</code> 语言的兴起和广泛使用，<code>Netscape</code> 出于宣传和推广的考虑，将它的名字从最初的 LiveScript 更改为 <code>JavaScript</code>——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源。</p><p>几个月后，<code>Microsoft</code> 随着 <code>IE 3</code> 推出了一个与之基本兼容的语言 <code>JScript</code>。又几个月后，<code>Netscape</code> 将 <code>JavaScript</code> 提交至 <code>Ecma International</code>（一个欧洲标准化组织）， <code>ECMAScript</code> 标准第一版便在 <code>1997</code> 年诞生了，随后在 <code>1999</code> 年以 <code>ECMAScript</code> 第三版的形式进行了更新，从那之后这个标准没有发生过大的改动。由于委员会在语言特性的讨论上发生分歧，<code>ECMAScript</code> 第四版尚未推出便被废除，但随后于 <code>2009</code> 年 <code>12</code> 月发布的 <code>ECMAScript</code> 第五版引入了第四版草案加入的许多特性。第六版标准已经于<code>2015</code>年六月发布。</p><p>注意： 为熟悉起见，从这里开始我们将用 “<code>JavaScript</code>” 替代 <code>ECMAScript</code> 。<br>与大多数编程语言不同，<code>JavaScript</code> 没有输入或输出的概念。它是一个在宿主环境（<code>host environment</code>）下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 <code>JavaScript</code> 解释器，如 <code>Adobe Acrobat</code>、<code>Photoshop</code>、<code>SVG</code> 图像、<code>Yahoo!</code> 的 <code>Widget</code> 引擎，以及 <code>Node.js</code> 之类的服务器端环境。<code>JavaScript</code> 的实际应用远不止这些，除此之外还有 <code>NoSQL</code> 数据库（如开源的 <code>Apache CouchDB</code>）、嵌入式计算机，以及包括 <code>GNOME</code> （注：<code>GNU/Linux</code> 上最流行的 <code>GUI</code> 之一）在内的桌面环境等等。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>JavaScript</code> 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ <code>built-in</code>）对象和方法。它的语法来源于 <code>Java</code> 和 <code>C</code>，所以这两种语言的许多语法特性同样适用于 <code>JavaScript</code>。需要注意的一个主要区别是 <code>JavaScript</code> 不支持类，类这一概念在 <code>JavaScript</code> 通过对象原型（<code>object prototype</code>）得到延续（有关 <code>ES6</code> 类的内容参考这里<code>Classes</code>）。另一个主要区别是 <code>JavaScript</code> 中的函数也是对象，<code>JavaScript</code> 允许函数在包含可执行代码的同时，能像其他对象一样被传递。</p><p>先从任何编程语言都不可缺少的组成部分——“类型”开始。<code>JavaScript</code> 程序可以修改值（<code>value</code>），这些值都有各自的类型。<code>JavaScript</code> 中的类型包括：</p><ul><li><code>Number</code>（数字）</li><li><code>String</code>（字符串）</li><li><code>Boolean</code>（布尔）</li><li><code>Function</code>（函数）</li><li><code>Object</code>（对象）</li><li><code>Symbol</code> (第六版新增)</li></ul><p>…哦，还有看上去有些…奇怪的 <code>undefined</code>（未定义）类型和 <code>null</code>（空）类型。此外还有<code>Array</code>（数组）类型，以及分别用于表示日期和正则表达式的 <code>Date</code>（日期）和 <code>RegExp</code>（正则表达式），这三种类型都是特殊的对象。严格意义上说，<code>Function</code>（函数）也是一种特殊的对象。所以准确来说，<code>JavaScript</code> 中的类型应该包括这些：</p><ul><li><code>Number</code>（数字）</li><li><code>String</code>（字符串）</li><li><code>Boolean</code>（布尔）</li><li><code>Symbol</code>（符号）（第六版新增）</li><li><code>Object</code>（对象）</li><li><code>Function</code>（函数）</li><li><code>Array</code>（数组）</li><li><code>Date</code>（日期）</li><li><code>RegExp</code>（正则表达式）</li><li><code>Null</code>（空）</li><li><code>Undefined</code>（未定义）</li><li><code>JavaScript</code> 还有一种内置<code>Error</code>（错误）类型，这个会在之后的介绍中提到；现在我们先讨论下上面这些类型。</li></ul><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>根据语言规范，<code>JavaScript</code> 采用“<code>IEEE 754</code> 标准定义的双精度<code>64</code>位格式”（”<code>double-precision 64-bit format IEEE 754 values</code>“）表示数字。据此我们能得到一个有趣的结论，和其他编程语言（如 <code>C</code> 和 <code>Java</code>）不同，<code>JavaScript</code> 不区分整数值和浮点数值，所有数字在 <code>JavaScript</code> 中均用浮点数值表示，所以在进行数字运算的时候要特别注意。看看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>在具体实现时，整数值通常被视为<code>32</code>位整型变量，在个别实现（如某些浏览器）中也以<code>32</code>位整型变量的形式进行存储，直到它被用于执行某些<code>32</code>位整型不支持的操作，这是为了便于进行位操作。</p><p><code>JavaScript</code> 支持标准的算术运算符，包括加法、减法、取模（或取余）等等。还有一个之前没有提及的内置对象 <code>Math</code>（数学对象），用以处理更多的高级数学函数和常数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sin(<span class="number">3.5</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Math</span>.PI * (r + r);</span><br></pre></td></tr></table></figure><p>你可以使用内置函数 <code>parseInt()</code> 将字符串转换为整型。该函数的第二个参数表示字符串所表示数字的基（进制）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"123"</span>, <span class="number">10</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"010"</span>, <span class="number">10</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>如果调用时没有提供第二个参数（字符串所表示数字的基），<code>2013</code> 年以前的 <code>JavaScript</code> 实现会返回一个意外的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"010"</span>);  <span class="comment">//  8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"0x10"</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>这是因为字符串以数字 <code>0</code> 开头，<code>parseInt()</code>函数会把这样的字符串视作八进制数字；同理，<code>0x</code>开头的字符串则视为十六进制数字。</p><p>如果想把一个二进制数字字符串转换成整数值，只要把第二个参数设置为 <code>2</code> 就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"11"</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 还有一个类似的内置函数 <code>parseFloat()</code>，用以解析浮点数字符串，与 <code>parseInt()</code> 不同的地方是，<code>parseFloat()</code>只应用于解析十进制数字。</p><p>单元运算符 + 也可以把数字字符串转换成数值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">"42"</span>;   <span class="comment">// 42</span></span><br><span class="line">+ <span class="string">"010"</span>;  <span class="comment">// 10</span></span><br><span class="line">+ <span class="string">"0x10"</span>; <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>如果给定的字符串不存在数值形式，函数会返回一个特殊的值 <code>NaN</code>（<code>Not a Number</code> 的缩写）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"hello"</span>, <span class="number">10</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>要小心<code>NaN</code>：如果把 <code>NaN</code> 作为参数进行任何数学运算，结果也会是 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> + <span class="number">5</span>; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p>可以使用内置函数 <code>isNaN()</code> 来判断一个变量是否为 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 还有两个特殊值：<code>Infinity</code>（正无穷）和 <code>-Infinity</code>（负无穷）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">0</span>; <span class="comment">//  Infinity</span></span><br><span class="line"><span class="number">-1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p>可以使用内置函数 <code>isFinite()</code> 来判断一个变量是否是一个有穷数， 如果类型为 <code>Infinity</code>, <code>-Infinity</code> 或 <code>NaN</code>则返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">1</span>/<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">2e64</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"0"</span>); <span class="comment">// true,如果是纯数值类型的检测，则返回false：Number.isFinite("0");</span></span><br></pre></td></tr></table></figure><p>备注： <code>parseInt()</code> 和 <code>parseFloat()</code> 函数会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。使用运算符 “<code>+</code>“ 将字符串转换成数字，只要字符串中含有无法被解析成数字的字符，该字符串都将被转换成 <code>NaN</code>。请你用这两种方法分别解析“<code>10.2abc</code>”这一字符串，比较得到的结果，理解这两种方法的区别。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>JavaScript</code> 中的字符串是一串<code>Unicode</code> 字符序列。这对于那些需要和多语种网页打交道的开发者来说是个好消息。更准确地说，它们是一串<code>UTF-16</code>编码单元的序列，每一个编码单元由一个 <code>16</code> 位二进制数表示。每一个<code>Unicode</code>字符由一个或两个编码单元来表示。</p><p>如果想表示一个单独的字符，只需使用长度为 <code>1</code> 的字符串。</p><p>通过访问字符串的长度（编码单元的个数）属性可以得到它的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.length; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这是我们第一次碰到 <code>JavaScript</code> 对象。我们有没有提过你可以像 <code>objects</code>  一样使用字符串？是的，字符串也有 <code>methods</code>（方法）能让你操作字符串和获取字符串的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.charAt(<span class="number">0</span>); <span class="comment">// "h"</span></span><br><span class="line"><span class="string">"hello, world"</span>.replace(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// "goodbye, world"</span></span><br><span class="line"><span class="string">"hello"</span>.toUpperCase(); <span class="comment">// "HELLO"</span></span><br></pre></td></tr></table></figure><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p><code>JavaScript</code> 中 <code>null</code> 和 <code>undefined</code> 是不同的，前者表示一个空值（<code>non-value</code>），必须使用<code>null</code>关键字才能访问，后者是“<code>undefined</code>（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值。我们之后再具体讨论变量，但有一点可以先简单说明一下，<code>JavaScript</code> 允许声明变量但不对其赋值，一个未被赋值的变量就是 <code>undefined</code> 类型。还有一点需要说明的是，<code>undefined</code> 实际上是一个不允许修改的常量。</p><p><code>JavaScript</code> 包含布尔类型，这个类型的变量有两个可能的值，分别是 <code>true</code> 和 <code>false</code>（两者都是关键字）。根据具体需要，<code>JavaScript</code> 按照如下规则将变量转换成布尔类型：</p><p><code>false</code>、<code>0</code>、空字符串(“”)、<code>NaN</code>、<code>null</code> 和 <code>undefined</code> 被转换为 <code>false</code><br>所有其他值被转换为 <code>true</code><br>也可以使用 <code>Boolean()</code> 函数进行显式转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">""</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">234</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不过一般没必要这么做，因为 <code>JavaScript</code> 会在需要一个布尔变量时隐式完成这个转换操作（比如在 <code>if</code> 条件语句中）。所以，有时我们可以把转换成布尔值后的变量分别称为 真值（<code>true values</code>）——即值为 <code>true</code>  和 假值（<code>false values</code>）——即值为 <code>false</code>；也可以分别称为“真的”（<code>truthy</code>）和“假的”（<code>falsy</code>）。</p><p><code>JavaScript</code> 支持包括 <code>&amp;&amp;</code>（逻辑与）、<code>||</code> （逻辑或）和 <code>!</code>（逻辑非）在内的逻辑运算符。下面会有所提到。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 <code>JavaScript</code> 中声明一个新变量的方法是使用关键字 <code>var</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"simon"</span>;</span><br></pre></td></tr></table></figure><p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 <code>undefined</code>。</p><p><code>JavaScript</code> 与其他语言的（如 <code>Java</code>）的重要区别是在 <code>JavaScript</code> 中语句块（<code>blocks</code>）是没有作用域的，只有函数有作用域。因此如果在一个复合语句中（如 <code>if</code> 控制结构中）使用 <code>var</code> 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）。 但是从 <code>ECMAScript</code> <code>Edition 6</code> 开始将有所不同的， <code>let</code> 和 <code>const</code> 关键字允许你创建块作用域的变量。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>JavaScript</code>的算术操作符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和 <code>%</code> ——求余（与模运算不同）。赋值使用 <code>=</code> 运算符，此外还有一些复合运算符，如 <code>+=</code> 和 <code>-=</code>，它们等价于 <code>x = x op y</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += <span class="number">5</span>; <span class="comment">// 等价于 x = x + 5;</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>++</code> 和 <code>--</code> 分别实现变量的自增和自减。两者都可以作为前缀或后缀操作符使用。</p><ul><li>操作符还可以用来连接字符串：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span> + <span class="string">" world"</span>; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>如果你用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"3"</span> + <span class="number">4</span> + <span class="number">5</span>; <span class="comment">// 345</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> + <span class="string">"5"</span>; <span class="comment">// 75</span></span><br></pre></td></tr></table></figure><p>这里不难看出一个实用的技巧——通过与空字符串相加，可以将某个变量快速转换成字符串类型。</p><p><code>JavaScript</code> 中的比较操作使用 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code>，这些运算符对于数字和字符串都通用。相等的比较稍微复杂一些。由两个“<code>=</code>（等号）”组成的相等运算符有类型自适应的功能，具体例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">"123"</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果在比较前不需要自动类型转换，应该使用由三个“<code>=</code>（等号）”组成的相等运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="literal">true</span>; <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span> === <span class="string">"123"</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 还支持 <code>!=</code> 和 <code>!==</code> 两种不等运算符，具体区别与两种相等运算符的区别类似。</p><p><code>JavaScript</code> 还提供了 位操作符。</p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p><code>JavaScript</code> 的控制结构与其他类 <code>C</code> 语言类似。可以使用 <code>if</code> 和 <code>else</code> 来定义条件语句，还可以连起来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"kittens"</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">"puppies"</span>) &#123;</span><br><span class="line">  name += <span class="string">"!"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"kittens"</span>) &#123;</span><br><span class="line">  name += <span class="string">"!!"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">"!"</span> + name;</span><br><span class="line">&#125;</span><br><span class="line">name == <span class="string">"kittens!!"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 支持 <code>while</code> 循环和 <code>do-while</code>循环。前者适合常见的基本循环操作，如果需要循环体至少被执行一次则可以使用 <code>do-while</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 一个无限循环！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  input = get_input();</span><br><span class="line">&#125; <span class="keyword">while</span> (inputIsNotValid(input))</span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 的 <code>for</code> 循环与 <code>C</code> 和 <code>Java</code> 中的相同，使用时可以在一行代码中提供控制信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 将会执行五次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 和 <code>||</code> 运算符使用短路逻辑（<code>short-circuit logic</code>），是否会执行第二个语句（操作数）取决于第一个操作数的结果。在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = o &amp;&amp; o.getName();</span><br></pre></td></tr></table></figure><p>或运算可以用来设置默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = otherName || <span class="string">"default"</span>;</span><br></pre></td></tr></table></figure><p>类似地，<code>JavaScript</code> 也有一个用于条件表达式的三元操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allowed = (age &gt; <span class="number">18</span>) ? <span class="string">"yes"</span> : <span class="string">"no"</span>;</span><br></pre></td></tr></table></figure><p>在需要多重分支时可以使用  基于一个数字或字符串的 <code>switch</code> 语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'draw'</span>:</span><br><span class="line">        drawIt();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'eat'</span>:</span><br><span class="line">        eatIt();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        doNothing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不使用 <code>break</code> 语句，<code>JavaScript</code> 解释器将会执行之后 <code>case</code> 中的代码。除非是为了调试，一般你并不需要这个特性，所以大多数时候不要忘了加上 <code>break</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 继续向下</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        eatIt();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        doNothing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>default</code> 语句是可选的。<code>switch</code> 和 <code>case</code> 都可以使用需要运算才能得到结果的表达式；在 <code>switch</code> 的表达式和 <code>case</code> 的表达式是使用 <code>===</code> 严格相等运算符进行比较的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span> + <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">        yay();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        neverhappens();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><code>JavaScript</code> 中的对象可以简单理解成“名称-值”对，不难联想 <code>JavaScript</code> 中的对象与下面这些概念类似：</p><ul><li><code>Python</code> 中的字典</li><li><code>Perl</code> 和 <code>Ruby</code> 中的散列（哈希）</li><li><code>C/C++</code> 中的散列表</li><li><code>Java</code> 中的 <code>HashMap</code></li><li><code>PHP</code> 中的关联数组<br>这样的数据结构设计合理，能应付各类复杂需求，所以被各类编程语言广泛采用。正因为 <code>JavaScript</code> 中的一切（除了核心类型，<code>core object</code>）都是对象，所以 <code>JavaScript</code> 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找。</li></ul><p>“名称”部分是一个 <code>JavaScript</code> 字符串，“值”部分可以是任何 <code>JavaScript</code> 的数据类型——包括对象。这使用户可以根据具体需求，创建出相当复杂的数据结构。</p><p>有两种简单方法可以创建一个空对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这两种方法在语义上是相同的。第二种更方便的方法叫作“对象字面量（<code>object literal</code>）”法。这种也是 <code>JSON</code> 格式的核心语法，一般我们优先选择第二种方法。</p><p>“对象字面量”也可以用来在对象实例中定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Carrot"</span>,</span><br><span class="line">    <span class="string">"for"</span>: <span class="string">"Max"</span>,</span><br><span class="line">    details: &#123;</span><br><span class="line">        color: <span class="string">"orange"</span>,</span><br><span class="line">        size: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的属性可以通过链式（<code>chain</code>）表示方法进行访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.details.color; <span class="comment">// orange</span></span><br><span class="line">obj[<span class="string">"details"</span>][<span class="string">"size"</span>]; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>下面的例子创建了一个对象原型，<code>Person</code>，和这个原型的实例，<code>You</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">var</span> You = <span class="keyword">new</span> Person(<span class="string">"You"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">// 我们创建了一个新的 Person，名称是 "You"</span></span><br><span class="line"><span class="comment">// ("You" 是第一个参数, 24 是第二个参数..)</span></span><br></pre></td></tr></table></figure><p>完成创建后，对象属性可以通过如下两种方式进行赋值和访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.name = <span class="string">"Simon"</span></span><br><span class="line"><span class="keyword">var</span> name = obj.name;</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">"name"</span>] = <span class="string">"Simon"</span>;</span><br><span class="line"><span class="keyword">var</span> name = obj[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure><p>这两种方法在语义上也是相同的。第二种方法的优点在于属性的名称被看作一个字符串，这就意味着它可以在运行时被计算，缺点在于这样的代码有可能无法在后期被解释器优化。它也可以被用来访问某些以预留关键字作为名称的属性的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.for = <span class="string">"Simon"</span>; <span class="comment">// 语法错误，因为 for 是一个预留关键字</span></span><br><span class="line">obj[<span class="string">"for"</span>] = <span class="string">"Simon"</span>; <span class="comment">// 工作正常</span></span><br></pre></td></tr></table></figure><p>注意：从 <code>EcmaScript 5</code>开始，预留关键字可以作为对象的属性名（<code>reserved words may be used as object property names &quot;in the buff&quot;</code>）。 这意味着当定义对象字面量时不需要用双引号了。参见 <code>ES5 Spec</code>.<br>关于对象和原型的详情参见： <code>Object.prototype</code>.</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>JavaScript</code> 中的数组是一种特殊的对象。它的工作原理与普通对象类似（以数字为属性名，但只能通过<code>[]</code> 来访问），但数组还有一个特殊的属性——<code>length</code>（长度）属性。这个属性的值通常比数组最大索引大 <code>1</code>。</p><p>创建数组的传统方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="string">`Array`</span>();</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"dog"</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"cat"</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">"hen"</span>;</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>使用数组字面量（<code>array literal</code>）法更加方便：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"hen"</span>];</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>注意，<code>Array.length</code> 并不总是等于数组中元素的个数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"hen"</span>];</span><br><span class="line">a[<span class="number">100</span>] = <span class="string">"fox"</span>;</span><br><span class="line">a.length; <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>记住：数组的长度是比数组最大索引值多一的数。</p><p>如果试图访问一个不存在的数组索引，会得到 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(a[<span class="number">90</span>]); <span class="comment">// `undefined`</span></span><br></pre></td></tr></table></figure><p>可以通过如下方式遍历一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// Do something with a[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历数组的另一种方法是使用 <code>for...in</code> 循环。注意，如果有人向 <code>Array.prototype</code> 添加了新的属性，使用这样的循环这些属性也同样会被遍历。所以并不推荐这种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="comment">// Do something with a[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ECMAScript 5</code> 增加了遍历数组的另一个方法 <code>forEach()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"hen"</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with currentValue or array[index]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果想在数组后追加元素，只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.push(item);</span><br></pre></td></tr></table></figure><p><code>Array</code>（数组）类自带了许多方法。查看 <code>array</code> 方法的完整文档。</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">a.toString()</td><td style="text-align:left">返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td></tr><tr><td style="text-align:left">a.toLocaleString()</td><td style="text-align:left">根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td></tr><tr><td style="text-align:left">a.concat(item1[, item2[, …[, itemN]]])</td><td style="text-align:left">返回一个数组，这个数组包含原先 a 和 item1、item2、……、itemN 中的所有元素。</td></tr><tr><td style="text-align:left">a.join(sep)</td><td style="text-align:left">返回一个包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔。</td></tr><tr><td style="text-align:left">a.pop()</td><td style="text-align:left">删除并返回数组中的最后一个元素。</td></tr><tr><td style="text-align:left">a.push(item1, …, itemN)</td><td style="text-align:left">将 item1、item2、……、itemN 追加至数组 a。</td></tr><tr><td style="text-align:left">a.reverse()</td><td style="text-align:left">数组逆序（会更改原数组 a）。</td></tr><tr><td style="text-align:left">a.shift()</td><td style="text-align:left">删除并返回数组中第一个元素。</td></tr><tr><td style="text-align:left">a.slice(start, end)</td><td style="text-align:left">返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾。</td></tr><tr><td style="text-align:left">a.sort([cmpfn])</td><td style="text-align:left">依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）。</td></tr><tr><td style="text-align:left">a.splice(start, delcount[, item1[, …[, itemN]]])</td><td style="text-align:left">从 start 开始，删除delcount个元素，然后插入所有的</td></tr><tr><td style="text-align:left">a.unshift([item])</td><td style="text-align:left">将 item 插入数组头部，返回数组新长度（考虑 undefined）。</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>学习 <code>JavaScript</code> 最重要的就是要理解对象和函数两个部分。最简单的函数就像下面这个这么简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = x + y;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子包括你需要了解的关于基本函数的所有部分。一个 <code>JavaScript</code> 函数可以包含 <code>0</code> 个或多个已命名的变量。函数体中的表达式数量也没有限制。你可以声明函数自己的局部变量。<code>return</code>语句在返回一个值并结束函数。如果没有使用 <code>return</code> 语句，或者一个没有值的 <code>return</code> 语句，<code>JavaScript</code> 会返回 <code>undefined</code>。</p><p>已命名的参数更像是一个指示而没有其他作用。如果调用函数时没有提供足够的参数，缺少的参数会被 <code>undefined</code> 替代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 不能在 `undefined` 对象上进行加法操作</span></span><br></pre></td></tr></table></figure><p>你还可以传入多于函数本身需要参数个数的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br><span class="line"> <span class="comment">// 将前两个值相加，4被忽略了</span></span><br></pre></td></tr></table></figure><p>这看上去有点蠢。函数实际上是访问了函数体中一个名为 <code>arguments</code> 的内部对象，这个对象就如同一个类似于数组的对象一样，包括了所有被传入的参数。让我们重写一下上面的函数，使它可以接收任意个数的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="built_in">arguments</span>.length; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><p>这跟直接写成 <code>2 + 3 + 4 + 5</code> 也没什么区别。接下来创建一个求平均数的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">avg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="built_in">arguments</span>.length; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line">avg(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure><p>这个很有用，但是却带来了新的问题。<code>avg()</code> 函数处理一个由逗号连接的变量串，但如果想得到一个数组的平均值该怎么办呢？可以这么修改函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">avg</span>`<span class="title">Array</span>`(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = arr.length; i &lt; j; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / arr.length;</span><br><span class="line">&#125;</span><br><span class="line">avg<span class="string">`Array`</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure><p>但如果能重用我们已经创建的那个函数不是更好吗？幸运的是 <code>JavaScript</code> 允许使用任意函数对象的<code>apply()</code>方法来调用该函数，并传递给它一个包含了参数的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg.apply(<span class="string">`null`</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure><p>传给 <code>apply()</code> 的第二个参数是一个数组，它将被当作 <code>avg()</code> 的参数使用，至于第一个参数 <code>null</code>，我们将在后面讨论。这也正说明一个事实——函数也是对象。</p><p><code>JavaScript</code> 允许你创建匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> avg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="built_in">arguments</span>.length; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数在语义上与 <code>function avg()</code> 相同。你可以在代码中的任何地方定义这个函数，就像写普通的表达式一样。基于这个特性，有人发明出一些有趣的技巧。与 <code>C</code> 中的块级作用域类似，下面这个例子隐藏了局部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    a += b;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 4</span></span><br><span class="line">b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 允许以递归方式调用函数。递归在处理树形结构（比如浏览器 <code>DOM</code>）时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChars</span>(<span class="params">elm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elm.nodeType == <span class="number">3</span>) &#123; <span class="comment">// 文本节点</span></span><br><span class="line">        <span class="keyword">return</span> elm.nodeValue.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, child; child = elm.childNodes[i]; i++) &#123;</span><br><span class="line">        count += countChars(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一个潜在问题——既然匿名函数没有名字，那该怎么递归调用它呢？在这一点上，<code>JavaScript</code> 允许你命名这个函数表达式。你可以命名立即调用的函数表达式（<code>IIFES——Immediately Invoked Function Expressions</code>），如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> charsInBody = (<span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">elm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elm.nodeType == <span class="number">3</span>) &#123; <span class="comment">// 文本节点</span></span><br><span class="line">        <span class="keyword">return</span> elm.nodeValue.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, child; child = elm.childNodes[i]; i++) &#123;</span><br><span class="line">        count += counter(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>如上所提供的函数表达式的名称的作用域仅仅是该函数自身。这允许引擎去做更多的优化，并且这种实现更可读、友好。该名称也显示在调试器和一些堆栈跟踪中，节省了调试时的时间。</p><p>需要注意的是 <code>JavaScript</code> 函数是它们本身的对象——就和 <code>JavaScript</code> 其他一切一样——你可以给它们添加属性或者更改它们的属性，这与前面的对象部分一样。</p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><p>备注：关于 <code>JavaScript</code> 中面向对象编程更详细的信息，请参考 <code>JavaScript</code> 面向对象简介。<br>在经典的面向对象语言中，对象是指数据和在这些数据上进行的操作的集合。与 <code>C++</code> 和 <code>Java</code> 不同，<code>JavaScript</code> 是一种基于原型的编程语言，并没有 <code>class</code> 语句，而是把函数用作类。那么让我们来定义一个人名对象，这个对象包括人的姓和名两个域（<code>field</code>）。名字的表示有两种方法：“名 姓（<code>First Last</code>）”或“姓, 名（<code>Last</code>, <code>First</code>）”。使用我们前面讨论过的函数和对象概念，可以像这样完成定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        first: first,</span><br><span class="line">        last: last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFullName</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFullNameReversed</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.last + <span class="string">', '</span> + person.first</span><br><span class="line">&#125;</span><br><span class="line">s = makePerson(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line">personFullName(s); <span class="comment">// Simon Willison</span></span><br><span class="line">personFullNameReversed(s); <span class="comment">// Willison, Simon</span></span><br></pre></td></tr></table></figure><p>上面的写法虽然可以满足要求，但是看起来很麻烦，因为需要在全局命名空间中写很多函数。既然函数本身就是对象，如果需要使一个函数隶属于一个对象，那么不难得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        first: first,</span><br><span class="line">        last: last,</span><br><span class="line">        fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last;</span><br><span class="line">        &#125;,</span><br><span class="line">        fullNameReversed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.last + <span class="string">', '</span> + <span class="keyword">this</span>.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s = makePerson(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line">s.fullName(); <span class="comment">// Simon Willison</span></span><br><span class="line">s.fullNameReversed(); <span class="comment">// Willison, Simon</span></span><br></pre></td></tr></table></figure><p>上面的代码里有一些我们之前没有见过的东西：关键字 <code>this</code>。当使用在函数中时，<code>this</code> 指代当前的对象，也就是调用了函数的对象。如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 <code>this</code>。如果并没有使用“点”运算符调用某个对象，那么 <code>this</code> 将指向全局对象（<code>global object</code>）。这是一个经常出错的地方。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = makePerson(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line"><span class="keyword">var</span> fullName = s.fullName;</span><br><span class="line">fullName(); <span class="comment">// `undefined` `undefined`</span></span><br></pre></td></tr></table></figure><p>当我们调用 <code>fullName()</code> 时，<code>this</code> 实际上是指向全局对象的，并没有名为 <code>first</code> 或 <code>last</code> 的全局变量，所以它们两个的返回值都会是 <code>undefined</code>。</p><p>下面使用关键字 <code>this</code> 改进已有的 <code>makePerson</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">    <span class="keyword">this</span>.last = last;</span><br><span class="line">    <span class="keyword">this</span>.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.last + <span class="string">', '</span> + <span class="keyword">this</span>.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);\</span><br></pre></td></tr></table></figure><p>我们引入了另外一个关键字：<code>new</code>，它和 <code>this</code> 密切相关。它的作用是创建一个崭新的空对象，然后使用指向那个对象的 <code>this</code> 调用特定的函数。注意，含有 <code>this</code> 的特定函数不会返回任何值，只会修改 <code>this</code> 对象本身。<code>new</code> 关键字将生成的 <code>this</code> 对象返回给调用方，而被 <code>new</code> 调用的函数成为构造函数。习惯的做法是将这些函数的首字母大写，这样用 <code>new</code> 调用他们的时候就容易识别了。</p><p>不过这个改进的函数还是和上一个例子一样，单独调用<code>fullName()</code> 时会产生相同的问题。</p><p>我们的 <code>Person</code> 对象现在已经相当完善了，但还有一些不太好的地方。每次我们创建一个 <code>Person</code> 对象的时候，我们都在其中创建了两个新的函数对象——如果这个代码可以共享不是更好吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFullNameReversed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.last + <span class="string">', '</span> + <span class="keyword">this</span>.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">    <span class="keyword">this</span>.last = last;</span><br><span class="line">    <span class="keyword">this</span>.fullName = personFullName;</span><br><span class="line">    <span class="keyword">this</span>.fullNameReversed = personFullNameReversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的好处是，我们只需要创建一次方法函数，在构造函数中引用它们。那是否还有更好的方法呢？答案是肯定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">    <span class="keyword">this</span>.last = last;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.last + <span class="string">', '</span> + <span class="keyword">this</span>.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person.prototype</code>是一个可以被<code>Person</code>的所有实例共享的对象。它是一个名叫原型链（<code>prototype chain</code>）的查询链的一部分：当你试图访问一个 <code>Person</code>没有定义的属性时，解释器会首先检查这个<code>Person.prototype</code>来判断是否存在这样一个属性。所以，任何分配给 <code>Person.prototype</code> 的东西对通过 <code>this</code> 对象构造的实例都是可用的。</p><p>这个特性功能十分强大，<code>JavaScript</code> 允许你在程序中的任何时候修改原型（<code>prototype</code>）中的一些东西，也就是说你可以在运行时(<code>runtime</code>)给已存在的对象添加额外的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> Person(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line">s.firstNameCaps();  <span class="comment">// TypeError on line 1: s.firstNameCaps is not a function</span></span><br><span class="line"></span><br><span class="line">Person.prototype.firstNameCaps = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">s.firstNameCaps(); <span class="comment">// SIMON</span></span><br></pre></td></tr></table></figure><p>有趣的是，你还可以给 <code>JavaScript</code> 的内置函数原型（<code>prototype</code>）添加东西。让我们给 <code>String</code> 添加一个方法用来返回逆序的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"Simon"</span>;</span><br><span class="line">s.reversed(); <span class="comment">// TypeError on line 1: s.reversed is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.reversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r += <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">s.reversed(); <span class="comment">// nomiS</span></span><br></pre></td></tr></table></figure><p>定义新方法也可以在字符串字面量上用（<code>string literal</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This can now be reversed"</span>.reversed(); <span class="comment">// desrever eb won nac sihT</span></span><br></pre></td></tr></table></figure><p>正如我前面提到的，原型组成链的一部分。那条链的根节点是 <code>Object.prototype</code>，它包括 <code>toString()</code>方法——将对象转换成字符串时调用的方法。这对于调试我们的 <code>Person</code> 对象很有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line">s; <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;Person: '</span> + <span class="keyword">this</span>.fullName() + <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.toString(); <span class="comment">// &lt;Person: Simon Willison&gt;</span></span><br></pre></td></tr></table></figure><p>你是否还记得之前我们说的 <code>avg.apply()</code> 中的第一个参数 <code>null</code>？现在我们可以回头看看这个东西了。<code>apply()</code> 的第一个参数应该是一个被当作 <code>this</code> 来看待的对象。下面是一个 <code>new</code> 方法的简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trivialNew</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="keyword">constructor</span>.apply(o, args);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并不是 <code>new</code> 的完整实现，因为它没有创建原型（<code>prototype</code>）链。想举例说明 <code>new</code> 的实现有些困难，因为你不会经常用到这个，但是适当了解一下还是很有用的。在这一小段代码里，<code>...args</code>（包括省略号）叫作剩余参数（<code>rest arguments</code>）。如名所示，这个东西包含了剩下的参数。</p><p>因此调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bill = trivialNew(Person, <span class="string">"William"</span>, <span class="string">"Orange"</span>);</span><br></pre></td></tr></table></figure><p>可认为和调用如下语句是等效的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bill = <span class="keyword">new</span> Person(<span class="string">"William"</span>, <span class="string">"Orange"</span>);</span><br></pre></td></tr></table></figure><p><code>apply()</code> 有一个姐妹函数，名叫 <code>call</code>，它也可以允许你设置 <code>this</code>，但它带有一个扩展的参数列表而不是一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastNameCaps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.last.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person(<span class="string">"Simon"</span>, <span class="string">"Willison"</span>);</span><br><span class="line">lastNameCaps.call(s);</span><br><span class="line"><span class="comment">// 和以下方式等价</span></span><br><span class="line">s.lastNameCaps = lastNameCaps;</span><br><span class="line">s.lastNameCaps();</span><br></pre></td></tr></table></figure><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p><code>JavaScript</code> 允许在一个函数内部定义函数，这一点我们在之前的 <code>makePerson()</code> 例子中也见过。关于 <code>JavaScript</code> 中的嵌套函数，一个很重要的细节是它们可以访问父函数作用域中的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterExampleNeeded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">oneMoreThanA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oneMoreThanA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个函数依赖于其他的一两个函数，而这一两个函数对你其余的代码没有用处，你可以将它们嵌套在会被调用的那个函数内部，这样做可以减少全局作用域下的函数的数量，这有利于编写易于维护的代码。</p><p>这也是一个减少使用全局变量的好方法。当编写复杂代码时，程序员往往试图使用全局变量，将值共享给多个函数，但这样做会使代码很难维护。内部函数可以共享父函数的变量，所以你可以使用这个特性把一些函数捆绑在一起，这样可以有效地防止“污染”你的全局命名空间——你可以称它为“局部全局（<code>local global</code>）”。虽然这种方法应该谨慎使用，但它确实很有用，应该掌握。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>下面我们将看到的是 <code>JavaScript</code> 中必须提到的功能最强大的抽象概念之一：闭包。但它可能也会带来一些潜在的困惑。那它究竟是做什么的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> y = makeAdder(<span class="number">20</span>);</span><br><span class="line">x(<span class="number">6</span>); <span class="comment">// ?</span></span><br><span class="line">y(<span class="number">7</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><code>makeAdder</code> 这个名字本身应该能说明函数是用来做什么的：它创建了一个新的 <code>adder</code> 函数，这个函数自身带有一个参数，它被调用的时候这个参数会被加在外层函数传进来的参数上。</p><p>这里发生的事情和前面介绍过的内嵌函数十分相似：一个函数被定义在了另外一个函数的内部，内部函数可以访问外部函数的变量。唯一的不同是，外部函数被返回了，那么常识告诉我们局部变量“应该”不再存在。但是它们却仍然存在——否则 <code>adder</code> 函数将不能工作。也就是说，这里存在 <code>makeAdder</code> 的局部变量的两个不同的“副本”——一个是 <code>a</code> 等于<code>5</code>，另一个是 <code>a</code> 等于<code>20</code>。那些函数的运行结果就如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x(<span class="number">6</span>); <span class="comment">// 返回 11</span></span><br><span class="line">y(<span class="number">7</span>); <span class="comment">// 返回 27</span></span><br></pre></td></tr></table></figure><p>下面来说说到底发生了什么。每当 <code>JavaScript</code> 执行一个函数时，都会创建一个作用域对象（<code>scope object</code>），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（<code>global object</code>）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 <code>JavaScript</code> 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。</p><p>所以当调用 <code>makeAdder</code>时，解释器创建了一个作用域对象，它带有一个属性：<code>a</code>，这个属性被当作参数传入 <code>makeAdder</code> 函数。然后 <code>makeAdder</code> 返回一个新创建的函数。通常 <code>JavaScript</code> 的垃圾回收器会在这时回收 <code>makeAdder</code> 创建的作用域对象，但是返回的函数却保留一个指向那个作用域对象的引用。结果是这个作用域对象不会被垃圾回收器回收，直到指向 <code>makeAdder</code> 返回的那个函数对象的引用计数为零。</p><p>作用域对象组成了一个名为作用域链（<code>scope chain</code>）的链。它类似于原形（<code>prototype</code>）链一样，被 <code>JavaScript</code> 的对象系统使用。</p><p>一个闭包就是一个函数和被创建的函数中的作用域对象的组合。</p><p>闭包允许你保存状态——所以它们通常可以代替对象来使用。这里有一些关于闭包的详细介绍。</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>使用闭包的一个坏处是，在 <code>IE</code> 浏览器中它会很容易导致内存泄露。<code>JavaScript</code> 是一种具有垃圾回收机制的语言——对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。宿主环境提供的对象都是按照这种方法被处理的。</p><p>浏览器主机需要处理大量的对象来描绘一个正在被展现的 <code>HTML</code> 页面——<code>DOM</code> 对象。浏览器负责管理它们的内存分配和回收。</p><p><code>IE</code> 浏览器有自己的一套垃圾回收机制，这套机制与 <code>JavaScript</code> 提供的垃圾回收机制进行交互时，可能会发生内存泄露。</p><p>在 <code>IE</code> 中，每当在一个 <code>JavaScript</code> 对象和一个本地对象之间形成循环引用时，就会发生内存泄露。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leakMemory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>);</span><br><span class="line">    <span class="keyword">var</span> o = &#123; <span class="string">'el'</span>: el &#125;;</span><br><span class="line">    el.o = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的循环引用会导致内存泄露：<code>IE</code> 不会释放被 <code>el</code> 和 <code>o</code> 使用的内存，直到浏览器被彻底关闭并重启后。</p><p>这个例子往往无法引起人们的重视：一般只会在长时间运行的应用程序中，或者因为巨大的数据量和循环中导致内存泄露发生时，内存泄露才会引起注意。</p><p>不过一般也很少发生如此明显的内存泄露现象——通常泄露的数据结构有多层的引用(<code>references</code>)，往往掩盖了循环引用的情况。</p><p>闭包很容易发生无意识的内存泄露。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>);</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        el.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个元素，当它被点击的时候变红，但同时它也会发生内存泄露。为什么？因为对 <code>el</code> 的引用不小心被放在一个匿名内部函数中。这就在 <code>JavaScript</code> 对象（这个内部函数）和本地对象之间（<code>el</code>）创建了一个循环引用。</p><p>这个问题有很多种解决方法，最简单的一种是不要使用 <code>el</code> 变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是，有一种窍门解决因闭包而引入的循环引用，是添加另外一个闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>);</span><br><span class="line">        el.onclick = clickHandler;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部函数被直接执行，并在 <code>clickHandler</code> 创建的闭包中隐藏了它的内容。</p><p>另外一种避免闭包的好方法是在 <code>window.onunload</code> 事件发生期间破坏循环引用。很多事件库都能完成这项工作。注意这样做将使 <code>Firefox</code> 中的 <code>bfcache</code> 无法工作。所以除非有其他必要的原因，最好不要在 <code>Firefox</code> 中注册一个 <code>onunload</code> 的监听器。</p><p>原文来自：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新介绍 JavaScript（JS 教程）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;为什么会有这一篇“重新介绍”呢？因为 &lt;code&gt;JavaScript&lt;/code&gt; 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 &lt;code&gt;JavaScript&lt;/code&gt; 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 &lt;code&gt;JavaScript&lt;/code&gt; 就尤有必要。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://blog.ihoey.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.ihoey.com/tags/javascript/"/>
    
      <category term="Function" scheme="https://blog.ihoey.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>博客评论网易云跟帖评论提醒功能</title>
    <link href="https://blog.ihoey.com/posts/Linux/2017-06-22-blog-comment-gentie-remind.html"/>
    <id>https://blog.ihoey.com/posts/Linux/2017-06-22-blog-comment-gentie-remind.html</id>
    <published>2017-06-22T11:00:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://oisha19l0.qnssl.com/comment_ihoey.png" alt="comment_ihoey"><br>多说官方宣布17年6月1号停止维护，一个优秀的评论系统从此倒下了，令人唏嘘不已，还是要感谢多说团队多年的付出。眼下留给博主们的选择也就畅言和网易云跟帖了。经过综合考虑选择了网易跟帖，由于网易云跟帖没有提醒功能，所以今天就做了一个邮件提醒的功能。</p><a id="more"></a><ul><li><p>网易云跟帖的安装这里就不多说了，照着网上的教程走一遍或者按官方的文档基本上就可以了，不过提醒一下，网易云跟帖不能在本地测试，必须部署完成才会显示！</p></li><li><p>接下来才是本篇文章的重点。也是云跟帖不足的一个地方。之前多说收到评论会在博客的右上角提示，云跟帖就没有这个功能，而且也不会收到邮件，这样就不能即时的处理评论。好在提供了收到评论的回调功能，所以我们自己来实现发送邮件的功能。</p></li></ul><h2 id="数据回推"><a href="#数据回推" class="headerlink" title="数据回推"></a>数据回推</h2><p>在获取代码里面有个优化设置功能，需要我们自己设置接口来接受评论推送。以下邮件评论提示由php来实现。php模拟邮箱登录发送邮件采用如下库：<a href="http://download.csdn.net/download/zhong960725/9755214" target="_blank" rel="noopener">http://download.csdn.net/download/zhong960725/9755214</a><br>，亲测能正常使用，需要配置smtp服务区，端口，帐号和密码等。 网易通过结果返回的数据如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "title" : "xxx",//文章标题</span><br><span class="line">    "url" : "http://localhost/1.htm",//文章url</span><br><span class="line">    "sourceId" : "xxx",//文章唯一id</span><br><span class="line">    "ctime" : 11111,//文章创建时间</span><br><span class="line">    "comments" : [&#123;</span><br><span class="line">        "cid" : "xxx",//跟贴id</span><br><span class="line">        "content" : "xxxx",//内容</span><br><span class="line">        "ctime" : 11111,//创建时间</span><br><span class="line">        "pid" : "xxxx",//父贴id</span><br><span class="line">        "ip" : "127.0.0.1",//发贴ip</span><br><span class="line">        "source" : "web",//来源 app,web,wap</span><br><span class="line">        "anonymous" : false,//是否匿名跟贴 false：非匿名 true：匿名</span><br><span class="line">        "attachment" : &#123;</span><br><span class="line">          "type" : 0,//0没有附件 1为图片 2为语音 3为视频</span><br><span class="line">          "desc" : "xxx",//描述</span><br><span class="line">          "info" : "http://localhost/1.jpg"//附件地址</span><br><span class="line">        &#125;,</span><br><span class="line">        "user" : &#123;</span><br><span class="line">          "userId" : "xxx",//第三方用户id</span><br><span class="line">          "nickname" : "xxx",//昵称</span><br><span class="line">          "avatar" : "http://localhost/2.png"//头像地址</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><ul><li>搭建<code>web</code>服务器,博客前面有提到，可以<a href="https://blog.ihoey.com/posts/Linux/2017-05-26-liunx-shell.html">Linux常用命令笔记</a></li><li>搭建<code>PHP</code>环境,由于我的服务器是<code>Ubuntu 16.04</code>的,所以貌似不能安装<code>php5</code>了,所以这里是<code>php7</code>。<ul><li>安装<code>PHP</code> : <code>sudo apt-get install -y php7.0 php7.0-fpm php7.0-cli php7.0-common php7.0-mbstring php7.0-gd php7.0-intl php7.0-xml php7.0-mysql php7.0-mcrypt php7.0-zip</code>.</li></ul></li><li><p>配置<code>nginx</code>,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name xxxx.xxx.xxx;</span><br><span class="line"></span><br><span class="line">        root   /var/www/comment;</span><br><span class="line">        index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                try_files $uri =404;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">                fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我这里将下载的<code>php</code>库文件放到<code>/var/www/comment</code>目录下。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Content-type: text/html; charset=utf-8"</span>);</span><br><span class="line">date_default_timezone_set(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Ihoey</span></span><br><span class="line"><span class="comment"> * User: Ihoey</span></span><br><span class="line"><span class="comment"> * Date: 17/6/22</span></span><br><span class="line"><span class="comment"> * Time: 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">$receiver = $_REQUEST;</span><br><span class="line"><span class="keyword">if</span>(count($receiver) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $content = implode(<span class="string">','</span>, $receiver);</span><br><span class="line">    $json = json_decode($content);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($json) &amp;&amp; count($json) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">require_once</span>(<span class="string">"./functions.php"</span>);</span><br><span class="line">        $title = $json[<span class="number">0</span>]-&gt;title;</span><br><span class="line">        $url = $json[<span class="number">0</span>]-&gt;url;</span><br><span class="line">        $ctime = $json[<span class="number">0</span>]-&gt;ctime;</span><br><span class="line">        $date = date(<span class="string">'Y-m-d H:i:s'</span>, $ctime/<span class="number">1000</span>);</span><br><span class="line">        $name = $json[<span class="number">0</span>]-&gt;comments[<span class="number">0</span>]-&gt;user-&gt;nickname;</span><br><span class="line">        $userId = $json[<span class="number">0</span>]-&gt;comments[<span class="number">0</span>]-&gt;user-&gt;userId;</span><br><span class="line">        $comment = $json[<span class="number">0</span>]-&gt;comments[<span class="number">0</span>]-&gt;content;</span><br><span class="line">        $flag = sendMail(<span class="string">'123456.qq.com'</span>,<span class="string">"您的博客收到一条来自&#123;$name&#125;(&#123;$userId&#125;)的新评论"</span>,</span><br><span class="line">            <span class="string">"文章标题:&lt;br/&gt;&lt;a target='_blank' href='&#123;$url&#125;'&gt;&#123;$title&#125;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;评论内容:&lt;br/&gt;&#123;$name&#125;(&#123;$userId&#125;): &#123;$comment&#125;&lt;br/&gt;&lt;br/&gt;评论时间:&lt;br/&gt;&#123;$date&#125;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&#123;$content&#125;"</span>);</span><br><span class="line">        file_put_contents(<span class="string">'./comment.txt'</span>, $flag ? <span class="string">"success!"</span> : <span class="string">"failure!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comment.php</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="设置回推"><a href="#设置回推" class="headerlink" title="设置回推"></a>设置回推</h2><p>优化设置里面的回推结果设置如下就好<code>http://yourDomain/comment.php</code>;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://oisha19l0.qnssl.com/comment_ihoey.png&quot; alt=&quot;comment_ihoey&quot;&gt;&lt;br&gt;多说官方宣布17年6月1号停止维护，一个优秀的评论系统从此倒下了，令人唏嘘不已，还是要感谢多说团队多年的付出。眼下留给博主们的选择也就畅言和网易云跟帖了。经过综合考虑选择了网易跟帖，由于网易云跟帖没有提醒功能，所以今天就做了一个邮件提醒的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ihoey.com/categories/Linux/"/>
    
    
      <category term="comment" scheme="https://blog.ihoey.com/tags/comment/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令笔记</title>
    <link href="https://blog.ihoey.com/posts/Linux/2017-05-26-liunx-shell.html"/>
    <id>https://blog.ihoey.com/posts/Linux/2017-05-26-liunx-shell.html</id>
    <published>2017-05-26T13:49:04.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录使用到的 <code>Linux</code> 命令!</p><a id="more"></a><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>安装: <code>sudo apt-get install git</code> , <code>git</code> 配置请查看<a href=""></a>。</li></ul><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><ul><li>安装: <code>sudo apt-get install nginx</code></li><li>启动: <code>sudo /etc/init.d/nginx start</code></li><li>停止: <code>sudo /etc/init.d/nginx stop</code></li><li>重启: <code>sudo /etc/init.d/nginx restart</code></li><li>检查配置文件: <code>sudo service nginx configtest</code></li><li>重载配置文件: <code>sudo service nginx reload</code></li><li>查询nginx进程: <code>ps -ef | grep nginx</code></li></ul><h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p><code>sudo vim /etc/nginx/sites-available/default</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only=on;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果要支持HTTPS，修改这里</span></span><br><span class="line">    <span class="comment"># 可以使用 https://letsencrypt.org 的免费SSL证书</span></span><br><span class="line">    <span class="comment">#listen 443 ssl;</span></span><br><span class="line">    <span class="comment">#ssl_certificate     www.example.com.crt;</span></span><br><span class="line">    <span class="comment">#ssl_certificate_key www.example.com.key;</span></span><br><span class="line">    <span class="comment">#ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class="line">    <span class="comment">#ssl_ciphers         HIGH:!aNULL:!MD5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重定向所有HTTP到HTTPS</span></span><br><span class="line">    <span class="comment"># rewrite ^(.*)$ https://$host$1 permanent;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网站根目录，根据需要修改</span></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    <span class="comment"># 增加index.php</span></span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 假设域名是 ssl.mcxiaoke.com</span></span><br><span class="line">    server_name ssl.mcxiaoke.com; <span class="comment">#绑定域名</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#支持php-fpm的配置</span></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        try_files <span class="variable">$uri</span> =404;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        fastcgi_pass unix:/var/run/php5-fpm.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><ul><li>安装: <code>sudo apt-get install mysql-server</code></li></ul><h2 id="安装-php-fpm"><a href="#安装-php-fpm" class="headerlink" title="安装 php-fpm"></a>安装 php-fpm</h2><ul><li>安装: <code>sudo apt-get install php5-fpm</code></li><li>重启: <code>sudo service php5-fpm restart</code></li><li>安装PHP常用扩展: <code>sudo apt-get install php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl php5-xcache</code></li></ul><h2 id="常用linux命令说明"><a href="#常用linux命令说明" class="headerlink" title="常用linux命令说明"></a>常用linux命令说明</h2><ul><li>查看端口占用: <code>lsof -i:80</code></li><li>杀死进程: <code>kill -9 3274</code></li><li><code>tar</code><ul><li>z- 用<code>gzip</code>对存档压缩或解压</li><li>x-从存档展开文件</li><li>v-详细显示处理的文件</li><li>f-指定存档或设备</li></ul></li><li><p><code>chmod</code><br>  +</p></li><li><p>更新源: <code>sudo apt-get update</code></p></li><li>更新已安装的包<code>sudo apt-get upgrade</code></li></ul><h2 id="账号和密码文件"><a href="#账号和密码文件" class="headerlink" title="账号和密码文件"></a>账号和密码文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc/passwd /etc/shadow</span><br><span class="line">-rw-r–r– 1 root root 1611 2011-12-16 05:30 /etc/passwd <span class="comment"># 保存的是账号</span></span><br><span class="line">-rw-r—– 1 root shadow 947 2011-12-16 05:30 /etc/shadow <span class="comment"># 账号的密码等信息</span></span><br></pre></td></tr></table></figure><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br></pre></td></tr></table></figure><ol><li>账号名称</li><li>原先用来保存密码的，现在密码都放在/etc/shadow中，所以这里显示x</li><li>UID，也就是使用者ID。默认的系统管理员的UID为0，我们添加用户的时候最好使用1000以上的UID，1-1000范围的UID最好保留给系统用。</li><li>GID，也就是群组ID</li><li>关于账号的一些说明信息（暂时可以忽略）</li><li>账号的家目录，家目录就是你登陆系统后默认的那个目录</li><li>账号使用的shell</li></ol><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:!:15324:0:99999:7:::</span><br><span class="line">daemon:*:15259:0:99999:7:::</span><br><span class="line">bin:*:15259:0:99999:7:::</span><br><span class="line">letuknowit:<span class="variable">$1</span><span class="variable">$cPf</span>/cIvr<span class="variable">$sCws95uSip2ljTK052DDB</span>.:15400:5:60:7:2:15490:</span><br></pre></td></tr></table></figure><ol><li>账户名称（密码需要与账户对应的嘛）</li><li>加密后的密码（总不能学CSDN放明文密码，是吧），如果这一栏的第一个字符为!或者*的话，说明这是一个不能登录的账户，从上面可以看出，ubuntu默认的就不启用root账户。</li><li>最近改动密码的日期（不是日期吗，咋是一堆数字，别急，这个是从1970年1月1日算起的总的天数）。那怎么才能知道今天距1970年1月1日有多少天呢？很简单，你改下密码，然后看下这个栏目中的数字是多少就可以了！</li><li>密码不可被变更的天数：设置了这个值，则表示从变更密码的日期算起，多少天内无法再次修改密码，如果是0的话，则没有限制</li><li>密码需要重新变更的天数：密码经常更换才能保证安全，为了提醒某些经常不更换密码的用户，可以设置一个天数，强制让用户更换密码，也就是说该用户的密码会在多少天后过期，如果为99999则没有限制</li><li>密码过期预警天数：如果在5中设置了密码需要重新变更的天数，则会在密码过期的前多少天进行提醒，提示用户其密码将在多少天后过期</li><li>密码过期的宽恕时间：如果在5中设置的日期过后，用户仍然没有修改密码，则该用户还可以继续使用的天数</li><li>账号失效日期，过了这个日期账号就不能用了</li><li>保留的</li></ol><p>以上面最后用户letuknowit为例（15400对应的日期为2012年3月1日），其保护如下信息：</p><ol><li>用户letuknowit最近一次修改密码的日期是2012年3月1日，</li><li>在2012年3月6日之前不能再改动密码了，</li><li>在2012-3-1到2012-4-29期间letuknowit需要更改密码，</li><li>在2012-4-29之前的7天，letuknowit登陆系统的时候，系统会提示letuknowit其密码即将过期，</li><li>如果letuknowit一直到2012-4-29都没有修改密码，则其仍然可以继续使用该账户2天，2天后该账户将不可用</li><li>无论如何，到了2012年5月29日，该账号都将失效</li></ol><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><ul><li>查看主机名: <code>hostname</code> 或<code>uname –n</code>，均可以查看到当前主机的主机名。</li><li>临时修改主机名: <code>hostname 新主机名</code></li><li>永久修改主机名: <code>/etc/hostname</code>文件中修改</li><li><code>host</code> 文件: <code>/etc/hosts</code> 存放的是域名与ip的对应关系, 添加一个新主机名到<code>127.0.0.1</code>.</li></ul><p>待续中…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录使用到的 &lt;code&gt;Linux&lt;/code&gt; 命令!&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ihoey.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.ihoey.com/tags/Linux/"/>
    
      <category term="shell" scheme="https://blog.ihoey.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>NPM 学习笔记整理</title>
    <link href="https://blog.ihoey.com/posts/Node/2017-05-10-npm.html"/>
    <id>https://blog.ihoey.com/posts/Node/2017-05-10-npm.html</id>
    <published>2017-05-09T19:25:24.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-NPM"><a href="#什么是-NPM" class="headerlink" title="什么是 NPM"></a>什么是 NPM</h1><p><code>npm</code> 之于 <code>Node</code> ，就像 <code>pip</code> 之于 <code>Python</code> , <code>gem</code> 之于 <code>Ruby</code> , <code>composer</code> 之于 <code>PHP</code> 。</p><p><code>npm</code> 是 <code>Node</code> 官方提供的包管理工具，他已经成了 <code>Node</code> 包的标准发布平台，用于 <code>Node</code> 包的发布、传播、依赖控制。<br><code>npm</code> 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p><a id="more"></a><h1 id="为什么要使用-NPM"><a href="#为什么要使用-NPM" class="headerlink" title="为什么要使用 NPM"></a>为什么要使用 NPM</h1><p><code>npm</code> 是随同 <code>Node</code> 一起安装的包管理工具，能解决 <code>Node</code> 代码部署上的很多问题，常见的场景有以下几种：</p><ul><li>允许用户从 <code>npm</code> 服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从 <code>npm</code> 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到 <code>npm</code> 服务器供别人使用。</li></ul><p><code>npm</code> 的背后，是基于 <code>CouchDB</code> 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p><h1 id="如何使用-NPM"><a href="#如何使用-NPM" class="headerlink" title="如何使用 NPM"></a>如何使用 NPM</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm</code> 不需要单独安装。在安装 <code>Node</code> 的时候，会连带一起安装 <code>npm</code> 。但是，<code>Node</code> 附带的 <code>npm</code> 可能不是最新版本，最后用下面的命令，更新到最新版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure><p>如果是 Window 系统使用以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure><p>也就是使用 <code>npm</code> 安装自己。之所以可以这样，是因为 <code>npm</code> 本身与 <code>Node</code> 的其他模块没有区别。</p><p>然后，运行下面的命令，查看各种信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 命令列表</span></span><br><span class="line">$ npm <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各个命令的简单用法</span></span><br><span class="line">$ npm -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的版本</span></span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的配置</span></span><br><span class="line">$ npm config list -l</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p><code>npm init</code> 用来初始化生成一个新的 <code>package.json</code> 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 <code>-f</code>（代表<code>force</code>）、<code>-y</code>（代表<code>yes</code>），则跳过提问阶段，直接生成一个新的 <code>package.json</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><h3 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h3><p><code>npm set</code> 用来设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">set</span> init-author-name <span class="string">'Your name'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-email <span class="string">'Your email'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-url <span class="string">'http://yourdomain.com'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-license <span class="string">'MIT'</span></span><br></pre></td></tr></table></figure><p>上面命令等于为 <code>npm init</code> 设置了默认值，以后执行 <code>npm init</code> 的时候，<code>package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 <code>~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 <code>npm config</code>。</p><h3 id="npm-info"><a href="#npm-info" class="headerlink" title="npm info"></a>npm info</h3><p><code>npm info</code> 命令可以查看每个模块的具体信息。比如，查看 <code>underscore</code> 模块的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore</span><br></pre></td></tr></table></figure><p>上面命令返回一个 <code>JavaScript</code> 对象，包含了 <code>underscore</code> 模块的详细信息。这个对象的每个成员，都可以直接从 <code>info</code> 命令查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore description</span><br><span class="line"></span><br><span class="line">$ npm info underscore homepage</span><br><span class="line"></span><br><span class="line">$ npm info underscore version</span><br></pre></td></tr></table></figure><h3 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h3><p><code>npm search</code> 命令用于搜索 <code>npm</code> 仓库，它后面可以跟字符串，也可以跟正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;搜索词&gt;</span><br></pre></td></tr></table></figure><h3 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h3><p><code>npm list</code> 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 global 参数，会列出全局安装的模块</span></span><br><span class="line">$ npm list -global</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm list 命令也可以列出单个模块</span></span><br><span class="line">$ npm list underscore</span><br></pre></td></tr></table></figure><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p>使用 <code>npm</code> 安装包的命令格式为：<code>npm [install/i] [package_name]</code></p><h4 id="本地模式和全局模式"><a href="#本地模式和全局模式" class="headerlink" title="本地模式和全局模式"></a>本地模式和全局模式</h4><p><code>npm</code> 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">NPM</a> 搜索或下载包，将包安装到当前目录的 <code>node_modules</code> 子目录下。</p><p>如果你熟悉 <code>Ruby</code> 的 <code>gem</code> 或者 <code>Python</code> 的 <code>pip</code> ，你会发现 <code>npm</code> 与它们的行为不同， <code>gem</code> 或 <code>pip</code> 总是以全局模式安装，使包可以供所有的程序使用，而 <code>npm</code> 默认会把包安装到当前目录下。这反映了 <code>npm</code> 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 <code>API</code> 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p><p>我们在使用 <code>supervisor</code> 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 <code>supervisor</code> 。</p><p>这里注意一点的就是， <code>supervisor</code> 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 <code>supervisor</code> 来启动服务了。<br><code>supervisor</code> 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 <code>Node</code> 。</p><p>一般来说，全局安装只适用于工具模块，比如 <code>eslint</code> 和 <code>gulp</code> 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 <strong>本地模式不会注册 <code>PATH</code> 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 <code>node_modules</code> 子目录，然后只有在项目目录之中，才能调用这个模块。</p><p>本地模式和全局模式的特点如下：</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">可通过 require 使用</th><th style="text-align:center">注册 PATH</th></tr></thead><tbody><tr><td style="text-align:center">本地模式</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">全局模式</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr></tbody></table><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地安装</span></span><br><span class="line">$ npm install &lt;package name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">$ sudo npm install -global &lt;package name&gt;</span><br><span class="line">$ sudo npm install -g &lt;package name&gt;</span><br></pre></td></tr></table></figure><p><code>npm install</code> 也支持直接输入 <code>Github</code> 代码库地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install git://github.com/package/path.git</span><br><span class="line">$ npm install git://github.com/package/path.git<span class="comment">#0.1.0</span></span><br></pre></td></tr></table></figure><p>安装之前，<code>npm install</code> 会先检查，<code>node_modules</code> 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p><p>如果你希望，一个模块不管是否安装过， <code>npm</code> 都要强制重新安装，可以使用 <code>-f</code> 或 <code>--force</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;packageName&gt; --force</span><br></pre></td></tr></table></figure><h4 id="安装不同版本"><a href="#安装不同版本" class="headerlink" title="安装不同版本"></a>安装不同版本</h4><p><code>install</code> 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 <code>@</code> 和版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax@latest</span><br><span class="line">$ npm install sax@0.1.1</span><br><span class="line">$ npm install sax@<span class="string">"&gt;=0.1.0 &lt;0.2.0"</span></span><br></pre></td></tr></table></figure><p><code>install</code> 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 <code>packages.json</code> 文件的哪一项中。</p><blockquote><p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax --save</span><br><span class="line">$ npm install node-tap --save-dev</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ npm install sax -S</span><br><span class="line">$ npm install node-tap -D</span><br></pre></td></tr></table></figure><h5 id="dependencies-依赖"><a href="#dependencies-依赖" class="headerlink" title="dependencies 依赖"></a>dependencies 依赖</h5><p>这个可以说是我们 <code>npm</code> 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 <code>js</code> 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 <code>npm install</code> 命令的时候， <code>npm</code> 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"markdown-it"</span>: <span class="string">"^8.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="devDependencies-开发依赖"><a href="#devDependencies-开发依赖" class="headerlink" title="devDependencies 开发依赖"></a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 <code>devDependencies</code> 的包，在别人引用的时候不会被 <code>npm</code> 下载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"autoprefixer"</span>: <span class="string">"^6.4.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-2"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="string">"babel-register"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^1.13.2"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-middleware"</span>: <span class="string">"^1.8.3"</span>,</span><br><span class="line">    <span class="string">"webpack-hot-middleware"</span>: <span class="string">"^2.12.2"</span>,</span><br><span class="line">    <span class="string">"webpack-merge"</span>: <span class="string">"^0.14.1"</span>,</span><br><span class="line">    <span class="string">"highlightjs"</span>: <span class="string">"^9.8.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你有了一个完整的 <code>package.json</code>文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 <code>npm install</code> 就可以很方便的下载好这个模块所需要的包。</p><p><code>npm install</code> 默认会安装 <code>dependencies</code> 字段和 <code>devDependencies</code> 字段中的所有模块，如果使用 <code>--production</code> 参数，可以只安装 <code>dependencies</code> 字段的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --production</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ NODE_ENV=production npm install</span><br></pre></td></tr></table></figure><p>一旦安装了某个模块，就可以在代码中用 <code>require</code> 命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backbone = <span class="built_in">require</span>(<span class="string">'backbone'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(backbone.VERSION)</span><br></pre></td></tr></table></figure><h3 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h3><p><code>npm</code> 不仅可以用于模块管理，还可以用于执行脚本。<code>package.json</code> 文件有一个 <code>scripts</code> 字段，可以用于指定脚本命令，供 <code>npm</code> 直接调用。<br><code>package.json</code> 文件内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"browserify"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"mocha"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"jshint **.js"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"mocha test/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scripts-脚本"><a href="#scripts-脚本" class="headerlink" title="scripts 脚本"></a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 <code>package.json</code> 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 <code>scripts</code> 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br><code>npm run</code> 是 <code>npm run-script</code> 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">    <span class="string">"docs"</span>: <span class="string">"node build/docs.js"</span>,</span><br><span class="line">    <span class="string">"build-docs"</span>: <span class="string">"npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master"</span>,</span><br><span class="line">    <span class="string">"build-publish"</span>: <span class="string">"rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push"</span>,</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>npm run</code> 如果不加任何参数，直接运行，会列出 <code>package.json</code> 里面所有可以执行的脚本命令。<br><code>npm</code> 内置了两个命令简写， <code>npm test</code> 等同于执行 <code>npm run test</code> ，<code>npm start</code> 等同于执行 <code>npm run start</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: <span class="string">"npm run build-js &amp;&amp; npm run build-css"</span></span><br></pre></td></tr></table></figure><p>上面的写法是先运行 <code>npm run build-js</code> ，然后再运行 <code>npm run build-css</code> ，两个命令中间用 <code>&amp;&amp;</code> 连接。如果希望两个命令同时平行执行，它们中间可以用 <code>&amp;</code> 连接。</p><p>写在 <code>scripts</code> 属性中的命令，也可以在 <code>node_modules/.bin</code> 目录中直接写成 <code>bash</code> 脚本。下面是一个 <code>bash</code> 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> site/main</span><br><span class="line">browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</span><br></pre></td></tr></table></figure><p>假定上面的脚本文件名为 <code>build.sh</code> ，并且权限为可执行，就可以在 <code>scripts</code> 属性中引用该文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build-js"</span>: <span class="string">"bin/build.sh"</span></span><br></pre></td></tr></table></figure><h3 id="pre-和-post-脚本"><a href="#pre-和-post-脚本" class="headerlink" title="pre- 和 post- 脚本"></a>pre- 和 post- 脚本</h3><p><code>npm run</code> 为每条命令提供了 <code>pre-</code> 和 <code>post-</code> 两个钩子（ <code>hook</code> ）。以 <code>npm run lint</code> 为例，执行这条命令之前， <code>npm</code> 会先查看有没有定义 <code>prelint</code> 和 <code>postlint</code> 两个钩子，如果有的话，就会先执行 <code>npm run prelint</code> ，然后执行 <code>npm run lint</code> ，最后执行 <code>npm run postlint</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"eslint"</span>: <span class="string">"latest"</span></span><br><span class="line">    <span class="string">"karma"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --cache --ext .js --ext .jsx src"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"karma start --log-leve=error karma.config.js --single-run=true"</span>,</span><br><span class="line">    <span class="string">"pretest"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">    <span class="string">"posttest"</span>: <span class="string">"echo 'Finished running tests'"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个 <code>package.json</code> 文件的例子。如果执行 <code>npm test</code>，会按下面的顺序执行相应的命令。</p><ol><li><code>pretest</code></li><li><code>test</code></li><li><code>posttest</code></li></ol><p>如果执行过程出错，就不会执行排在后面的脚本，即如果 <code>prelint</code> 脚本执行出错，就不会接着执行 <code>lint</code> 和 <code>postlint</code> 脚本。</p><h3 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h3><p><code>npm bin</code> 命令显示相对于当前目录的，<code>Node</code> 模块的可执行脚本所在的目录（即 <code>.bin</code> 目录）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下执行</span></span><br><span class="line">$ npm bin</span><br><span class="line">./node_modules/.bin</span><br></pre></td></tr></table></figure><h1 id="创建全局链接"><a href="#创建全局链接" class="headerlink" title="创建全局链接"></a>创建全局链接</h1><p><code>npm</code> 提供了一个有趣的命令 <code>npm link</code>，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 <code>require</code> 使用。但通过 <code>npm link</code> 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 <code>express</code> ，这时在工程的目录下运行命令：<code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 <code>node_modules</code> 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 <code>npm link</code> 命令还可以将本地的包链接到全局。使用方法是在包目录（<code>package.json</code> 所在目录）中运行 <code>npm link</code> 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p><h1 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h1><p>包是在模块基础上更深一步的抽象，<code>Node</code> 的包类似于 <code>C/C++</code> 的函数库或者 <code>Java</code> 、<code>.Net</code> 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。<code>Node</code> 根据 <code>CommonJS</code> 规范实现了包机制，开发了 <code>npm</code> 来解决包的发布和获取需求。<br><code>Node</code> 的包是一个目录，其中包含了一个 <code>JSON</code> 格式的包说明文件 <code>package.json</code>。严格符合 <code>CommonJS</code> 规范的包应该具备以下特征：</p><ul><li><code>package.json</code> 必须在包的顶层目录下；</li><li>二进制文件应该在 <code>bin</code> 目录下；</li><li><code>JavaScript</code> 代码应该在 <code>lib</code> 目录下；</li><li>文档应该在 <code>doc</code> 目录下；</li><li>单元测试应该在 <code>test</code> 目录下。</li></ul><p><code>Node</code> 对包的要求并没有这么严格，只要顶层目录下有 <code>package.json</code>，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 <code>CommonJS</code> 规范。</p><p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 <code>package.json</code>，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p><p><code>Node</code> 在调用某个包时，会首先检查包中 <code>packgage.json</code> 文件的 <code>main</code> 字段，将其作为包的接口模块，如果 <code>package.json</code> 或 <code>main</code> 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p><p><code>package.json</code> 是 <code>CommonJS</code> 规定的用来描述包的文件，完全符合规范的 <code>package.json</code> 文件应该含有以下字段：<br><span id="inline-yellow">name</span>: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br><span id="inline-blue">description</span>: 包的简要说明。<br><span id="inline-green">version</span>: 符合语义化版本识别规范的版本字符串。<br><span id="inline-red">keywords</span>: 关键字数组，通常用于搜索。<br><span id="inline-purple">maintainers</span>: 维护者数组，每个元素要包含 <code>name</code> 、 <code>email</code>(可选)、 <code>web</code>(可选)字段。<br><span id="inline-yellow">contributors</span>: 贡献者数组，格式与 <code>maintainers</code> 相同。包的作者应该是贡献者数组的第一个元素。<br><span id="inline-blue">bugs</span>: 提交 <code>bug</code> 的地址，可以是网址或者电子邮件地址。<br><span id="inline-green">licenses</span>: 许可证数组，每个元素要包含 <code>type</code> （许可证的名称）和 url（链接到许可证文本的地址）字段。<br><span id="inline-red">repositories</span>: 仓库托管地址数组，每个元素要包含 <code>type</code> （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br><span id="inline-purple">dependencies</span>: 包的依赖，一个关联数组，由包名称和版本号组成。</p><h1 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h1><p>通过使用 <code>npm init</code> 可以根据交互式回答产生一个符合标准的 <code>package.json</code>。创建一个 <code>index.js</code> 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 <code>npm adduser</code> 根据提示完成账号的创建<br>完成后可以使用 <code>npm whoami</code> 检测是否已经取得了账号。<br>接下来,在 <code>package.json</code> 所在目录下运行 <code>npm publish</code>，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">NPM搜索</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 <code>npm install neveryumodule</code> 命令来安装它。<br>如果你的包将来有更新,只需要在 <code>package.json</code> 文件中修改 <code>version</code> 字段,然后重新使用 <code>npm publish</code>命令就行了。<br>如果你对已发布的包不满意，可以使用 <code>npm unpublish</code> 命令来取消发布。</p><p id="div-border-top-yellow"><em>需要说明的是： <code>json</code> 文件不能有注释</em><br></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/npm.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-NPM&quot;&gt;&lt;a href=&quot;#什么是-NPM&quot; class=&quot;headerlink&quot; title=&quot;什么是 NPM&quot;&gt;&lt;/a&gt;什么是 NPM&lt;/h1&gt;&lt;p&gt;&lt;code&gt;npm&lt;/code&gt; 之于 &lt;code&gt;Node&lt;/code&gt; ，就像 &lt;code&gt;pip&lt;/code&gt; 之于 &lt;code&gt;Python&lt;/code&gt; , &lt;code&gt;gem&lt;/code&gt; 之于 &lt;code&gt;Ruby&lt;/code&gt; , &lt;code&gt;composer&lt;/code&gt; 之于 &lt;code&gt;PHP&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm&lt;/code&gt; 是 &lt;code&gt;Node&lt;/code&gt; 官方提供的包管理工具，他已经成了 &lt;code&gt;Node&lt;/code&gt; 包的标准发布平台，用于 &lt;code&gt;Node&lt;/code&gt; 包的发布、传播、依赖控制。&lt;br&gt;&lt;code&gt;npm&lt;/code&gt; 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="https://blog.ihoey.com/categories/Node/"/>
    
    
      <category term="Node" scheme="https://blog.ihoey.com/tags/Node/"/>
    
      <category term="npm" scheme="https://blog.ihoey.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>重新认识伪类和伪元素</title>
    <link href="https://blog.ihoey.com/posts/CSS3/2017-04-28-pseudo-elements-and-pseudo-classes.html"/>
    <id>https://blog.ihoey.com/posts/CSS3/2017-04-28-pseudo-elements-and-pseudo-classes.html</id>
    <published>2017-04-28T08:35:10.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉前端的人都会听过<code>css</code>的伪类与伪元素，然而大多数的人都会将这两者混淆(包括我)。那今天就让我们来看看伪类和伪元素的区别吧!</p><a id="more"></a><h2 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h2><p>先说一说为什么<code>css</code>要引入伪元素和伪类，以下是<code>css2.1 Selectors</code>章节中对伪类与伪元素的描述：</p><p><code>CSS introduces the concepts of pseudo-elements and pseudo-classes  to permit formatting based on information that lies outside the document tree.</code></p><ul><li>直译过来就是：<code>css</code>引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释：<ul><li>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。虽然它和普通的<code>css</code>类相似，可以为已有的元素添加样式，但是它只有处于<code>dom</code>树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li><li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过<code>:before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li></ul></li></ul><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><ul><li>伪类前面是一个冒号，<code>E:first-child</code> 伪类，会对现有的元素进行筛选<ul><li><code>:link</code></li><li><code>:visited</code></li><li><code>:hover</code></li><li><code>:active</code></li><li><code>:focus</code></li><li><code>:not()</code></li><li><code>:first-child</code></li><li><code>:last-child</code></li><li><code>:nth-child</code></li><li><code>:nth-last-child</code> 从后面计数</li><li><code>:only-child</code> 只满足一个子元素</li><li><code>:target</code> 当URL带有锚名称，指向文档内某个具体的元素时，<code>:target</code>匹配该元素。</li><li><code>:checked</code> 被选中的input元素</li><li><code>:empty</code> 匹配没有子元素的元素</li><li><code>:valid</code> 匹配条件验证正确的表单元素。</li></ul></li></ul><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><ul><li>伪元素前面是两个冒号，<code>E::first-line</code> 伪元素。会创造出不存在的新元素，由于 <code>css</code> 对单冒号的伪元素也支持，所以这样很容易让新学者混淆。但实际上现在 <code>css3</code> 已经明确规定了伪类单冒号，伪元素双冒号的规则。<ul><li><code>::before/:before</code> 在被选元素前插入内容</li><li><code>::after/:after</code> 在被元素后插入内容，其用法和特性与<code>:before</code>相似。</li><li><code>::first-letter/:first-letter</code> 匹配元素中文本的首字母。被修饰的首字母不在文档树中</li><li><code>::first-line/:first-line</code> 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。</li><li><code>::selection</code> 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加<code>-moz</code>前缀。该伪元素只支持双冒号的形式。</li><li><code>::placeholder</code> 匹配占位符的文本，只有元素设置了<code>placeholder</code>属性时，该伪元素才能生效。</li></ul></li><li>该伪元素不是<code>CSS</code>的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。<br>在一些浏览器中（<code>IE10</code>和<code>Firefox18</code>及其以下版本）会使用单冒号的形式。</li><li>对于伪元素 <code>:before</code> 和 <code>:after</code> 而言，属性 <code>content</code> 是必须设置的，我们知道属性的值可以为字符串，也可以有其它形式，比如指向一张图片的 <code>URL:</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content: url(&apos;img/icon.png&apos;)</span><br></pre></td></tr></table></figure><ul><li>配合伪类使用<ul><li>伪元素 <code>:before</code> 还可以配合伪类使用，这里举经常与 <code>:before</code> 配合使用的伪类 <code>:hover</code> 为例：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.before:hover:before&#123;content:&apos;you before&apos;; color:red;&#125;</span><br><span class="line">&lt;div class=&quot;before&quot;&gt; me&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>配合取值函数 <code>attr()</code> 使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a::before&#123;content: attr(title)&#125;</span><br><span class="line">&lt;a href=&quot;https://blog.ihoey.com&quot; title=&quot;梦魇小栈&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line">&lt;a href=&quot;https://blog.ihoey.com&quot; title=&quot;梦魇小栈&quot;&gt;梦魇小栈&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 <code>css3</code> 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。</li><li>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉前端的人都会听过&lt;code&gt;css&lt;/code&gt;的伪类与伪元素，然而大多数的人都会将这两者混淆(包括我)。那今天就让我们来看看伪类和伪元素的区别吧!&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://blog.ihoey.com/categories/CSS3/"/>
    
    
      <category term="伪类" scheme="https://blog.ihoey.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
      <category term="伪元素" scheme="https://blog.ihoey.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令学习及整理</title>
    <link href="https://blog.ihoey.com/posts/Git/2017-04-23-git.html"/>
    <id>https://blog.ihoey.com/posts/Git/2017-04-23-git.html</id>
    <published>2017-04-23T02:23:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用Git比较多，所以大概整理下 <strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装软件就不多说了，这个肯定都会了</p><ul><li>下载地址：<a class="active" href="https://git-scm.com/downloads" rel="noopener" target="_blank">Downloads</a></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"ihoey"</span>           <span class="comment"># 设置git用户名</span></span><br><span class="line">git config --global user.email <span class="string">"mail@ihoey.com"</span> <span class="comment"># 设置git邮箱</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>               <span class="comment"># 为true是终端着色</span></span><br><span class="line">git config --global alias.co checkout           <span class="comment"># 配置checkout的别名</span></span><br><span class="line">git config --global alias.ci commit             <span class="comment"># 配置commit的别名</span></span><br><span class="line">git config --global alias.st status             <span class="comment"># 配置status的别名</span></span><br><span class="line">git config --global alias.br branch             <span class="comment"># 配置branch的别名</span></span><br><span class="line">git config --global core.editor <span class="string">"mate -w"</span>       <span class="comment"># 设置Editor使用textmate</span></span><br><span class="line">git config -l                                   <span class="comment"># 列举所有配置</span></span><br><span class="line"><span class="comment">#用户的git配置文件~/.gitconfig</span></span><br></pre></td></tr></table></figure><h2 id="SSH-秘钥"><a href="#SSH-秘钥" class="headerlink" title="SSH 秘钥"></a>SSH 秘钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"mail@ihoey.com"</span></span><br><span class="line"><span class="comment"># 连续3个回车。如果不需要密码的话。</span></span><br><span class="line"><span class="comment"># 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面</span></span><br><span class="line"><span class="comment"># id_rsa为你的私钥，不可以告诉别人</span></span><br><span class="line"><span class="comment"># id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面</span></span><br></pre></td></tr></table></figure><h2 id="GitHub-测试"><a href="#GitHub-测试" class="headerlink" title="GitHub 测试"></a>GitHub 测试</h2><p><em>ssh -T git@github.com</em> 将公钥放在<code>github</code>测试是否验证通过命令，选择 <code>yes</code> 如果看到 <code>Hi</code> 后面是你的用户名，就说明成功了。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>创建<code>git</code>仓库 <code>git init</code></li><li>添加文件到暂存区 <code>git add fileName</code> / <code>git add .</code></li><li>提交文件到仓库 <code>git commit -m &quot;版本提交信息&quot;</code></li><li>查看文件提交状态 <code>git status</code></li><li>查看文件修改的信息 <code>git diff readme.txt</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;          <span class="comment"># 显示command的help</span></span><br><span class="line">git show                    <span class="comment"># 显示某次提交的内容</span></span><br><span class="line">git show <span class="variable">$id</span></span><br><span class="line"></span><br><span class="line">git checkout  -- &lt;file&gt;     <span class="comment"># 抛弃工作区修改</span></span><br><span class="line">git checkout  .             <span class="comment"># 抛弃工作区修改</span></span><br><span class="line"></span><br><span class="line">git add &lt;file&gt;              <span class="comment"># 将工作文件修改提交到本地暂存区</span></span><br><span class="line">git add .                   <span class="comment"># 将所有修改过的工作文件提交暂存区</span></span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt;               <span class="comment"># 从版本库中删除文件</span></span><br><span class="line">git rm &lt;file&gt; --cached      <span class="comment"># 从版本库中删除文件，但不删除文件</span></span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt;            <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line">git reset -- .              <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line">git reset --hard            <span class="comment"># 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"some comments"</span></span><br><span class="line"></span><br><span class="line">git revert &lt;<span class="variable">$id</span>&gt;            <span class="comment"># 恢复某次提交的状态，恢复动作本身也创建了一次提交对象</span></span><br><span class="line">git revert HEAD             <span class="comment"># 恢复最后一次提交的状态</span></span><br></pre></td></tr></table></figure><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt;                 <span class="comment"># 比较当前文件和暂存区文件差异</span></span><br><span class="line">git diff</span><br><span class="line">git diff &lt;<span class="variable">$id1</span>&gt; &lt;<span class="variable">$id2</span>&gt;          <span class="comment"># 比较两次提交之间的差异</span></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt;   <span class="comment"># 在两个分支之间比较</span></span><br><span class="line">git diff --staged               <span class="comment"># 比较暂存区和版本库差异</span></span><br><span class="line">git diff --cached               <span class="comment"># 比较暂存区和版本库差异</span></span><br><span class="line">git diff --<span class="built_in">stat</span>                 <span class="comment"># 仅仅比较统计信息</span></span><br></pre></td></tr></table></figure><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> &lt;file&gt;      <span class="comment"># 查看该文件每次提交记录</span></span><br><span class="line">git <span class="built_in">log</span> -p &lt;file&gt;   <span class="comment"># 查看每次详细修改内容的diff</span></span><br><span class="line">git <span class="built_in">log</span> -p -2       <span class="comment"># 查看最近两次详细修改内容的diff</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>      <span class="comment"># 查看提交统计信息</span></span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch -r                           <span class="comment"># 查看远程分支</span></span><br><span class="line">git branch &lt;new_branch&gt;                 <span class="comment"># 创建新的分支</span></span><br><span class="line">git branch -v                           <span class="comment"># 查看各个分支最后提交信息</span></span><br><span class="line">git branch --merged                     <span class="comment"># 查看已经被合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                  <span class="comment"># 查看尚未被合并到当前分支的分支</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;                   <span class="comment"># 切换到某个分支</span></span><br><span class="line">git checkout -b &lt;new_branch&gt;            <span class="comment"># 创建新的分支，并且切换过去</span></span><br><span class="line">git checkout -b &lt;new_branch&gt; &lt;branch&gt;   <span class="comment"># 基于branch创建新的new_branch</span></span><br><span class="line">git checkout <span class="variable">$id</span>       <span class="comment"># 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span></span><br><span class="line">git checkout <span class="variable">$id</span> -b &lt;new_branch&gt;        <span class="comment"># 把某次历史提交记录checkout出来，创建成一个分支</span></span><br><span class="line">git branch -d &lt;branch&gt;                  <span class="comment"># 删除某个分支</span></span><br><span class="line">git branch -D &lt;branch&gt; <span class="comment"># 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span></span><br></pre></td></tr></table></figure><h2 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;               <span class="comment"># 将branch分支合并到当前分支</span></span><br><span class="line">git merge --no-ff &lt;branch&gt;       <span class="comment"># 不要Fast-Foward合并，这样可以生成merge提交</span></span><br><span class="line">git rebase master &lt;branch&gt;       <span class="comment"># 将master rebase到branch，相当于：</span></span><br><span class="line">git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><ul><li>在我们操作过程中。<code>merge</code>操作遇到冲突的时候，当前<code>merge</code>不能继续进行下去。手动修改冲突内容后，<code>add</code> 修改，<code>commit</code> 就可以了。</li><li>而<code>rebase</code> 操作的话，会中断<code>rebase</code>,同时会提示去解决冲突。解决冲突后,将修改<code>add</code>后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li></ul><h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                        <span class="comment"># 暂存</span></span><br><span class="line">git stash list                   <span class="comment"># 列所有stash</span></span><br><span class="line">git stash apply                  <span class="comment"># 恢复暂存的内容</span></span><br><span class="line">git stash drop                   <span class="comment"># 删除暂存区</span></span><br></pre></td></tr></table></figure><h2 id="远程分支管理"><a href="#远程分支管理" class="headerlink" title="远程分支管理"></a>远程分支管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git pull                         <span class="comment"># 抓取远程仓库所有分支更新并合并到本地</span></span><br><span class="line">git pull --no-ff                 <span class="comment"># 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span></span><br><span class="line">git fetch origin                 <span class="comment"># 抓取远程仓库更新</span></span><br><span class="line">git merge origin/master          <span class="comment"># 将远程主分支合并到本地当前分支</span></span><br><span class="line">git checkout --track origin/branch     <span class="comment"># 跟踪某个远程分支创建相应的本地分支</span></span><br><span class="line">git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  <span class="comment"># 基于远程分支创建本地分支，功能同上</span></span><br><span class="line">git push                         <span class="comment"># push所有分支</span></span><br><span class="line">git push origin master           <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line">git push -u origin master        <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line">git push origin &lt;local_branch&gt;   <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  <span class="comment"># 创建远程分支</span></span><br><span class="line">git push origin :&lt;remote_branch&gt; <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br></pre></td></tr></table></figure><h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v                    <span class="comment"># 查看远程服务器地址和仓库名称</span></span><br><span class="line">git remote show origin           <span class="comment"># 查看远程服务器仓库状态</span></span><br><span class="line">git remote add origin git@github.com:ihoey/blog.git     <span class="comment"># 添加远程仓库地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:ihoey/blog.git <span class="comment"># 设置远程仓库地址(用于修改远程仓库地址)</span></span><br><span class="line">git remote rm &lt;repository&gt;       <span class="comment"># 删除远程仓库</span></span><br></pre></td></tr></table></figure><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare ihoey.com blog.git     <span class="comment"># 用带版本的项目创建纯版本仓库</span></span><br><span class="line">scp -r my_blog.git git@ihoey.com:~      <span class="comment"># 将纯仓库上传到服务器上</span></span><br><span class="line">mkdir blog.git &amp;&amp; <span class="built_in">cd</span> blog.git &amp;&amp; git --bare init <span class="comment"># 在服务器创建纯仓库</span></span><br><span class="line"></span><br><span class="line">git push -u origin master         <span class="comment"># 客户端首次提交</span></span><br><span class="line">git push -u origin develop        <span class="comment"># 首次将本地develop分支提交到远程develop分支，并且track</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-head origin master <span class="comment"># 设置远程仓库的HEAD指向master分支</span></span><br></pre></td></tr></table></figure><h2 id="设置跟踪远程库和本地库"><a href="#设置跟踪远程库和本地库" class="headerlink" title="设置跟踪远程库和本地库"></a>设置跟踪远程库和本地库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream master origin/master      <span class="comment">#master</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream develop origin/develop    <span class="comment">#develop</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir XX    <span class="comment">#(创建一个空目录 XX指目录名)</span></span><br><span class="line"><span class="built_in">pwd</span>         <span class="comment">#显示当前目录的路径。</span></span><br><span class="line">cat XX      <span class="comment">#查看XX文件内容</span></span><br><span class="line">rm  XX      <span class="comment">#删除文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用Git比较多，所以大概整理下 &lt;strong&gt;Git是目前世界上最先进的分布式版本控制系统。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://blog.ihoey.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://blog.ihoey.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 使用 Cron 实现计划任务</title>
    <link href="https://blog.ihoey.com/posts/Cron/2017-04-22-Cron.html"/>
    <id>https://blog.ihoey.com/posts/Cron/2017-04-22-Cron.html</id>
    <published>2017-04-21T16:21:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows 自带定时执行任务的工具叫做“计划任务”，Linux 下我们使用 Cron 实现这一功能。</p><a id="more"></a><h2 id="安装-cron-服务"><a href="#安装-cron-服务" class="headerlink" title="安装 cron 服务"></a>安装 cron 服务</h2><ul><li>通常 ubuntu 下自带 cron，如果没有也可以通过以下命令进行安装：<code>apt-get install cron</code></li><li>若已经安装，输入以下命令判断 cron 服务是否启动：<code>pgrep cron</code></li><li>如果有 pid （一串数字）输出则说明 cron 服务已经启动，没有任何输出说明需要手动启动 cron 服务。</li></ul><h2 id="启动-cron-服务"><a href="#启动-cron-服务" class="headerlink" title="启动 cron 服务"></a>启动 cron 服务</h2><ul><li>启动服务 <code>service cron start</code></li></ul><h2 id="编辑计划文件"><a href="#编辑计划文件" class="headerlink" title="编辑计划文件"></a>编辑计划文件</h2><p><code>crontab -e</code></p><p>来打开你的用户所属的crontab文件。第一次用这个命令，会让你选择文本编辑器，我选的是vim。选定的编辑器也可以使用</p><p>你也可以每次自己更改 <code>select-editor</code></p><h2 id="重启-cron-服务"><a href="#重启-cron-服务" class="headerlink" title="重启 cron 服务"></a>重启 cron 服务</h2><p>每次保存了crontab之后，我们还需要重启cron来应用这个计划任务。使用命令：<code>sudo service cron restart</code></p><h2 id="管理任务计划文件"><a href="#管理任务计划文件" class="headerlink" title="管理任务计划文件"></a>管理任务计划文件</h2><p>cron 的所有任务计划都记录在 crontab 任务计划文件中，通过 crontab 命令对该任务文件进行管理。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -u root -e     <span class="comment">#编辑用户 root 的计划任务文件</span></span><br><span class="line"></span><br><span class="line">$ crontab -e            <span class="comment">#编辑当前用户的计划任务文件</span></span><br><span class="line"></span><br><span class="line">$ crontab -u root -l     <span class="comment">#显示用户 root 的计划任务文件</span></span><br><span class="line"></span><br><span class="line">$ crontab -l            <span class="comment">#显示当前用户的计划任务文件</span></span><br><span class="line"></span><br><span class="line">$ crontab -r            <span class="comment">#删除当前用户的计划任务文件</span></span><br></pre></td></tr></table></figure><h2 id="cron-语法格式"><a href="#cron-语法格式" class="headerlink" title="cron 语法格式"></a>cron 语法格式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m h dom mon dow   <span class="built_in">command</span></span><br><span class="line">0-59 0-23 1-31 1-12 0-7  <span class="built_in">command</span></span><br></pre></td></tr></table></figure><ul><li>m: 表示分钟</li><li>h: 表示小时</li><li>dom: 表示日期</li><li>mon: 表示月份</li><li>dow: 表示星期</li><li>command: 预执行的命令</li></ul><p>另外需要使用一些特殊符号实现灵活的配置：</p><ul><li><code>* 代表所有值</code></li><li><code>/ 代表“每”</code></li><li><code>- 代表范围</code></li><li><code>, 分割数字</code></li></ul><h2 id="任务示例"><a href="#任务示例" class="headerlink" title="任务示例"></a>任务示例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 指定具体执行时间</span></span><br><span class="line">2   *  *  *  * ls    <span class="comment">#每个小时的第2分钟执行一次 ls 命令</span></span><br><span class="line">30  7  *  *  * ls    <span class="comment">#每天7：30执行一次 ls 命令</span></span><br><span class="line">30 20  *  *  2 ls    <span class="comment">#每周二，20：30执行一次 ls 命令（0和7表示星期天）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定间隔时间</span></span><br><span class="line">*/2 *  *  *  * ls    <span class="comment">#每隔2分钟执行一次 ls 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定时间段</span></span><br><span class="line">30  7 3-6 *  * ls    <span class="comment">#每个月的3，4，5，6号的7：30分各执行一次 ls 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定多个时间</span></span><br><span class="line">30  7 3,6 *  * ls    <span class="comment">#每月的3号和6号的7：30分各执行一次 ls 命令</span></span><br></pre></td></tr></table></figure><p>另外，使用 run-parts 可以运行指定目录下所有的脚本（注意脚本必须加上 “#!/bin/bash”，否则 run-parts 会调用失败）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 7 * * * run-parts /home   <span class="comment">#每天7：30运行 /home 目录下的所有脚本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows 自带定时执行任务的工具叫做“计划任务”，Linux 下我们使用 Cron 实现这一功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Cron" scheme="https://blog.ihoey.com/categories/Cron/"/>
    
    
      <category term="Ubuntu" scheme="https://blog.ihoey.com/tags/Ubuntu/"/>
    
      <category term="Cron" scheme="https://blog.ihoey.com/tags/Cron/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="https://blog.ihoey.com/posts/MongoDB/2017-03-27-mongodb-ues.html"/>
    <id>https://blog.ihoey.com/posts/MongoDB/2017-03-27-mongodb-ues.html</id>
    <published>2017-03-27T07:07:03.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章介绍学习MongoDB的一些常用命令,希望能帮助大家.</p><a id="more"></a><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><code>Help</code>查看命令提示<ul><li><code>db.help()</code>;</li><li><code>db.yourColl.help()</code>;</li><li><code>db.youColl.find().help()</code>;</li></ul></li><li>切换/创建数据库<ul><li><code>use yourDB</code>;  当创建一个集合(<code>table</code>)的时候会自动创建当前数据库</li></ul></li><li>查询所有数据库<ul><li><code>show dbs</code>;</li></ul></li><li>删除当前使用数据库<ul><li><code>db.dropDatabase()</code>;</li></ul></li><li>从指定主机上克隆数据库<ul><li>从指定主机上克隆数据库</li></ul></li><li>从指定的机器上复制指定数据库数据到某个数据库<ul><li><code>db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;)</code>;将本机的<code>mydb</code>的数据复制到<code>temp</code>数据库中</li></ul></li><li>修复当前数据库<ul><li><code>db.repairDatabase()</code>;</li></ul></li><li>查看当前使用的数据库<ul><li><code>db.getName()</code>;</li></ul></li><li>显示当前db状态<ul><li><code>db.stats()</code>;</li></ul></li><li>当前db版本<ul><li><code>db.version()</code>;</li></ul></li><li>查看当前db的链接机器地址<ul><li><code>db.getMongo()</code>;</li></ul></li></ul><h2 id="Collection聚集集合操作"><a href="#Collection聚集集合操作" class="headerlink" title="Collection聚集集合操作"></a>Collection聚集集合操作</h2><ul><li>创建一个聚集集合（<code>table</code>）<ul><li><code>db.createCollection(“collName”, {size: 20, capped: 5, max: 100})</code>;</li></ul></li><li>得到指定名称的聚集集合（<code>table</code>）<ul><li><code>db.getCollection(&quot;account&quot;)</code>;</li></ul></li><li>得到当前db的所有聚集集合<ul><li><code>db.getCollectionNames()</code>;</li></ul></li><li>显示当前db所有聚集索引的状态<ul><li><code>db.printCollectionStats()</code>;</li></ul></li></ul><h2 id="用户相关操作"><a href="#用户相关操作" class="headerlink" title="用户相关操作"></a>用户相关操作</h2><ul><li>添加一个用户<ul><li><code>db.addUser(&quot;name&quot;)</code>;</li><li><code>db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true)</code>; 添加用户、设置密码、是否只读</li></ul></li><li>数据库认证、安全模式<ul><li><code>db.auth(&quot;userName&quot;, &quot;123123&quot;)</code>;</li></ul></li><li>显示当前所有用户<ul><li><code>show users</code>;</li></ul></li><li>删除用户<ul><li><code>db.removeUser(&quot;userName&quot;)</code>;</li></ul></li></ul><h2 id="聚集集合查询"><a href="#聚集集合查询" class="headerlink" title="聚集集合查询"></a>聚集集合查询</h2><ul><li>查询所有记录<ul><li><code>db.userInfo.find()</code>; 相当于：<code>select* from userInfo</code>;默认每页显示20条记录，当显示不下的情况下,可以用it迭代命令查询下一页数据。注意：键入it命令不能带“;”但是你可以设置每页显示数据的大小,用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。</li></ul></li><li>查询去掉后的当前聚集集合中的某列的重复数据<ul><li><code>db.userInfo.distinct(&quot;name&quot;)</code>;会过滤掉name中的相同数据,相当于：<code>select distict name from userInfo</code>;</li></ul></li><li>查询<code>age = 22</code>的记录<ul><li><code>db.userInfo.find({&quot;age&quot;: 22})</code>; 相当于：<code>select * from userInfo where age = 22</code>;</li></ul></li><li>查询<code>age &gt; 22</code>的记录<ul><li><code>db.userInfo.find({age: {$gt: 22}})</code>;</li></ul></li><li>查询<code>age &lt; 22</code>的记录<ul><li><code>db.userInfo.find({age: {$lt: 22}})</code>;</li></ul></li><li>查询<code>age &gt;= 25</code>的记录<ul><li><code>db.userInfo.find({age: {$gte: 25}})</code>;</li></ul></li><li>查询<code>age &gt;= 23</code> 并且 <code>age &lt;= 26</code><ul><li><code>db.userInfo.find({age: {$gte: 23, $lte: 26}})</code>;</li></ul></li><li>查询<code>name</code>中包含 <code>mongo</code>的数据<ul><li><code>db.userInfo.find({name: /mongo/})</code>;</li></ul></li><li>查询<code>name</code>中以<code>mongo</code>开头的<ul><li><code>db.userInfo.find({name: /^mongo/})</code>;</li></ul></li><li>查询指定列<code>name</code>、<code>age</code>数据<ul><li><code>db.userInfo.find({}, {name: 1, age: 1})</code>;当然<code>name</code>也可以用<code>true</code>或<code>false</code>,当用<code>ture</code>的情况下河<code>name:1</code>效果一样，如果用<code>false</code>就是排除<code>name</code>，显示<code>name</code>以外的列信息。</li></ul></li><li>查询指定列<code>name</code>、<code>age</code>数据, <code>age &gt; 25</code>.<ul><li><code>db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1})</code>;</li></ul></li><li>按照年龄排序<ul><li>升序：<code>db.userInfo.find().sort({age: 1})</code>;</li><li>降序：<code>db.userInfo.find().sort({age: -1})</code>;</li></ul></li><li>查询<code>name = zhangsan, age = 22</code>的数据<ul><li><code>db.userInfo.find({name: &#39;zhangsan&#39;, age: 22})</code>;</li></ul></li><li>查询前5条数据<ul><li><code>db.userInfo.find().limit(5)</code>;</li></ul></li><li>查询10条以后的数据<ul><li><code>db.userInfo.find().skip(10)</code>;</li></ul></li><li>查询在5-10之间的数据<ul><li><code>db.userInfo.find().limit(10).skip(5)</code>;可用于分页，limit是pageSize，skip是第几页*pageSize</li></ul></li><li>or与 查询<ul><li><code>db.userInfo.find({$or: [{age: 22}, {age: 25}]})</code>;</li></ul></li><li>查询第一条数据<ul><li><code>db.userInfo.findOne()</code>;</li><li><code>db.userInfo.find().limit(1)</code>;</li></ul></li><li>查询某个结果集的记录条数<ul><li><code>db.userInfo.find({age: {$gte: 25}}).count()</code>;如果要返回限制之后的记录数量，要使用count(true)或者count(非0)</li><li><code>db.users.find().skip(10).limit(5).count(true)</code>;</li></ul></li><li>按照某列进行排序<ul><li><code>db.userInfo.find({sex: {$exists: true}}).count()</code>;</li></ul></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>创建索引<ul><li><code>db.userInfo.ensureIndex({name: 1})</code>;</li><li><code>db.userInfo.ensureIndex({name: 1, ts: -1})</code>;</li></ul></li><li>查询当前聚集集合所有索引<ul><li><code>db.userInfo.getIndexes()</code>;</li></ul></li><li>查看总索引记录大小<ul><li><code>db.userInfo.totalIndexSize()</code>;</li></ul></li><li>读取当前集合的所有index信息<ul><li><code>db.users.reIndex()</code>;</li></ul></li><li>删除指定索引<ul><li><code>db.users.dropIndex(&quot;name_1&quot;)</code>;</li></ul></li><li>删除所有索引<ul><li><code>db.users.dropIndexes()</code>;</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章介绍学习MongoDB的一些常用命令,希望能帮助大家.&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://blog.ihoey.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://blog.ihoey.com/tags/MongoDB/"/>
    
      <category term="NoSQL" scheme="https://blog.ihoey.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB安装笔记</title>
    <link href="https://blog.ihoey.com/posts/MongoDB/2017-03-23-mongodb.html"/>
    <id>https://blog.ihoey.com/posts/MongoDB/2017-03-23-mongodb.html</id>
    <published>2017-03-23T08:25:11.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mongodb概述"><a href="#mongodb概述" class="headerlink" title="mongodb概述"></a>mongodb概述</h2><ul><li><code>MongoDB</code> 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便. <code>MongoDB</code> 将数据存储为一个文档，数据结构由键值 <code>(key=&gt;value)</code> 对组成。<code>MongoDB</code> 文档类似于 <code>JSON</code> 对象。字段值可以包含其他文档，数组及文档数组。</li></ul><a id="more"></a><h2 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a>mongodb安装</h2><pre><code>mongodb下载地址 `https://www.mongodb.com/download-center#community` ,在此选择对应的系统版本进行安装</code></pre><ul><li><p><code>Windows</code> 系统的安装, 直接下一步即可</p><ul><li>对不知道系统版本和位数的同学这里提供两个命令可查看当前<code>Windows</code>系统的版本和位数.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic os get caption</span><br><span class="line">wmic os get osarchitecture</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Linux</code> 系统的安装:</p><ul><li>导入包管理系统使用的公钥 <code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6</code></li><li>为MongoDB创建一个列表文件:<ul><li><code>Ubuntu 12.04</code> 版本: <code>echo &quot;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu precise/mongodb-org/3.4 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list</code></li><li><code>Ubuntu 14.04</code> 版本: <code>echo &quot;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list</code></li><li><code>Ubuntu 16.04</code> 版本: <code>echo &quot;deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list</code></li></ul></li><li>重新加载本地包数据库 <code>sudo apt-get update</code></li><li>安装<code>MongoDB</code>包 <code>sudo apt-get install -y mongodb-org</code></li></ul></li><li><p><code>OS X</code> 系统的安装</p><ul><li>下载 <code>curl -O https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.4.2.tgz</code></li><li>解压 <code>tar -zxvf mongodb-osx-x86_64-3.4.2.tgz</code></li><li>指定存放文件夹 <code>mkdir -p mongodb &amp;&amp; cp -R -n mongodb-osx-x86_64-3.4.2 / mongodb</code></li><li>设置变量添加到<code>shell</code>的 <code>rc</code>文件中（例如<code>~/.bashrc</code>）： <code>export  PATH = &lt;mongodb-install-directory&gt; / bin：$ PATH</code></li></ul></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li>创建数据目录(我这里是在<code>D</code>盘下) <code>mkdir -p /Server-related/DB</code></li><li>设置数据文件路径(在<code>mongodb</code>安装目录下运行) <code>mongod --dbpath=D:\Server-related\DB</code></li></ul><h2 id="连接mongodb"><a href="#连接mongodb" class="headerlink" title="连接mongodb"></a>连接mongodb</h2><ul><li>打开<code>mongodb</code>安装目录下的 <code>mongo.exe</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mongodb概述&quot;&gt;&lt;a href=&quot;#mongodb概述&quot; class=&quot;headerlink&quot; title=&quot;mongodb概述&quot;&gt;&lt;/a&gt;mongodb概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MongoDB&lt;/code&gt; 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便. &lt;code&gt;MongoDB&lt;/code&gt; 将数据存储为一个文档，数据结构由键值 &lt;code&gt;(key=&amp;gt;value)&lt;/code&gt; 对组成。&lt;code&gt;MongoDB&lt;/code&gt; 文档类似于 &lt;code&gt;JSON&lt;/code&gt; 对象。字段值可以包含其他文档，数组及文档数组。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://blog.ihoey.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://blog.ihoey.com/tags/MongoDB/"/>
    
      <category term="NoSQL" scheme="https://blog.ihoey.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之shadowsocks 服务端安装</title>
    <link href="https://blog.ihoey.com/posts/shadowsocks/2017-03-16-shadowsocks-install.html"/>
    <id>https://blog.ihoey.com/posts/shadowsocks/2017-03-16-shadowsocks-install.html</id>
    <published>2017-03-16T10:38:46.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>轻松搭建<code>shadowsocks</code>,及相关配置说明</p><a id="more"></a><h2 id="安装shadowsocks依赖-我的服务器系统是ubuntu"><a href="#安装shadowsocks依赖-我的服务器系统是ubuntu" class="headerlink" title="安装shadowsocks依赖(我的服务器系统是ubuntu)"></a>安装shadowsocks依赖(我的服务器系统是ubuntu)</h2><ul><li><code>sudo -s</code> // 获取超级管理员权限</li><li><code>apt-get update</code> // 更新apt-get</li><li><code>apt-get install python-pip</code> // 安装python包管理工具pip</li><li><code>pip install shadowsocks</code> // 安装shadowsocks</li></ul><h2 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h2><ul><li><code>vi /etc/shadowsocks.json</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//单一端口</span><br><span class="line">&#123;</span><br><span class="line">    "server":"0.0.0.0",//服务器 ip地址 (IPv4/IPv6)</span><br><span class="line">    "server_port":1121,//服务器监听的端口,注意不要设为使用中的端口</span><br><span class="line">    "local_address":"127.0.0.1",//默认即可</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"password",//密码</span><br><span class="line">    "timeout":300,//超时时间（秒）</span><br><span class="line">    "method":"aes-256-cfb",//加密方式</span><br><span class="line">    "fast_open":false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多端口</span><br><span class="line">  &#123;</span><br><span class="line">   "server":"my_server_ip",  //填入你的IP地址</span><br><span class="line">   "local_address": "127.0.0.1",</span><br><span class="line">   "local_port":1080,</span><br><span class="line">    "port_password": &#123;</span><br><span class="line">        "8381": "foobar1",    //端口号，密码</span><br><span class="line">        "8382": "foobar2",</span><br><span class="line">        "8383": "foobar3",</span><br><span class="line">        "8384": "foobar4"</span><br><span class="line">   &#125;,</span><br><span class="line">   "timeout":300,</span><br><span class="line">   "method":"aes-256-cfb",</span><br><span class="line">   "fast_open": false</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="优化shadowsocks服务"><a href="#优化shadowsocks服务" class="headerlink" title="优化shadowsocks服务"></a>优化shadowsocks服务</h2><ul><li>在终端输入 <code>vi /etc/sysctl.d/local.conf</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># max open files</span><br><span class="line">fs.file-max = 1024000</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"># for high-latency network</span><br><span class="line">net.ipv4.tcp_congestion_control = hybla</span><br><span class="line"># forward ivp4</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><ul><li>配置生效：<code>sysctl --system</code></li></ul><h2 id="开启shadowsocks服务"><a href="#开启shadowsocks服务" class="headerlink" title="开启shadowsocks服务"></a>开启shadowsocks服务</h2><ul><li><code>ssserver -c /etc/shadowsocks.json -d start</code></li></ul><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ul><li><code>ssserver -c /etc/shadowsocks.json -d stop</code></li></ul><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><ul><li>重启(修改配置要重启才生效)：<code>ssserver -c /etc/shadowsocks.json -d restart</code></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><code>/var/log/shadowsocks.log</code></li></ul><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul><li><p><code>ssserver -h</code></p><p>  如果出现故障，试试把<code>/etc/shadowsocks.json</code>里改为<code>&quot;server&quot;=&quot;0.0.0.0&quot;.</code> 小心不要掉<code>,</code></p></li></ul><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><ul><li>在终端输入 <code>vi /etc/rc.local</code></li><li>把 <code>sudo ssserver -c /etc/shadowsocks.json -d start</code>加进去</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;轻松搭建&lt;code&gt;shadowsocks&lt;/code&gt;,及相关配置说明&lt;/p&gt;
    
    </summary>
    
      <category term="shadowsocks" scheme="https://blog.ihoey.com/categories/shadowsocks/"/>
    
    
      <category term="科学上网" scheme="https://blog.ihoey.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="shadowsocks" scheme="https://blog.ihoey.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>adb设备信息查询修改刷机等命令</title>
    <link href="https://blog.ihoey.com/posts/Android/2016-12-22-adb-Android-Debug-Bridge-2.html"/>
    <id>https://blog.ihoey.com/posts/Android/2016-12-22-adb-Android-Debug-Bridge-2.html</id>
    <published>2016-12-22T10:51:53.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>ADB很强大，记住一些ADB命令有助于提高工作效率。<br>通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等</p><a id="more"></a><h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><ul><li><code>adb logcat</code> – 查看日志</li><li><code>adb shell dumpsys battery</code> – 电池状况<br>其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量</li><li><code>adb reboot</code> – 重启</li><li><code>adb get-serialno</code> – 获取序列号</li><li><code>adb shell  cat /sys/class/net/wlan0/address</code> – MAC 地址</li><li><code>adb shell getprop ro.product.model</code> – 型号</li><li><code>adb shell getprop ro.build.version.release</code> – 查看 Android 系统版本</li><li><code>adb shell wm size</code> – 查看屏幕分辨率</li><li><code>adb shell wm density</code> – 查看屏幕密度</li><li><code>adb shell dumpsys window displays</code> – 显示屏参数</li><li><code>adb shell settings get secure android_id</code> – android_id</li><li><code>adb shell ifconfig | grep Mask</code> – IP 地址(powershell无效)</li><li><code>adb shell cat /proc/cpuinfo</code> – CPU 信息</li><li><code>adb shell cat /proc/meminfo</code> – 内存信息(输出内容: <code>MemTotal</code> 总内存，<code>MemFree</code> 空闲内存)</li><li><code>adb shell cat /system/build.prop</code> – 更多硬件与系统属性</li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ro.build.version.sdk</td><td style="text-align:center">SDK 版本</td></tr><tr><td style="text-align:center">ro.build.version.release</td><td style="text-align:center">Android 系统版本</td></tr><tr><td style="text-align:center">ro.build.version.security_patch</td><td style="text-align:center">Android 安全补丁程序级别</td></tr><tr><td style="text-align:center">ro.product.model</td><td style="text-align:center">型号</td></tr><tr><td style="text-align:center">ro.product.brand</td><td style="text-align:center">品牌</td></tr><tr><td style="text-align:center">ro.product.name</td><td style="text-align:center">设备名</td></tr><tr><td style="text-align:center">ro.product.board</td><td style="text-align:center">处理器型号</td></tr><tr><td style="text-align:center">ro.product.cpu.abilist</td><td style="text-align:center">CPU 支持的 abi 列表</td></tr><tr><td style="text-align:center">persist.sys.isUsbOtgEnabled</td><td style="text-align:center">是否支持 OTG</td></tr><tr><td style="text-align:center">dalvik.vm.heapsize</td><td style="text-align:center">每个应用程序的内存上限</td></tr><tr><td style="text-align:center">ro.sf.lcd_density</td><td style="text-align:center">屏幕密度</td></tr></tbody></table><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong>修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p><p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br></pre></td></tr></table></figure><p>表示将分辨率修改为 480px * 1024px。</p><p>恢复原分辨率命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure><h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm density 160</span><br></pre></td></tr></table></figure><p>表示将屏幕密度修改为 160dpi。</p><p>恢复原屏幕密度命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure><h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br></pre></td></tr></table></figure><p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p><p>恢复原显示区域命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br></pre></td></tr></table></figure><h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br></pre></td></tr></table></figure><p>恢复：</p><p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p><p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p><h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p><table><thead><tr><th style="text-align:center">key</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">immersive.full</td><td style="text-align:center">同时隐藏</td></tr><tr><td style="text-align:center">immersive.status</td><td style="text-align:center">隐藏状态栏</td></tr><tr><td style="text-align:center">immersive.navigation</td><td style="text-align:center">隐藏导航栏</td></tr><tr><td style="text-align:center">immersive.preconfirms</td><td style="text-align:center">?</td></tr></tbody></table><p>这些键对应的值可则如下值用逗号组合：</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>apps</code></td><td style="text-align:center">所有应用</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">所有界面</td></tr><tr><td style="text-align:center"><code>packagename</code></td><td style="text-align:center">指定应用</td></tr><tr><td style="text-align:center"><code>-packagename</code></td><td style="text-align:center">排除指定应用</td></tr></tbody></table><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure><p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure><p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p><h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure><p>然后将 png 文件导出到电脑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure><p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-p</td><td style="text-align:center">指定保存文件为 png 格式</td></tr><tr><td style="text-align:center">-d display-id</td><td style="text-align:center">指定截图的显示屏编号（有多显示屏的情况下）</td></tr></tbody></table><p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p><p>直接一行命令截图并保存到电脑的方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p | sed <span class="string">"s/\r$//"</span> &gt; sc.png</span><br></pre></td></tr></table></figure><p>这个方法需要用到 sed 命令，在 Linux 和 Mac 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm" target="_blank" rel="noopener">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p><h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 /sdcard：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p><p>如果需要导出到电脑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">–size WIDTHxHEIGHT</td><td style="text-align:center">视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td></tr><tr><td style="text-align:center">–bit-rate RATE</td><td style="text-align:center">视频的比特率，默认是 4Mbps。</td></tr><tr><td style="text-align:center">–time-limit TIME</td><td style="text-align:center">录制时长，单位秒。</td></tr><tr><td style="text-align:center">–verbose</td><td style="text-align:center">输出更多信息。</td></tr></tbody></table><h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p><p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p><p>步骤：</p><ol><li><p>进入 shell 并切换到 root 用户权限。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure></li><li><p>查看当前分区挂载情况。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</span><br><span class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</span><br><span class="line">none /acct cgroup rw,relatime,cpuacct 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</span><br><span class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br></pre></td></tr></table></figure><p>找到其中我们关注的带 /system 的那一行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure></li><li><p>重新挂载。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</span><br></pre></td></tr></table></figure><p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p></li></ol><p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p><h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">"TP-LINK_9DFC"</span></span><br><span class="line">    scan_ssid=1</span><br><span class="line">    psk=<span class="string">"123456789"</span></span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    group=CCMP TKIP</span><br><span class="line">    auth_alg=OPEN</span><br><span class="line">    sim_num=1</span><br><span class="line">    priority=13893</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">"TP-LINK_F11E"</span></span><br><span class="line">    psk=<span class="string">"987654321"</span></span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    sim_num=1</span><br><span class="line">    priority=17293</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p><h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">date -s 20160823.131500</span><br></pre></td></tr></table></figure><p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p><h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure><p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p><h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p><p>简单用法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure><p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p><p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="开启-关闭-WiFi"><a href="#开启-关闭-WiFi" class="headerlink" title="开启/关闭 WiFi"></a>开启/关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p><p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p><p>开启 WiFi：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>关闭 WiFi：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p><h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p><p>以 Recovery 模式下更新为例：</p><ol><li><p>重启到 Recovery 模式。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure></li><li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p><p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p></li><li><p>通过 adb 上传和更新系统。</p><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure><p>各列含义：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">USER</td><td style="text-align:center">所属用户</td></tr><tr><td style="text-align:center">PID</td><td style="text-align:center">进程 ID</td></tr><tr><td style="text-align:center">PPID</td><td style="text-align:center">父进程 ID</td></tr><tr><td style="text-align:center">NAME</td><td style="text-align:center">进程名</td></tr></tbody></table><h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User 0%, System 6%, IOW 0%, IRQ 0%</span><br><span class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span><br><span class="line"></span><br><span class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name</span></span><br><span class="line"> 8763  0   3% R     1  10640K   1064K  <span class="built_in">fg</span> shell    top</span><br><span class="line">  131  0   3% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_dpc</span><br><span class="line"> 6144  0   0% S   115 1682004K 115916K  <span class="built_in">fg</span> system   system_server</span><br><span class="line">  132  0   0% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_rxf</span><br><span class="line"> 1731  0   0% S     6  20288K    788K  <span class="built_in">fg</span> root     /system/bin/mpdecision</span><br><span class="line">  217  0   0% S     6  18008K    356K  <span class="built_in">fg</span> shell    /sbin/adbd</span><br><span class="line"> ...</span><br><span class="line"> 7779  2   0% S    19 1538748K  48896K  <span class="built_in">bg</span> u0_a71   com.sohu.inputmethod.sogou:classic</span><br><span class="line"> 7963  0   0% S    18 1561916K  59568K  <span class="built_in">fg</span> u0_a58   org.mazhuang.boottimemeasure</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>各列含义：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">PID</td><td style="text-align:center">进程 ID</td></tr><tr><td style="text-align:center">PR</td><td style="text-align:center">优先级</td></tr><tr><td style="text-align:center">CPU%</td><td style="text-align:center">当前瞬间占用 CPU 百分比</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td></tr><tr><td style="text-align:center">#THR</td><td style="text-align:center">线程数</td></tr><tr><td style="text-align:center">VSS</td><td style="text-align:center">Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td></tr><tr><td style="text-align:center">RSS</td><td style="text-align:center">Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td></tr><tr><td style="text-align:center">PCY</td><td style="text-align:center">调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td></tr><tr><td style="text-align:center">UID</td><td style="text-align:center">进程所有者的用户 ID</td></tr><tr><td style="text-align:center">NAME</td><td style="text-align:center">进程名</td></tr></tbody></table><p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">cat</td><td style="text-align:center">显示文件内容</td></tr><tr><td style="text-align:center">cd</td><td style="text-align:center">切换目录</td></tr><tr><td style="text-align:center">chmod</td><td style="text-align:center">改变文件的存取模式/访问权限</td></tr><tr><td style="text-align:center">df</td><td style="text-align:center">查看磁盘空间使用情况</td></tr><tr><td style="text-align:center">grep</td><td style="text-align:center">过滤输出</td></tr><tr><td style="text-align:center">kill</td><td style="text-align:center">杀死指定 PID 的进程</td></tr><tr><td style="text-align:center">ls</td><td style="text-align:center">列举目录内容</td></tr><tr><td style="text-align:center">mount</td><td style="text-align:center">挂载目录的查看和管理</td></tr><tr><td style="text-align:center">mv</td><td style="text-align:center">移动或重命名文件</td></tr><tr><td style="text-align:center">ps</td><td style="text-align:center">查看正在运行的进程</td></tr><tr><td style="text-align:center">rm</td><td style="text-align:center">删除文件</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">查看进程的资源占用情况</td></tr></tbody></table><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: protocol fault (couldn\<span class="string">'t read status): No error</span></span><br></pre></td></tr></table></figure><p><strong>可能原因</strong></p><p>adb server 进程想使用的 5037 端口被占用。</p><p><strong>解决方案</strong></p><p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里 1548 即为进程 ID，用命令结束该进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /PID 1548</span><br></pre></td></tr></table></figure><p>然后再启动 adb 就没问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ADB很强大，记住一些ADB命令有助于提高工作效率。&lt;br&gt;通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blog.ihoey.com/categories/Android/"/>
    
    
      <category term="adb" scheme="https://blog.ihoey.com/tags/adb/"/>
    
      <category term="Android" scheme="https://blog.ihoey.com/tags/Android/"/>
    
      <category term="adb命令" scheme="https://blog.ihoey.com/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>adb(Android Debug Bridge，Android调试桥)常用命令</title>
    <link href="https://blog.ihoey.com/posts/Android/2016-12-18-adb-Android-Debug-Bridge.html"/>
    <id>https://blog.ihoey.com/posts/Android/2016-12-18-adb-Android-Debug-Bridge.html</id>
    <published>2016-12-18T08:18:21.000Z</published>
    <updated>2017-09-14T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>说到 <code>ADB</code> 大家应该都不陌生，即 <code>Android Debug Bridge，Android</code> 调试桥，身为 <code>Android</code> 开发的我们，熟练使用 <code>ADB</code> 命令将会大大提升我们的开发效率， <code>ADB</code> 的命令有很多，今天就来整理下我在开发常用到的一些 ADB 命令。</p><a id="more"></a><p>ADB 的安装这里就不多说了，输入以下命令有如下提示就证明你环境ok，否则自行网上搜索解决下。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><code>adb version</code> – 查看版本</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb version</span><br><span class="line"></span><br><span class="line">Android Debug Bridge version 1.0.36</span><br><span class="line">Revision 8f855a3d9b35-android</span><br></pre></td></tr></table></figure><ul><li><code>adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</code> – adb 命令的基本语法<br>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-d</td><td style="text-align:center">指定当前唯一通过 USB 连接的 Android 设备为命令目标</td></tr><tr><td style="text-align:center">-e</td><td style="text-align:center">指定当前唯一运行的模拟器为命令目标</td></tr><tr><td style="text-align:center">-s <serialnumber></serialnumber></td><td style="text-align:center">指定相应 serialNumber 号的设备/模拟器为命令目标</td></tr></tbody></table><p>在多个设备/模拟器连接的情况下较常用的是 -s <serialnumber> 参数，serialNumber 可以通过 adb devices 命令获取。如：</serialnumber></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">cf264b8f    device</span><br><span class="line">emulator-5554   device</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出里的cf264b8f 和 emulator-5554 即为 serialNumber。比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率：</span></span><br><span class="line"></span><br><span class="line">adb -s cf264b8f shell wm size</span><br></pre></td></tr></table></figure><p>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</p><ul><li><code>adb start-server/adb kill-server</code>– 启动/停止 Server</li></ul><p>一般来说，这两个命令基本不会用到，因为只要设备连接正确，会自动启动 <code>adb server</code> 的，不过大家也需要知道这俩命令。</p><ul><li><code>adb -P &lt;port&gt; start-server</code> – 指定 adb server 的网络端口</li></ul><h2 id="设备连接"><a href="#设备连接" class="headerlink" title="设备连接"></a>设备连接</h2><ul><li><code>adb devices</code> – 查看连接设备</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">adb devices</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过USB:</span></span><br><span class="line">List of devices attached</span><br><span class="line">02ae0c1021089daf       device</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过IP:(会有一个端口号,一般都是5555)</span></span><br><span class="line">List of devices attached</span><br><span class="line">192.168.123.104:5555    device</span><br></pre></td></tr></table></figure><ul><li><code>adb connect &lt;device-ip-address&gt;</code> – 通过 IP 地址连接设备</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">adb connect 192.168.123.104</span><br><span class="line"><span class="comment">#会提示:</span></span><br><span class="line">connected to 192.168.123.104:5555</span><br></pre></td></tr></table></figure><ul><li><code>adb disconnect &lt;device-ip-address&gt;</code> – 断开无线连接</li></ul><h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><ul><li><code>adb install [-l\-r\-s\-d] &lt;path_to_apk&gt;</code> – 安装应用</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-l</td><td style="text-align:center">将应用安装到保护目录 /mnt/asec</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">允许覆盖安装允许覆盖安装</td></tr><tr><td style="text-align:center">-s</td><td style="text-align:center">将应用安装到 sdcard</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">允许降级覆盖安装</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">    adb install</span><br><span class="line">    adb install /Users/storm/temp/demo.apk</span><br><span class="line">    adb install -r demo.apk</span><br><span class="line">    adb install -s demo.apk</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装成功</span></span><br><span class="line">[100%] /data/<span class="built_in">local</span>/tmp/1.apk</span><br><span class="line">    pkg: /data/<span class="built_in">local</span>/tmp/1.apk</span><br><span class="line">Success</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装失败</span></span><br><span class="line">[100%] /data/<span class="built_in">local</span>/tmp/map-20160831.apk</span><br><span class="line">        pkg: /data/<span class="built_in">local</span>/tmp/map-20160831.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br><span class="line"></span><br><span class="line"><span class="comment">#adb install 内部原理简介</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#adb install 实际是分三步完成：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#push apk 文件到 /data/local/tmp。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用 pm install 安装。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除 /data/local/tmp 下的对应 apk 文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</span></span><br></pre></td></tr></table></figure><ul><li><code>adb uninstall [-k] &lt;packagename&gt;</code> – 卸载应用</li></ul><p><packagename> 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。</packagename></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line">adb uninstall com.qihoo360.mobilesafe</span><br><span class="line"><span class="comment">#表示卸载 360 手机卫士。</span></span><br></pre></td></tr></table></figure><ul><li><code>adb shell pm clear &lt;packagename&gt;</code> – 清除应用数据与缓存</li></ul><p><packagename> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</packagename></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">adb shell pm clear com.qihoo360.mobilesafe</span><br><span class="line"><span class="comment">#表示清除 360 手机卫士的数据和缓存。</span></span><br></pre></td></tr></table></figure><ul><li><code>adb shell pm list packages [-f/-d/-e/-s/-3/-i/-u] [FILTER]</code> – 查看应用列表</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">显示列表</th></tr></thead><tbody><tr><td style="text-align:center">无</td><td style="text-align:center">所有应用</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:center">显示应用关联的 apk 文件</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">只显示 disabled 的应用</td></tr><tr><td style="text-align:center">-e</td><td style="text-align:center">只显示 enabled 的应用</td></tr><tr><td style="text-align:center">-s</td><td style="text-align:center">只显示系统应用</td></tr><tr><td style="text-align:center">-3</td><td style="text-align:center">只显示第三方应用</td></tr><tr><td style="text-align:center">[FILTER&gt;]</td><td style="text-align:center">包名包含 <filter> 字符串</filter></td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">    <span class="comment">#系统应用</span></span><br><span class="line">    adb shell pm list packages -s</span><br><span class="line"></span><br><span class="line">    <span class="comment">#第三方应用</span></span><br><span class="line">    adb shell pm list packages -3</span><br><span class="line"></span><br><span class="line">    <span class="comment">#包名包含某字符串的应用</span></span><br><span class="line">    adb shell pm list packages mazhuang</span><br><span class="line"></span><br><span class="line">    <span class="comment">#当然也可以使用 grep 来过滤：</span></span><br><span class="line">    adb shell pm list packages | grep mazhuang</span><br></pre></td></tr></table></figure><ul><li><code>adb shell am force-stop &lt;packagename&gt;</code> – 强制停止应用</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">adb shell am force-stop com.qihoo360.mobilesafe</span><br><span class="line"><span class="comment">#表示停止 360 安全卫士的一切进程与服务。</span></span><br></pre></td></tr></table></figure><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><code>adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</code> – 复制设备里的文件到电脑<br>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</li><li><code>adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</code> – 复制电脑里的文件到设备</li></ul><h2 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键/输入"></a>模拟按键/输入</h2><ul><li><code>adb shell input keyevent &lt;keycode&gt;</code> – 模拟按键/输入</li></ul><table><thead><tr><th style="text-align:center">keycode</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">HOME键</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">返回键</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">打开拨号应用</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">挂断电话</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">增加音量</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">降低音量</td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">电源键</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">拍照（需要在相机应用里）</td></tr><tr><td style="text-align:center">64</td><td style="text-align:center">打开浏览器</td></tr><tr><td style="text-align:center">82</td><td style="text-align:center">菜单键</td></tr><tr><td style="text-align:center">85</td><td style="text-align:center">播放/暂停</td></tr><tr><td style="text-align:center">86</td><td style="text-align:center">停止播放</td></tr><tr><td style="text-align:center">87</td><td style="text-align:center">播放下一首</td></tr><tr><td style="text-align:center">88</td><td style="text-align:center">播放上一首</td></tr><tr><td style="text-align:center">122</td><td style="text-align:center">移动光标到行首或列表顶部</td></tr><tr><td style="text-align:center">123</td><td style="text-align:center">移动光标到行末或列表底部</td></tr><tr><td style="text-align:center">126</td><td style="text-align:center">恢复播放</td></tr><tr><td style="text-align:center">127</td><td style="text-align:center">暂停播放</td></tr><tr><td style="text-align:center">164</td><td style="text-align:center">静音</td></tr><tr><td style="text-align:center">176</td><td style="text-align:center">打开系统设置</td></tr><tr><td style="text-align:center">187</td><td style="text-align:center">切换应用</td></tr><tr><td style="text-align:center">207</td><td style="text-align:center">打开联系人</td></tr><tr><td style="text-align:center">208</td><td style="text-align:center">打开日历</td></tr><tr><td style="text-align:center">209</td><td style="text-align:center">打开音乐</td></tr><tr><td style="text-align:center">210</td><td style="text-align:center">打开计算器</td></tr><tr><td style="text-align:center">220</td><td style="text-align:center">降低屏幕亮度</td></tr><tr><td style="text-align:center">221</td><td style="text-align:center">提高屏幕亮度</td></tr><tr><td style="text-align:center">223</td><td style="text-align:center">系统休眠</td></tr><tr><td style="text-align:center">224</td><td style="text-align:center">点亮屏幕</td></tr><tr><td style="text-align:center">231</td><td style="text-align:center">打开语音助手</td></tr><tr><td style="text-align:center">276</td><td style="text-align:center">如果没有 wakelock 则让系统休眠</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="comment">#电源键</span></span><br><span class="line">adb shell input keyevent 26</span><br><span class="line"></span><br><span class="line"><span class="comment">#菜单键</span></span><br><span class="line">adb shell input keyevent 82</span><br><span class="line"></span><br><span class="line"><span class="comment">#HOME 键</span></span><br><span class="line">adb shell input keyevent 3</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回键</span></span><br><span class="line">adb shell input keyevent 4</span><br><span class="line"></span><br><span class="line"><span class="comment">#音量加/减/静音</span></span><br><span class="line">adb shell input keyevent 24/25/164</span><br><span class="line"></span><br><span class="line"><span class="comment">#滑动解锁(参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标)</span></span><br><span class="line">adb shell input swipe 300 1000 300 500</span><br><span class="line"></span><br><span class="line"><span class="comment">#在焦点处于某文本框时，可以通过 input 命令来输入文本</span></span><br><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到 &lt;code&gt;ADB&lt;/code&gt; 大家应该都不陌生，即 &lt;code&gt;Android Debug Bridge，Android&lt;/code&gt; 调试桥，身为 &lt;code&gt;Android&lt;/code&gt; 开发的我们，熟练使用 &lt;code&gt;ADB&lt;/code&gt; 命令将会大大提升我们的开发效率， &lt;code&gt;ADB&lt;/code&gt; 的命令有很多，今天就来整理下我在开发常用到的一些 ADB 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blog.ihoey.com/categories/Android/"/>
    
    
      <category term="adb" scheme="https://blog.ihoey.com/tags/adb/"/>
    
      <category term="Android" scheme="https://blog.ihoey.com/tags/Android/"/>
    
      <category term="adb命令" scheme="https://blog.ihoey.com/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
