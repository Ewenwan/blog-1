{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/next/source/400.html","path":"400.html","modified":1,"renderable":1},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/next/source/README.MD","path":"README.MD","modified":1,"renderable":1},{"_id":"themes/next/source/baidu_verify_HR5eYsvhwq.html","path":"baidu_verify_HR5eYsvhwq.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/cursor.css","path":"css/cursor.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/eevee.css","path":"css/eevee.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/Thumbs.db","path":"images/Thumbs.db","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cursor.ico","path":"images/cursor.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/ds-1.gif","path":"images/ds-1.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/img1.png","path":"images/img1.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/img2.png","path":"images/img2.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/plbj.png","path":"images/plbj.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/qcode/alipay_qcode.png","path":"qcode/alipay_qcode.png","modified":1,"renderable":1},{"_id":"themes/next/source/qcode/wechat_qcode.png","path":"qcode/wechat_qcode.png","modified":1,"renderable":1},{"_id":"themes/next/source/qcode/weixin-qrcode.png","path":"qcode/weixin-qrcode.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/ds-2.png","path":"images/ds-2.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/img/sp161118_190319.png","path":"img/sp161118_190319.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/embed.js","path":"js/src/embed.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/set.js","path":"js/src/set.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"9932ffe4a09bde463858cc493a9709c0125dc605","modified":1480955875031},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1481002345584},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1481002345599},{"_id":"themes/next/.gitignore","hash":"de5b9b9e5b313b4a86e805b02f334d35c87bfe56","modified":1481002345599},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1481002345599},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1481002345615},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1481002345615},{"_id":"themes/next/README.en.md","hash":"8fb7ceba7e34593de97d73a8234584452d9de3a5","modified":1481019646715},{"_id":"themes/next/README.md","hash":"a0848e66caac79f24df40a2a8981858c3b65e72d","modified":1481019626042},{"_id":"themes/next/_config.yml","hash":"868c9c70c9b07cfe00c801b00747483bd2f4a20d","modified":1482756249123},{"_id":"themes/next/gulpfile.coffee","hash":"e549561461642051d195550ec49d793e44ee22a0","modified":1481002345631},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1481019688280},{"_id":"themes/next/package.json","hash":"48e2352f8e41f2b6bbf55254d10f3192ee206d5a","modified":1481002346071},{"_id":"source/favicon.ico","hash":"61ed14c161a5df9092565996e38cdd438f128783","modified":1479648569380},{"_id":"source/_posts/Node-part1.md","hash":"313ea96ad1d0d10016ff82e59fdd51ee3c57da49","modified":1482629489762},{"_id":"source/_posts/Node-part2.md","hash":"ab927e9d96f406827411ab85692a984ce99615a2","modified":1481978095139},{"_id":"source/_posts/canvas-part1.md","hash":"79f0a5655f28c51b6b6998b32f2bf048c8ab7643","modified":1479951213631},{"_id":"source/_posts/canvas-summary.md","hash":"64ccba23acb9678998ea941ed6eeae82ef9f5f7d","modified":1479951309908},{"_id":"source/_posts/canvas-part2.md","hash":"384b27a77509903dc479df5b5e2ddf877c806892","modified":1479951273712},{"_id":"source/_posts/hello-world.md","hash":"b3bb0867f9dd8365049ad2559a192d86b6a96705","modified":1479950190994},{"_id":"source/_posts/javascript-Function.md","hash":"0a59b054941e621ef7a24130bea30edebf875499","modified":1479950917656},{"_id":"source/_posts/javascript-inherit.md","hash":"5f92254df069652980996a6ff0dcdc3db7a33b72","modified":1479950850082},{"_id":"source/_posts/javascript-jquery-part1.md","hash":"d48115cbefbcbb8d4ca2f4b3b8c3537cb7564918","modified":1482752302477},{"_id":"source/_posts/javascript-jquery-part2.md","hash":"ec09b544a399d60ddc3df569a7c8ea107b501b1b","modified":1479951378943},{"_id":"source/_posts/javascript-constructor.md","hash":"f4b55e3c697b3462be9680d30da69cd26967a9bc","modified":1479950758217},{"_id":"source/_posts/javascript-jquery-part3.md","hash":"94de405402ceb22fe6ec3712f4c62e74b385d5da","modified":1479951397176},{"_id":"source/_posts/javascript-jquery-part4.md","hash":"cd19546c7bfd8d445d1f44a676e8b3fef940fd8e","modified":1479951449096},{"_id":"source/_posts/javascript-jquery-part5.md","hash":"27c05a89c142453222993ae09706a8a41e36178f","modified":1479951457701},{"_id":"source/_posts/javascript-jquery-part6.md","hash":"6d2d515ba7ef29dba12e3b9d9dd931cbef6259ec","modified":1479993233120},{"_id":"source/_posts/javascript-jquery-part7.md","hash":"6c14bd63cf5fb4bea46597d2ee763e55f6b6640e","modified":1480213863000},{"_id":"source/_posts/javascript-part1.md","hash":"34e46ec4b20cac6de81ff386300970f13ce7702f","modified":1479950491000},{"_id":"source/_posts/javascript-part2.md","hash":"442bd39b3dc6c9d5c35ec534ac0a859797d5f874","modified":1479950717338},{"_id":"source/_posts/javascript-part3.md","hash":"b7904d5d1852859cb76c061122175512abc236b6","modified":1479950976406},{"_id":"source/_posts/javascript-part4.md","hash":"41bacb60063954146c606ea89875828864d0412f","modified":1479951005120},{"_id":"source/_posts/javascript-part6.md","hash":"bbe1899a3f1384acb27fd1774a1e4f032e55ca69","modified":1479951091067},{"_id":"source/_posts/javascript-part5.md","hash":"45bba563ca0c1e81d900255397c3ee1342baed77","modified":1479951021970},{"_id":"source/_posts/javascript-prototype-chain.md","hash":"74e3c28b6a0ce159e65b0b58ec3312756ae5cc5a","modified":1479950887277},{"_id":"source/_posts/javascript-prototype.md","hash":"73103828fc32ec288db88ce99bb9635684435647","modified":1479950799852},{"_id":"source/_posts/javascript-summary.md","hash":"732fcc68b63e07c4ac5ac9344cade64ec5003e63","modified":1479951148396},{"_id":"source/_posts/use-tools-part1-markdown.md","hash":"62e601f0dd4ae5c45310ed5b44dd2537f17f35d7","modified":1481977590648},{"_id":"source/about/index.md","hash":"6bb46934884788823ca9a397f523742ada2ad7bd","modified":1482628813105},{"_id":"source/categories/index.md","hash":"c550b628154423bc8705185c3d2f517cb6d8302f","modified":1480582925604},{"_id":"source/guestbook/index.md","hash":"0f0437211c72a77aa779e6deb229bb6c4957f861","modified":1481547988744},{"_id":"source/links/index.md","hash":"32b25d5fc82e93a77dba4dd1f5f90a8626af8838","modified":1482660212590},{"_id":"source/tags/index.md","hash":"4b5e474c530d9099b4970cf881a7988d735573e8","modified":1478790256289},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1481002345599},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"2692e36cc35b1594530981e7727771f601720a43","modified":1481002345599},{"_id":"themes/next/layout/_layout.swig","hash":"d0c184cfdeaf86020259754999621c4f4fac145a","modified":1481018227800},{"_id":"themes/next/layout/archive.swig","hash":"1532dde26dd547a93531f4c3b9d2da0606183c0b","modified":1481018867022},{"_id":"themes/next/layout/category.swig","hash":"6c55fcc07acb91d788db70497aedaacad594f349","modified":1481018809320},{"_id":"themes/next/layout/index.swig","hash":"1328ab8ddfb08a3f8e2ba204d25ef9c1ceccb50d","modified":1481018722051},{"_id":"themes/next/layout/page.swig","hash":"3547409a5b4ef0dfd2fc3f4b90aad635d5b0ff1e","modified":1481018634562},{"_id":"themes/next/layout/post.swig","hash":"320ec16a178814387c521ca1117cd8607172e96d","modified":1481018523843},{"_id":"themes/next/layout/schedule.swig","hash":"3ed13dc33a791248f5ce63c6ab64137da6d3067b","modified":1481018413562},{"_id":"themes/next/layout/tag.swig","hash":"5e46abeacde124a08818fc1c34b15d9de293f05c","modified":1481018318967},{"_id":"themes/next/languages/de.yml","hash":"db6a9d669f4b6282cda6c0a2d4e03d3e308a4846","modified":1481002345646},{"_id":"themes/next/languages/default.yml","hash":"fe00529a94bb2550194a31d178f5810b45014ab6","modified":1481002345646},{"_id":"themes/next/languages/en.yml","hash":"d02acdce503c86fbb01920ad22d31ec56fc285f1","modified":1481002345646},{"_id":"themes/next/languages/fr-FR.yml","hash":"91cf55b9d75879e72c8008d2659fe2ea993a4cca","modified":1481002345646},{"_id":"themes/next/languages/id.yml","hash":"d8b9dc017da0be7f71fda1cacd8064cbc38963b9","modified":1481002345662},{"_id":"themes/next/languages/ja.yml","hash":"bc89436a2a015ef72f43f265e56e37d94e73c0cd","modified":1481002345662},{"_id":"themes/next/languages/pt-BR.yml","hash":"4b91f96b07e05705b28964df7460466c9b522e2c","modified":1481002345662},{"_id":"themes/next/languages/ko.yml","hash":"c59676f2af80c3c594c34c4a0fcbf65fd8864ff3","modified":1481002345662},{"_id":"themes/next/languages/pt.yml","hash":"f364905121a816c9797acce07c0a4f248965b29a","modified":1481002345678},{"_id":"themes/next/languages/ru.yml","hash":"402e676252ab1fc4522257a578738cb9536eb077","modified":1481002345678},{"_id":"themes/next/languages/zh-Hans.yml","hash":"0e9311805aefa37b2c411a378a51643f10d0efac","modified":1481013497250},{"_id":"themes/next/languages/zh-hk.yml","hash":"a59f3f3114f5eb4d170a76da4359307e8f5159a7","modified":1481002345678},{"_id":"themes/next/languages/zh-tw.yml","hash":"18da1324d2212faca9a6e5e6ce98b419c86d4b0c","modified":1481002345693},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1481002346071},{"_id":"themes/next/source/400.html","hash":"3f872f1e5f7ab764fb0d3ae2875c9088d84f98ac","modified":1479866612156},{"_id":"themes/next/source/404.html","hash":"90e824f92dd6b1901818ec12546ac02194247bfe","modified":1479866591048},{"_id":"themes/next/source/CNAME","hash":"b6b717a1f89639bb8eeb19bbf4558c6cc1804390","modified":1479806730149},{"_id":"themes/next/source/README.MD","hash":"35a323124d3dbcddfc399a178d844c10ee36bbc5","modified":1482629170630},{"_id":"themes/next/source/baidu_verify_HR5eYsvhwq.html","hash":"18f2c1a4a646c26871a5e9fc8fd424117035fcc3","modified":1479487192246},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1481002347205},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1481002347220},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1481002347220},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346430},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1481002345693},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1481002345693},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"0c9ba63b9183570baa883c48c476cc9ba02efc04","modified":1482508321271},{"_id":"themes/next/layout/_macro/post.swig","hash":"052bc0e0d8710cea5c3f339bd39644454158dc34","modified":1481977785292},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1481002345709},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1481002345724},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"90d2c06b880af32263b1ef28bf5a6929fa1917b3","modified":1482752463521},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1481002345724},{"_id":"themes/next/layout/_partials/comments.swig","hash":"a5ffadb516522f85c052b290b94c0e4af3002644","modified":1481002345724},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1481002345740},{"_id":"themes/next/layout/_partials/footer.swig","hash":"fe2f869f403e63f3f41baf453170ae84fe733a9e","modified":1481017988957},{"_id":"themes/next/layout/_partials/head.swig","hash":"ab9ea1690f90795af24befe8ba899493eec3cde5","modified":1482752630255},{"_id":"themes/next/layout/_partials/header.swig","hash":"d9b10a92fdccd57a0c0d6773831f9c1b0f1bb449","modified":1481002345756},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"dfbb6e9692333166aa78231ad12b2a40c153cbcb","modified":1481002345756},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1481002345771},{"_id":"themes/next/layout/_partials/search.swig","hash":"952b7b8d9ce2c81d4002a9dc2331f1e710f99616","modified":1481002345771},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1481002345837},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1481002345837},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1481002345837},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c9d45628330ce8bf5fbe71c9f131c7d75334c1c4","modified":1481002346040},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1481002346071},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1481002346118},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1481002346087},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1481002346118},{"_id":"themes/next/source/css/cursor.css","hash":"da582310722ca088769344f81d39919356c69f72","modified":1478860083881},{"_id":"themes/next/source/css/eevee.css","hash":"cab2df001af5d1fb47f42b72d620d5a01c9064d1","modified":1480953965616},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1481002346430},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1481002346430},{"_id":"themes/next/source/images/Thumbs.db","hash":"878f9833358933aa1f79c0627cbb7180d3853b89","modified":1470202100000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1481002346430},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1481002346446},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1481002346446},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1481002346446},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1481002346446},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1481002346446},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1481002346466},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1481002346470},{"_id":"themes/next/source/images/cursor.ico","hash":"cd8349fb9cef6c217fc364cf35eae6819cebf5d6","modified":1478845626332},{"_id":"themes/next/source/images/ds-1.gif","hash":"e0bc6023185e4c841f624f2347f8439d06f627fd","modified":1478770531362},{"_id":"themes/next/source/images/img1.png","hash":"8091e664621d6d4fc2f41818af5ea5ade896173b","modified":1467101542000},{"_id":"themes/next/source/images/img2.png","hash":"69eb3bd6a5e6d45ee336b328753b3465c4abc48a","modified":1478770542679},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481002346471},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481002346472},{"_id":"themes/next/source/images/plbj.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1479485780865},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1481002346475},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1481002346478},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1481002346479},{"_id":"themes/next/source/qcode/alipay_qcode.png","hash":"f3f74023ae68e5c42089cffedcc219bc5a927bcf","modified":1472816960320},{"_id":"themes/next/source/qcode/wechat_qcode.png","hash":"c9f59c9bab781f36de9d6f0d712663ed71c396b0","modified":1478759413896},{"_id":"themes/next/source/qcode/weixin-qrcode.png","hash":"1914ee1c99643a35aac4d9ad700ac157bd1bbe65","modified":1478759378132},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002345852},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002345852},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346337},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346337},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346337},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346415},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481002346430},{"_id":"themes/next/source/images/ds-2.png","hash":"bc9e1efb29ee3d8da0d84fd59009f74218e604ce","modified":1478770526833},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1481002345693},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"bb2c3a926bb7f8fea54d424882b25d93dfde7ae6","modified":1481002345693},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"7bf8191b545f27a6086174d30ba323672062ee5a","modified":1482752818649},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1481002345756},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1481002345771},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1481002345771},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1481002345787},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1481002345787},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1481002345821},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1481002345821},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1481002345821},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1481002345852},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1481002345852},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"188423f7df0eb8c99a03cb6741384415651c4665","modified":1481002345852},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"9c8f4b2a29741d96adf0b8fef52ae7f4396f27f5","modified":1481002345930},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1481002345977},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"f592adff22628b271ec9657b080cf6b9cc200615","modified":1481002345993},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1481002346009},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1481002346024},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1481002346024},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1481002346337},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1481002346337},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"1250cedfd533013d54017acb9e261ad50d21f47f","modified":1482801321819},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"d7826b48a20162835450495db534d353ac52e476","modified":1481002346415},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1481002346415},{"_id":"themes/next/source/css/_variables/base.styl","hash":"4c4298a7011841d9ee2aec5bd192df5730b08517","modified":1481002346430},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1481002346480},{"_id":"themes/next/source/img/sp161118_190319.png","hash":"5dbcdf3b18a5934d6808ef5dc3f6404f41786d52","modified":1479467004963},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1481002346589},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1481002346496},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"84bdc8a4fe127849a5c99bdefe1d0b65ee1a4a0a","modified":1481002346496},{"_id":"themes/next/source/js/src/embed.js","hash":"2b54e66acd0bb0756486b939da6be43475c039ae","modified":1472816960349},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1481002346511},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1481002346527},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1481002346543},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1481002346558},{"_id":"themes/next/source/js/src/set.js","hash":"e1a60aa98a2f9c1f04f7b2f7814f7145a229456f","modified":1481092966848},{"_id":"themes/next/source/js/src/utils.js","hash":"e34f83848883732ddd7a34a3e3ed2a293f0f76a7","modified":1481002346574},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1481002346892},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1481002346892},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1481002346892},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1481002346908},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1481002346798},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1481002346798},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"8868275e8b6340c87a81c69a54ed138d11fb3c3e","modified":1481002346939},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1481002346955},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1481002346955},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1481002346955},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1481002346955},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1481002347033},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1481002347080},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1481002347080},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1481002347095},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1481002347095},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1481002347111},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1481002347111},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1481002347142},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1481002347142},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1481002347173},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1481002347189},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1481002347205},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1481002347080}],"Category":[{"name":"Node","_id":"cix6tyw3i0002csg70a426las"},{"name":"Canvas","_id":"cix6tyw41000ccsg72tf9rhr9"},{"name":"javascript","_id":"cix6tyw4e000vcsg72rg15gzu"},{"name":"Hexo","_id":"cix6tyw4n0010csg7ipmkvn29"},{"name":"Markdown","_id":"cix6tyw5d0029csg7u5nt5jlk"}],"Data":[],"Page":[{"title":"关于我","date":"2016-11-09T01:58:04.000Z","_content":"\n<blockquote class=\"blockquote-center\">愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。</blockquote>\n\n<center>首先梦魇小栈欢迎您的到来!</center>\n\n> <p style=\"text-indent: .5em; margin-bottom: 10px;\">关于我</p>\n\n90后,技术宅?恩或许是,现居于北京,然后喜爱折腾,好奇新事物\n欢迎各位小伙伴与我互换友链，详情请戳 上面的 <a href=\"/links\"><b>链接</b></a> 页面 。\n关于这个站呢,就是记录下平时记不太住的还有一些自己感兴趣喜欢的一些东西\n顺便也分享给大家吧!\n就酱紫,联系方式在下面\n\n***\n\n<center> <h2>联系方式</h2> </center>\n\n- Email：<a href=\"https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=mail@ihoey.com\">mail@ihoey.com</a>\n- Q  Q：<a href=\"http://wpa.qq.com/msgrd?v=3&uin=1058221214&site=qq&menu=yes\">1058221214</a>\n- 微博：<a href=\"http://weibo.com/hy951121\">ihoeys</a>\n\n***\n\n[2016-10-25] 站点从SinaAppEngine(SAE)迁移到Coding/GitHub, 国内用户默认解析至Coding, 海外则解析至GitHub, 互为备份, 改善了访问速度与稳定性\n\n***\n\n<center> <h2>打赏记录</h2> </center><br>\n\n|打赏人|打赏留言|打赏时间|\n|:--:|:--:|:--:|\n|159**0212|小站不错，支持一下啦！|2015-11-02|\n|138**4533|我来啦，占前排！|2015-11-02|\n|188**5838|网站不错哦！|2015-12-14|\n|175**1534|新年快乐!！|2016-2-11|\n|131**7309|很漂亮的网站,我的零钱都给你啦!|2016-3-15|\n|1121**@qq.com|谢谢帮助,祝你888!|2016-6-20|\n|lw**@163.com|那我就给你来个666吧!|2016-6-21|\n\n<br>\n\n啦啦啦，感谢你们啦，我会做的更好的呢\n2016-6-25:感谢你们的赞助了.虽然人不多,但我还是很感动的.\n\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n***\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-11-09 09:58:04\n---\n\n<blockquote class=\"blockquote-center\">愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。</blockquote>\n\n<center>首先梦魇小栈欢迎您的到来!</center>\n\n> <p style=\"text-indent: .5em; margin-bottom: 10px;\">关于我</p>\n\n90后,技术宅?恩或许是,现居于北京,然后喜爱折腾,好奇新事物\n欢迎各位小伙伴与我互换友链，详情请戳 上面的 <a href=\"/links\"><b>链接</b></a> 页面 。\n关于这个站呢,就是记录下平时记不太住的还有一些自己感兴趣喜欢的一些东西\n顺便也分享给大家吧!\n就酱紫,联系方式在下面\n\n***\n\n<center> <h2>联系方式</h2> </center>\n\n- Email：<a href=\"https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=mail@ihoey.com\">mail@ihoey.com</a>\n- Q  Q：<a href=\"http://wpa.qq.com/msgrd?v=3&uin=1058221214&site=qq&menu=yes\">1058221214</a>\n- 微博：<a href=\"http://weibo.com/hy951121\">ihoeys</a>\n\n***\n\n[2016-10-25] 站点从SinaAppEngine(SAE)迁移到Coding/GitHub, 国内用户默认解析至Coding, 海外则解析至GitHub, 互为备份, 改善了访问速度与稳定性\n\n***\n\n<center> <h2>打赏记录</h2> </center><br>\n\n|打赏人|打赏留言|打赏时间|\n|:--:|:--:|:--:|\n|159**0212|小站不错，支持一下啦！|2015-11-02|\n|138**4533|我来啦，占前排！|2015-11-02|\n|188**5838|网站不错哦！|2015-12-14|\n|175**1534|新年快乐!！|2016-2-11|\n|131**7309|很漂亮的网站,我的零钱都给你啦!|2016-3-15|\n|1121**@qq.com|谢谢帮助,祝你888!|2016-6-20|\n|lw**@163.com|那我就给你来个666吧!|2016-6-21|\n\n<br>\n\n啦啦啦，感谢你们啦，我会做的更好的呢\n2016-6-25:感谢你们的赞助了.虽然人不多,但我还是很感动的.\n\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n***\n","updated":"2016-12-25T01:20:13.105Z","path":"about/index.html","comments":1,"layout":"page","_id":"cix6tywa70052csg7qq799hs9"},{"title":"categories","date":"2016-11-09T01:56:23.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-09 09:56:23\ntype: \"categories\"\n---\n","updated":"2016-12-01T09:02:05.604Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cix6tywa90053csg7vjof9jac"},{"title":"留言板","date":"2016-11-10T12:35:52.000Z","comments":1,"_content":"\n<blockquote class=\"blockquote-center\">I eat alone. I sleep alone. I cry alone. So….cool.</blockquote>\n\n<center> 你想说些什么呢？就在这里回复吧~ 欢迎灌水，来者不拒！<br>如果你觉得我的博客对你有价值，并且有帮助到你，欢迎向我捐赠，就当是请我喝杯饮料~ <br><b>另外,你确定就看看不留个爪爪么!</b></center>\n\n<div style=\"margin: 20px auto; width: 100%; text-align: center\">\n    <a href=\"/qcode/alipay_qcode.png\" class=\"fancybox\" rel=\"group\"><img src=\"/qcode/alipay_qcode.png\" alt=\"支付宝打赏\" style=\"width: 200px; max-width: 100%;\"></a>\n    <div>支付宝打赏</div>\n</div>\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n\n*** \n\n> <p style=\"text-indent: .5em; margin-bottom: 10px;\">最新访客</p>\n\n<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n\n*** \n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"http://music.163.com/outchain/player?type=2&id=442016214&auto=1&height=32\"></iframe>\n\n***\n","source":"guestbook/index.md","raw":"---\ntitle: 留言板\ndate: 2016-11-10 20:35:52\ncomments: true\n---\n\n<blockquote class=\"blockquote-center\">I eat alone. I sleep alone. I cry alone. So….cool.</blockquote>\n\n<center> 你想说些什么呢？就在这里回复吧~ 欢迎灌水，来者不拒！<br>如果你觉得我的博客对你有价值，并且有帮助到你，欢迎向我捐赠，就当是请我喝杯饮料~ <br><b>另外,你确定就看看不留个爪爪么!</b></center>\n\n<div style=\"margin: 20px auto; width: 100%; text-align: center\">\n    <a href=\"/qcode/alipay_qcode.png\" class=\"fancybox\" rel=\"group\"><img src=\"/qcode/alipay_qcode.png\" alt=\"支付宝打赏\" style=\"width: 200px; max-width: 100%;\"></a>\n    <div>支付宝打赏</div>\n</div>\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n\n*** \n\n> <p style=\"text-indent: .5em; margin-bottom: 10px;\">最新访客</p>\n\n<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n\n*** \n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"http://music.163.com/outchain/player?type=2&id=442016214&auto=1&height=32\"></iframe>\n\n***\n","updated":"2016-12-12T13:06:28.744Z","path":"guestbook/index.html","layout":"page","_id":"cix6tywab0054csg73p8sdsz7"},{"title":"标签","date":"2016-11-09T01:55:47.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-11-09 09:55:47\ntype: \"tags\"\n---\n","updated":"2016-11-10T15:04:16.289Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cix6tywac0055csg73rj32gnc"},{"title":"友情链接","date":"2016-11-10T12:36:20.000Z","_content":"\n<blockquote class=\"blockquote-center\">过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以</blockquote>\n\n\n## Blog friends\n\n- [梦魇|专注于分享](http://www.dode.top/ \"梦魇|专注于分享™\")  -  一个帮助过我的好朋友，技术很不错\n- [一叶知秋](http://www.yc1993.xyz/)  -  森林里出现了两条路，而我选择了人迹罕至的一条，从此决定了一切际遇的不同！\n- [等待!!!](http://www.ccyyao.top/)  -  纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中!\n- [心雨](http://www.mcling.xyz)  -  天再高又怎样, 踮起脚尖就更接近阳光!\n- [neoFelhz](https://blog.neofelhz.ga)  -  拾穗者的故事\n\n***\n\n以上链接排名不分先后。\n如果你发现你的链接消失了，那么可能是网站无法访问，恢复后联系我即可~\n（也可能是超过半年未更新或者有不适当内容...这样的话自己看着办）\n在您申请友情链接之前请先添加本站链接,谢谢\n\n***\n\n### 友情链接添加须知\n\n- 本站友链目的不是为了SEO,只是为了交朋友;\n- 必须为合法的、内容健康向上的网站;\n- 只接受文字链接，并写好网站介绍;\n- 友情连接是双方站点寻求共同发展、互助互利的方式;\n\n***\n\n### 本站链接信息\n\n- 名称：梦魇小栈\n- 地址：http://blog.ihoey.com/\n- 描述：心，若没有栖息的地方，到哪里都是流浪......\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n***\n","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2016-11-10 20:36:20\n---\n\n<blockquote class=\"blockquote-center\">过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以</blockquote>\n\n\n## Blog friends\n\n- [梦魇|专注于分享](http://www.dode.top/ \"梦魇|专注于分享™\")  -  一个帮助过我的好朋友，技术很不错\n- [一叶知秋](http://www.yc1993.xyz/)  -  森林里出现了两条路，而我选择了人迹罕至的一条，从此决定了一切际遇的不同！\n- [等待!!!](http://www.ccyyao.top/)  -  纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中!\n- [心雨](http://www.mcling.xyz)  -  天再高又怎样, 踮起脚尖就更接近阳光!\n- [neoFelhz](https://blog.neofelhz.ga)  -  拾穗者的故事\n\n***\n\n以上链接排名不分先后。\n如果你发现你的链接消失了，那么可能是网站无法访问，恢复后联系我即可~\n（也可能是超过半年未更新或者有不适当内容...这样的话自己看着办）\n在您申请友情链接之前请先添加本站链接,谢谢\n\n***\n\n### 友情链接添加须知\n\n- 本站友链目的不是为了SEO,只是为了交朋友;\n- 必须为合法的、内容健康向上的网站;\n- 只接受文字链接，并写好网站介绍;\n- 友情连接是双方站点寻求共同发展、互助互利的方式;\n\n***\n\n### 本站链接信息\n\n- 名称：梦魇小栈\n- 地址：http://blog.ihoey.com/\n- 描述：心，若没有栖息的地方，到哪里都是流浪......\n\n***\n\n<iframe src=\"http://sponsor.ihoey.com/\" style=\"overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;\"  frameborder=\"0\" scrolling=\"no\"></iframe>\n\n***\n","updated":"2016-12-25T10:03:32.590Z","path":"links/index.html","comments":1,"layout":"page","_id":"cix6tywad0056csg72k5lgvc4"}],"Post":[{"title":"Node第一部分-初体验","date":"2016-12-10T02:31:09.000Z","_content":"\n## NodeJs是什么？\n\n> 简单的说 `NodeJs` 就是运行在服务端的 `JavaScript` 。`NodeJs` 是一个基于 `Chrome JavaScript` 运行时建立的一个平台。`NodeJs` 是一个事件驱动 `I/O` 服务端 `JavaScript` 环境，基于 `Google` 的 `V8` 引擎，`V8` 引擎执行 `Javascript` 的速度非常快，性能非常好。\n\n- 官网 `https://nodejs.org`\n\n<!--more-->\n\n- `NodeJs` 自带运行时环境可在 `Javascript` 脚本的基础上可以解释和执行(这类似于 `JVM` 的 `Java` 字节码)。这个运行时允许在浏览器以外的任何机器上执行 `JavaScript` 代码。由于这种运行时在 `NodeJs` 上，所以 `JavaScript` 现在可以在服务器上并执行。\n- `NodeJs` 还提供了各种丰富的 `JavaScript` 模块库，它极大简化了使用 `NodeJs` 来扩展 `Web` 应用程序的研究与开发。\n- `NodeJs` = 运行环境 + `JavaScript` 库\n\n### 浏览器和NodeJs中的Js\n\n- 浏览器的 `Js`\n  * 可以通过 `Js` 操作 `Html`\n  * 有 `DOM` (和操作 `Html` 有关)，有 `BOM` (和浏览器有关)，有 `ECMA` (就是 `js` 语法规范)\n- `Node` 中的 `Js`\n  * 没有 `DOM`, 没有 `BOM`, 有 `ECMA`\n  * `windows` (也就是说没有 `windows` 对象)\n\n## Node安装\n\n在 `windows` 上安装 `NodeJs` (本教程中使用)。使用 `MSI` 文件，并按照提示安装 `NodeJs` ，默认情况下，安装程序将 `NodeJs` 发行到 `C:\\Program Files\\nodejs`. 但这里我们可以根据需要修改安装路径到指定的文件夹，比如：`D:\\Program Files\\nodejs` ，并将 `D:\\Program Files\\nodejs` 目录添加到 `Window` 系统的 `PATH` 环境变量中（或者安装的时候选中添加环境变量，下面会有提到）。\n\n- 第一步：双击下载的 `node-v7.2.1-x64.msi` 文件，出现提示安装界面\n- 第二步：选择安装目录，比如安装在目录 `D:\\Program Files\\nodejs` 中\n- 第三步：选择安装的模块和功能，这里全部安装，并添加到系统环境变量，最后一个选项\n- 最后一步：安装完成！\n- 验证安装：在 `CMD` 或者 `powershell` 中输入 `node -v` 注意中间有空格，显示版本号就说明安装成功了！\n\n## Node版本介绍\n\n- `0.10.x` , `Node` 就开源了\n  + 开源（开放源代码）的话, 别人就可以贡献（提意见，修改等）源码! \n  + 因为作者比较精益求精，所以后来第三方社区: 觉得Node更新太慢! \n    * 于是第三方社区在原来Node的基础上继续开发并加入了很多新的东西\n  + 后来因为反响太大，作者便直接合并: 从 `0.10.x` 直接升到 `4.x`\n  + 版本历史 `4.x` `5.x` `6.x` `7.x`\n\n## 创建 NodeJs 应用\n\n### 步骤一、引入 required 模块\n\n我们使用 `require` 指令来载入 `http` 模块，并将实例化的 `HTTP` 赋值给变量 http，实例如下:\n\n```js\nvar http = require(\"http\");\n```\n### 步骤一、创建服务器\n- 我们电脑上只要安装了node,不需要其他的软件配置，就能够开启一个http服务\n\n接下来我们使用 `http.createServer()` 方法创建服务器，并使用 `listen` 方法绑定 `8888` 端口。 函数通过 `request`, `response` 参数来接收和响应数据。\n实例如下，在你项目的根目录下创建一个叫 `server.js` 的文件，并写入以下代码：\n\n```js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n  // 发送 http 头部\n  // http 状态码：200 ：OK\n  // 内容类型： text/piain\n  response.writeHead(200,{'Contenr-Type': 'text/piain'})\n  //发送响应数据 ‘hello world’\n  response.end('hello-world');\n  //监听8888端口\n  }).listen(8888)\n\n  console.log('Server running at http://127.0.0.1:8888/')\n```\n\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n使用 node 命令执行以上的代码：\n\n```js\nnode server.js\nServer running at http://127.0.0.1:8888/\n```\n\n接下来，打开浏览器访问 `http://127.0.0.1:8888/` ，你会看到一个写着 \"Hello World\"的网页。\n\n> 服务器\n\n- 服务器就是一台电脑, 只是性能一般比我们普通电脑高!\n\n### 注意\n\n*file协议，默认，是不能够发ajax请求的！*\n\n- 服务器就是一台电脑(这个电脑是有独立 `ip` )\n- 我们的笔记本也是电脑(也可以把最终的项目代码放到笔记本上! ,但是没有公司愿意这么干)\n- 操作系统都可能是一样的\n- 服务器能运行的软件，我们电脑也能运行\n\n## 环境变量\n\n- 我们在 `cmd` 窗口中敲一个命令, 本质上是执行了一个程序(软件)\n- 默认按下回车时, 会到当前命令行所对应的目录寻找文件, 如果找到就立即执行\n- 如果找不到就会到环境变量中的 `PATH` 中指定的目录中寻找!\n\n例:我们把 `node` 的默认安装目录: `D:\\Program Files\\nodejs`, 配置 `PATH` 上，那么\n我们在 `cmd` 中敲命令时，如果当前目录找不到，就会到 `D:\\Program Files\\nodejs` \n目录寻找相应的文件执行!\n\n## 命令行\n\n- 系统底层还是命令\n- windows系统刚开始的时候还没有界面\n- 在 `cmd` 中敲命令,或默认到当前命令行对应的目录中找文件执行\n","source":"_posts/Node-part1.md","raw":"---\ntitle: Node第一部分-初体验\ndate: 2016-12-10 10:31:09\ntags: \n    - Node\n    - NodeJs \ncategories: Node\n---\n\n## NodeJs是什么？\n\n> 简单的说 `NodeJs` 就是运行在服务端的 `JavaScript` 。`NodeJs` 是一个基于 `Chrome JavaScript` 运行时建立的一个平台。`NodeJs` 是一个事件驱动 `I/O` 服务端 `JavaScript` 环境，基于 `Google` 的 `V8` 引擎，`V8` 引擎执行 `Javascript` 的速度非常快，性能非常好。\n\n- 官网 `https://nodejs.org`\n\n<!--more-->\n\n- `NodeJs` 自带运行时环境可在 `Javascript` 脚本的基础上可以解释和执行(这类似于 `JVM` 的 `Java` 字节码)。这个运行时允许在浏览器以外的任何机器上执行 `JavaScript` 代码。由于这种运行时在 `NodeJs` 上，所以 `JavaScript` 现在可以在服务器上并执行。\n- `NodeJs` 还提供了各种丰富的 `JavaScript` 模块库，它极大简化了使用 `NodeJs` 来扩展 `Web` 应用程序的研究与开发。\n- `NodeJs` = 运行环境 + `JavaScript` 库\n\n### 浏览器和NodeJs中的Js\n\n- 浏览器的 `Js`\n  * 可以通过 `Js` 操作 `Html`\n  * 有 `DOM` (和操作 `Html` 有关)，有 `BOM` (和浏览器有关)，有 `ECMA` (就是 `js` 语法规范)\n- `Node` 中的 `Js`\n  * 没有 `DOM`, 没有 `BOM`, 有 `ECMA`\n  * `windows` (也就是说没有 `windows` 对象)\n\n## Node安装\n\n在 `windows` 上安装 `NodeJs` (本教程中使用)。使用 `MSI` 文件，并按照提示安装 `NodeJs` ，默认情况下，安装程序将 `NodeJs` 发行到 `C:\\Program Files\\nodejs`. 但这里我们可以根据需要修改安装路径到指定的文件夹，比如：`D:\\Program Files\\nodejs` ，并将 `D:\\Program Files\\nodejs` 目录添加到 `Window` 系统的 `PATH` 环境变量中（或者安装的时候选中添加环境变量，下面会有提到）。\n\n- 第一步：双击下载的 `node-v7.2.1-x64.msi` 文件，出现提示安装界面\n- 第二步：选择安装目录，比如安装在目录 `D:\\Program Files\\nodejs` 中\n- 第三步：选择安装的模块和功能，这里全部安装，并添加到系统环境变量，最后一个选项\n- 最后一步：安装完成！\n- 验证安装：在 `CMD` 或者 `powershell` 中输入 `node -v` 注意中间有空格，显示版本号就说明安装成功了！\n\n## Node版本介绍\n\n- `0.10.x` , `Node` 就开源了\n  + 开源（开放源代码）的话, 别人就可以贡献（提意见，修改等）源码! \n  + 因为作者比较精益求精，所以后来第三方社区: 觉得Node更新太慢! \n    * 于是第三方社区在原来Node的基础上继续开发并加入了很多新的东西\n  + 后来因为反响太大，作者便直接合并: 从 `0.10.x` 直接升到 `4.x`\n  + 版本历史 `4.x` `5.x` `6.x` `7.x`\n\n## 创建 NodeJs 应用\n\n### 步骤一、引入 required 模块\n\n我们使用 `require` 指令来载入 `http` 模块，并将实例化的 `HTTP` 赋值给变量 http，实例如下:\n\n```js\nvar http = require(\"http\");\n```\n### 步骤一、创建服务器\n- 我们电脑上只要安装了node,不需要其他的软件配置，就能够开启一个http服务\n\n接下来我们使用 `http.createServer()` 方法创建服务器，并使用 `listen` 方法绑定 `8888` 端口。 函数通过 `request`, `response` 参数来接收和响应数据。\n实例如下，在你项目的根目录下创建一个叫 `server.js` 的文件，并写入以下代码：\n\n```js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n  // 发送 http 头部\n  // http 状态码：200 ：OK\n  // 内容类型： text/piain\n  response.writeHead(200,{'Contenr-Type': 'text/piain'})\n  //发送响应数据 ‘hello world’\n  response.end('hello-world');\n  //监听8888端口\n  }).listen(8888)\n\n  console.log('Server running at http://127.0.0.1:8888/')\n```\n\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n使用 node 命令执行以上的代码：\n\n```js\nnode server.js\nServer running at http://127.0.0.1:8888/\n```\n\n接下来，打开浏览器访问 `http://127.0.0.1:8888/` ，你会看到一个写着 \"Hello World\"的网页。\n\n> 服务器\n\n- 服务器就是一台电脑, 只是性能一般比我们普通电脑高!\n\n### 注意\n\n*file协议，默认，是不能够发ajax请求的！*\n\n- 服务器就是一台电脑(这个电脑是有独立 `ip` )\n- 我们的笔记本也是电脑(也可以把最终的项目代码放到笔记本上! ,但是没有公司愿意这么干)\n- 操作系统都可能是一样的\n- 服务器能运行的软件，我们电脑也能运行\n\n## 环境变量\n\n- 我们在 `cmd` 窗口中敲一个命令, 本质上是执行了一个程序(软件)\n- 默认按下回车时, 会到当前命令行所对应的目录寻找文件, 如果找到就立即执行\n- 如果找不到就会到环境变量中的 `PATH` 中指定的目录中寻找!\n\n例:我们把 `node` 的默认安装目录: `D:\\Program Files\\nodejs`, 配置 `PATH` 上，那么\n我们在 `cmd` 中敲命令时，如果当前目录找不到，就会到 `D:\\Program Files\\nodejs` \n目录寻找相应的文件执行!\n\n## 命令行\n\n- 系统底层还是命令\n- windows系统刚开始的时候还没有界面\n- 在 `cmd` 中敲命令,或默认到当前命令行对应的目录中找文件执行\n","slug":"Node-part1","published":1,"updated":"2016-12-25T01:31:29.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3b0000csg7l7rmci7g"},{"title":"Node第二部分-模块及工具","date":"2016-12-12T01:12:32.000Z","_content":"为了让 `NodeJs` 的文件可以相互调用，`NodeJs` 提供了一个简单的模块系统。\n模块是 `NodeJs` 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 `NodeJs` 文件就是一个模块，这个文件可能是 `JavaScript` 代码、`JSON` 或者编译过的 `C/C++` 扩展。\n\n<!--more-->\n\n## NodeJs的模块\n\n- 核心模块(只要安装了node就会有的模块,已经被打包到了node.exe文件)\n- 自定义模块(我们自己写的js模块)\n- 第三方的模块(包)\n\n## 核心模块\n\n- http\n- url\n- fs\n- ……等\n\n### http 模块\n\n在我们的代码中请求它并把返回值赋给一个本地变量\n\n### url 模块\n\n- 用来操作url的\n- url.parse(request.url,true)\n\n## fs文件操作模块\n\n```javascript\nvar fs = require('fs')\n// 读取文件:\n// 参数1：文件路径\n// 参数2： 文件编码\n// 返回值： 文件内容\nvar data = fs.readFileSync('./index.html','utf8')\n\n// 写入文件\n// 第一个参数：是要写入的文件目录,\n// 第二个参数:是要写入的内容!\n// 这个方法执行时会【覆盖】之前的文件内容!\nfs.writeFileSync('./tmp.txt','我是中国人，我爱自己的祖国!')\n\n// 追加文件\nfs.appendFileSync('./xx.js','我是小明，我在哪里?\\r\\n')\n\n // 创建目录\n    // 判断目录是否存在，如果不存在，则创建\n    var result = fs.existsSync('data') // 判断当前目录是否存在data目录\n    if(!result){\n    console.log(result)\n    // 创建目录\n    fs.mkdirSync('data')// 在当前目录创建data目录\n    }\n```\n\n## __dirname和__firename\n1, __dirname 可在任意文件中直接使用,值表示当前文件所在路径字符串\n2, __firname 也可以在任意文件中使用,值表示当前文件的包含文件名的完整路径!\n\n## 按顺序执行就是同步\n## form表单，提交get请求，会把请求参数添加到url中\n\n## 重定向!\n- 在响应头里加上 Location:'新地址',并设置状态为302\n- `res.setHeader('key','value')`// 设置响应头\n- `res.writeHead(状态码)`// 设置状态码!\n- 浏览器接收到数据后会重新向新地址跳转!\n\n## npm\n- node package manager\n- node的包管理工具，管理的是第三方包\n- [官网](https://www.npmjs.com/)\n- 也能管理前端的包\n\n### 安装包\n- 初始化: `npm init`\n- `npm install <包名>`\n\n## 扩展\n## 离线文档阅读器\n- [windows版本](https://zealdocs.org/)\n- [mac版本](dash)\n\n## es6/es2015 每天一点点\n- const\n//  const申明的数据，在栈中不可变，但是如果是对象，则对应的属性值可以变,也就是堆中的值可变,栈中的地址不可以变！\n- let\n// let申明的变量，作用由大括号决定!\n\n### 提交效率\n- 组合键: `win+E`, 打开资源管理器\n- 组合键: `wind+D`, 快速切换到桌面\n- 组合键: `ctrl+shift+esc` 快速打开任务管理器\n","source":"_posts/Node-part2.md","raw":"---\ntitle: Node第二部分-模块及工具\ndate: 2016-12-12 09:12:32\ntags: \n    - Node\n    - NodeJs \ncategories: Node\n---\n为了让 `NodeJs` 的文件可以相互调用，`NodeJs` 提供了一个简单的模块系统。\n模块是 `NodeJs` 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 `NodeJs` 文件就是一个模块，这个文件可能是 `JavaScript` 代码、`JSON` 或者编译过的 `C/C++` 扩展。\n\n<!--more-->\n\n## NodeJs的模块\n\n- 核心模块(只要安装了node就会有的模块,已经被打包到了node.exe文件)\n- 自定义模块(我们自己写的js模块)\n- 第三方的模块(包)\n\n## 核心模块\n\n- http\n- url\n- fs\n- ……等\n\n### http 模块\n\n在我们的代码中请求它并把返回值赋给一个本地变量\n\n### url 模块\n\n- 用来操作url的\n- url.parse(request.url,true)\n\n## fs文件操作模块\n\n```javascript\nvar fs = require('fs')\n// 读取文件:\n// 参数1：文件路径\n// 参数2： 文件编码\n// 返回值： 文件内容\nvar data = fs.readFileSync('./index.html','utf8')\n\n// 写入文件\n// 第一个参数：是要写入的文件目录,\n// 第二个参数:是要写入的内容!\n// 这个方法执行时会【覆盖】之前的文件内容!\nfs.writeFileSync('./tmp.txt','我是中国人，我爱自己的祖国!')\n\n// 追加文件\nfs.appendFileSync('./xx.js','我是小明，我在哪里?\\r\\n')\n\n // 创建目录\n    // 判断目录是否存在，如果不存在，则创建\n    var result = fs.existsSync('data') // 判断当前目录是否存在data目录\n    if(!result){\n    console.log(result)\n    // 创建目录\n    fs.mkdirSync('data')// 在当前目录创建data目录\n    }\n```\n\n## __dirname和__firename\n1, __dirname 可在任意文件中直接使用,值表示当前文件所在路径字符串\n2, __firname 也可以在任意文件中使用,值表示当前文件的包含文件名的完整路径!\n\n## 按顺序执行就是同步\n## form表单，提交get请求，会把请求参数添加到url中\n\n## 重定向!\n- 在响应头里加上 Location:'新地址',并设置状态为302\n- `res.setHeader('key','value')`// 设置响应头\n- `res.writeHead(状态码)`// 设置状态码!\n- 浏览器接收到数据后会重新向新地址跳转!\n\n## npm\n- node package manager\n- node的包管理工具，管理的是第三方包\n- [官网](https://www.npmjs.com/)\n- 也能管理前端的包\n\n### 安装包\n- 初始化: `npm init`\n- `npm install <包名>`\n\n## 扩展\n## 离线文档阅读器\n- [windows版本](https://zealdocs.org/)\n- [mac版本](dash)\n\n## es6/es2015 每天一点点\n- const\n//  const申明的数据，在栈中不可变，但是如果是对象，则对应的属性值可以变,也就是堆中的值可变,栈中的地址不可以变！\n- let\n// let申明的变量，作用由大括号决定!\n\n### 提交效率\n- 组合键: `win+E`, 打开资源管理器\n- 组合键: `wind+D`, 快速切换到桌面\n- 组合键: `ctrl+shift+esc` 快速打开任务管理器\n","slug":"Node-part2","published":1,"updated":"2016-12-17T12:34:55.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3f0001csg7ijh18ba6"},{"title":"Canvas部分知识总结","date":"2016-11-15T12:38:26.000Z","_content":"\nCanvas笔记总结！！\n接前部分~\n\n<!-- more -->\n\n## canvas是什么?\n\n是一个 `HTML5` 标签,该标签用来绘图\n\n## canvas怎么用\n\n`canvas` 是一个画布,不能自己画图,画图需要绘图上下文\n\n```js\nvar cas = document.querySelector(\"#c\");\n//获取绘图上下文\ncar ctx = cas.getContext(\"2d\");\n```\n\n## 画直线\n\n```js\n//设置直线的起点\nctx.moveTo(x,y);\n//画路径到直线的终点\nctx.lineTo(x,y);\n```\n\n## 开启新路径\n\n```js\nctx.befinPath();\n```\n\n## 画曲线\n\n```js\n//使用for循环,用函数来帮一个y确定一个x\n//然后讲x,y的每一个点用lingTo连起来就变成了一条曲线\n```\n\n## 画矩形\n\n```js\n//1. 手动,纯人工\n//2. ctx.rect(x,y,w,h);\n//3. ctx.strokeRect(x,y,w,h);\n//4. ctx.fillRect(x,y,w,h);\n```\n\n## 画弧\n\n```js\nctx.arc(x,y,r,startAngle.endAngle[,Boolean optional anticlockwise])\n```\n\n## 扇形\n\n```js\n//先moveTo到原心\nmoveTo(x,y);\nctx.arc(x,y,r,startAngle.endAngle[,Boolean optional anticlockwise])\nctx.closePath();\nctx.fill();\n```\n\n## 饼图\n\n`3` 等分的饼\n1. 开始的角度一般是 `-90`\n2. 每画一个扇形,就让角度 `+120`\n3. 再从加了 `120` 的角度画下一个扇形\n\n## 动画饼图\n\n定时器\n每一段时间画一个小扇形,就和画饼一样\n\n## 文字\n\n```js\nfillText(str, x, y)\nstrokText(str, x, y)\n```\n\n### 对其方式\n\n#### 水平\n\n* left\n* center\n* right\n* start\n* end\n\n#### 垂直\n\n* top\n* middle\n* bottom\n* hanging\n* alphabetic\n* ideographic\n\n## 完整饼图\n\n1. 先算所有数据的总和\n2. 算每个数据的比例,用比例算出角度\n3. 更具每个角度去画扇形\n4. 在去画扇形的中线\n5. 画文字下面的线\n6. 写文字\n\n## 图片\n\n```js\n//3参\nctx.drawImage(img, x, y)\n//直接画不管宽高\n//5参\nctx.drawImage(img, x, y, w, h)\n//要确定宽高\n//9参\nctx.drawImage(img, x, y, w, h, x1, y1, w1, h1)\n\n//拿出图片中 x, y, w, h 这个矩形所在的位置的图像\n//放到canvas中x1, y1, w1, h1这个矩形所在的位置\n```\n\n## 帧动画\n\n\n## 变换\n\n* 平移变换   把画布的原点移动到指定的位置\n    `ctx.translate(x, y)`\n* 缩放变换   对画布进行缩放\n\n```js\n    ctx.scale(x, y)  //x表示的是对画布x轴的缩放，如果大于1 是放大 如果小于1 是缩小\n    ctx.scale(x, y)  //y表示的是对画布y轴的缩放，如果大于1 是放大 如果小于1 是缩小\n```\n\n* 旋转变换\n    `ctx.rotate(弧度)  //将画布，围绕原点旋转指定的弧度`","source":"_posts/canvas-summary.md","raw":"---\ntitle: Canvas部分知识总结\ndate: 2016-11-15 20:38:26\ntags: \n\t- Canvas\n\t- HTML5\n\t- 画布\ncategories: Canvas\n---\n\nCanvas笔记总结！！\n接前部分~\n\n<!-- more -->\n\n## canvas是什么?\n\n是一个 `HTML5` 标签,该标签用来绘图\n\n## canvas怎么用\n\n`canvas` 是一个画布,不能自己画图,画图需要绘图上下文\n\n```js\nvar cas = document.querySelector(\"#c\");\n//获取绘图上下文\ncar ctx = cas.getContext(\"2d\");\n```\n\n## 画直线\n\n```js\n//设置直线的起点\nctx.moveTo(x,y);\n//画路径到直线的终点\nctx.lineTo(x,y);\n```\n\n## 开启新路径\n\n```js\nctx.befinPath();\n```\n\n## 画曲线\n\n```js\n//使用for循环,用函数来帮一个y确定一个x\n//然后讲x,y的每一个点用lingTo连起来就变成了一条曲线\n```\n\n## 画矩形\n\n```js\n//1. 手动,纯人工\n//2. ctx.rect(x,y,w,h);\n//3. ctx.strokeRect(x,y,w,h);\n//4. ctx.fillRect(x,y,w,h);\n```\n\n## 画弧\n\n```js\nctx.arc(x,y,r,startAngle.endAngle[,Boolean optional anticlockwise])\n```\n\n## 扇形\n\n```js\n//先moveTo到原心\nmoveTo(x,y);\nctx.arc(x,y,r,startAngle.endAngle[,Boolean optional anticlockwise])\nctx.closePath();\nctx.fill();\n```\n\n## 饼图\n\n`3` 等分的饼\n1. 开始的角度一般是 `-90`\n2. 每画一个扇形,就让角度 `+120`\n3. 再从加了 `120` 的角度画下一个扇形\n\n## 动画饼图\n\n定时器\n每一段时间画一个小扇形,就和画饼一样\n\n## 文字\n\n```js\nfillText(str, x, y)\nstrokText(str, x, y)\n```\n\n### 对其方式\n\n#### 水平\n\n* left\n* center\n* right\n* start\n* end\n\n#### 垂直\n\n* top\n* middle\n* bottom\n* hanging\n* alphabetic\n* ideographic\n\n## 完整饼图\n\n1. 先算所有数据的总和\n2. 算每个数据的比例,用比例算出角度\n3. 更具每个角度去画扇形\n4. 在去画扇形的中线\n5. 画文字下面的线\n6. 写文字\n\n## 图片\n\n```js\n//3参\nctx.drawImage(img, x, y)\n//直接画不管宽高\n//5参\nctx.drawImage(img, x, y, w, h)\n//要确定宽高\n//9参\nctx.drawImage(img, x, y, w, h, x1, y1, w1, h1)\n\n//拿出图片中 x, y, w, h 这个矩形所在的位置的图像\n//放到canvas中x1, y1, w1, h1这个矩形所在的位置\n```\n\n## 帧动画\n\n\n## 变换\n\n* 平移变换   把画布的原点移动到指定的位置\n    `ctx.translate(x, y)`\n* 缩放变换   对画布进行缩放\n\n```js\n    ctx.scale(x, y)  //x表示的是对画布x轴的缩放，如果大于1 是放大 如果小于1 是缩小\n    ctx.scale(x, y)  //y表示的是对画布y轴的缩放，如果大于1 是放大 如果小于1 是缩小\n```\n\n* 旋转变换\n    `ctx.rotate(弧度)  //将画布，围绕原点旋转指定的弧度`","slug":"canvas-summary","published":1,"updated":"2016-11-24T01:35:09.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3k0004csg76gn6nw3h"},{"title":"Canvas知识整理part1","date":"2016-11-13T11:39:33.000Z","_content":"\ncanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.\n\n<!-- more -->\n\n    canvas 英 ['kænvəs]  美 ['kænvəs]   帆布 画布\n\n默认的宽高为：`300 * 150`\n\n## Canvas 使用注意：\n\n* 设置 `canvas` 宽高 `canvas` 只是一个画布，不能直接自己绘图，绘图需要使用工具\n* 设置 `canvas` 宽和高的时候不推荐使用 `css` 样式去设置，因为会有拉伸的效果\n* 在不支持的浏览器中，`canvas` 中的内容会正常的现实出来\n* 再 `canvas` 标签内部书写内容，在支持的浏览器中，该内容会被忽略\n* 在不支持的浏览器中会将 `canvas` 标签会当作 `div` 标签来处理\n\n## canvas 的使用领域\n\n`canvas` 的使用领域很多:\n\n1. 游戏\n2. 可视化数据(重点)\n3. `banner` 广告\n4. 多媒体\n5. 未来\n    * 模拟仿真\n    * 远程操作\n    * 图形编辑\n\n## Canvas 怎么用？\n\n1. 创建一个 `Canvas` 标签\n2. 获取到该 `DOM` 对象\n3.  `Canvas` 只是一个画布，不能自己画画，需要画图工具\n4. 每个 `Canvas` 对应一个画图工具，通过 `canvas` 对象 `.getContext(\"2d\")` 参数有 `2d` 和 `webgl` 两种 `2d` 获取到一个 ` CanvasRenderingContext2D` 类型的对象,使用 `webgl` 返回 `WebGLRenderingContext` 类型的对象.\n\n## 如何画直线\n\n1. 先确定在何处下笔，画图工具 `.moveTo(x, y)`\n2. 确定从开始的点画到哪里去，  画图工具 `.lineTo(x, y)`\n3. 上面两步之后，线并没有画出来，而是描点，需要最后一步进行画线  画图工具 `.stroke();`\n\n```js\nvar canvas = document.createElement( 'canvas' );\ncanvas.width = 500;\ncanvas.height = 400;\ncanvas.style.border = '1px dashed red';\ndocument.body.appendChild( canvas );\n// 获得 CanvasRenderingContext2D 对象\nvar context = canvas.getContext( '2d' );\n// 设置 起点\ncontext.moveTo( 0, 0 );\n// 绘制直线\ncontext.lineTo( 500, 400 );\n// 设置 起点\ncontext.moveTo( 0, 400 );\n// 绘制直线\ncontext.lineTo( 500, 0 );\n// 描边显示效果\ncontext.stroke();\n```\n\n## lineTo的特性\n\n每次 `lineTo` 之后都会记录最后的 `lineTo` 的点，下次 `lineTo` 的时候就接着这个 `canvas` 只是一个画布，不能直接自己绘图，绘图需要使用工具sssss点继续画\n\n\n## closePath\n\n将最后一次 `lineTo` 的点 和最后一次 `moveTo` 的点连起来的\n两条线的交界处，如果使用的是 `closePath` 会补全缺口\n\n```js\nctx.moveTo( 100, 100 );\nctx.lineTo( 300, 100 );\nctx.lineTo( 300, 200 );\nctx.closePath();\nctx.stroke();\n```\n\n## fill\n\n可以将闭合的图形进行填充\n\n## 非零填充原则\n\n从一个闭合空间引出一条直线，如果该直线两边的箭头数量不相等，则要填充，如果相等则不填充\n\n一边有一个箭头就+1\n另一边有一个箭头就-1\n\n## 如何绘制曲线？\n\n使用 `for` 循环给每一个 `x` 对应一个 `y` 值，`x` 和 `y` 的关系需要是个多次幂的方程\n\n## 路径概念\n\n路径就是一次绘图，包含该次绘图中的所有的状态，线宽  颜色  是否虚线\n\n如果想要改变状态，就需要开启新的路径\n\n## beginPath\n\n可以用来开启新的路径\n\n## 线型相关属性\n\n|名称|描述|\n|:--:|:--:|\n|lineWidth|画线的时候的线的宽度|\n|setLineDash()|设置虚线各个线段的长度,参数是一个数组，会将数组中的数字循环使用|\n|getLineDash()|获取虚线各个线段的长度，如果是实线，获取到的是空数组|\n|lineDashOffset|设置虚线的偏移量，正值往左，负值往右|\n|strokeStyle|设置描边的，画线的颜色，颜色值可以为css中任意一种|\n|fillStyle|设置填充颜色，颜色值可以为css中任意一种|\n\n## 渐变色\n\n将线划分为 `256` 份，每一份为一个颜色，新画一条线，依次递增，就形成了一个颜色渐变的线段","source":"_posts/canvas-part1.md","raw":"---\ntitle: Canvas知识整理part1\ndate: 2016-11-13 19:39:33\ntags: \n\t- Canvas\n\t- HTML5\n\t- 画布\ncategories: Canvas\n---\n\ncanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.\n\n<!-- more -->\n\n    canvas 英 ['kænvəs]  美 ['kænvəs]   帆布 画布\n\n默认的宽高为：`300 * 150`\n\n## Canvas 使用注意：\n\n* 设置 `canvas` 宽高 `canvas` 只是一个画布，不能直接自己绘图，绘图需要使用工具\n* 设置 `canvas` 宽和高的时候不推荐使用 `css` 样式去设置，因为会有拉伸的效果\n* 在不支持的浏览器中，`canvas` 中的内容会正常的现实出来\n* 再 `canvas` 标签内部书写内容，在支持的浏览器中，该内容会被忽略\n* 在不支持的浏览器中会将 `canvas` 标签会当作 `div` 标签来处理\n\n## canvas 的使用领域\n\n`canvas` 的使用领域很多:\n\n1. 游戏\n2. 可视化数据(重点)\n3. `banner` 广告\n4. 多媒体\n5. 未来\n    * 模拟仿真\n    * 远程操作\n    * 图形编辑\n\n## Canvas 怎么用？\n\n1. 创建一个 `Canvas` 标签\n2. 获取到该 `DOM` 对象\n3.  `Canvas` 只是一个画布，不能自己画画，需要画图工具\n4. 每个 `Canvas` 对应一个画图工具，通过 `canvas` 对象 `.getContext(\"2d\")` 参数有 `2d` 和 `webgl` 两种 `2d` 获取到一个 ` CanvasRenderingContext2D` 类型的对象,使用 `webgl` 返回 `WebGLRenderingContext` 类型的对象.\n\n## 如何画直线\n\n1. 先确定在何处下笔，画图工具 `.moveTo(x, y)`\n2. 确定从开始的点画到哪里去，  画图工具 `.lineTo(x, y)`\n3. 上面两步之后，线并没有画出来，而是描点，需要最后一步进行画线  画图工具 `.stroke();`\n\n```js\nvar canvas = document.createElement( 'canvas' );\ncanvas.width = 500;\ncanvas.height = 400;\ncanvas.style.border = '1px dashed red';\ndocument.body.appendChild( canvas );\n// 获得 CanvasRenderingContext2D 对象\nvar context = canvas.getContext( '2d' );\n// 设置 起点\ncontext.moveTo( 0, 0 );\n// 绘制直线\ncontext.lineTo( 500, 400 );\n// 设置 起点\ncontext.moveTo( 0, 400 );\n// 绘制直线\ncontext.lineTo( 500, 0 );\n// 描边显示效果\ncontext.stroke();\n```\n\n## lineTo的特性\n\n每次 `lineTo` 之后都会记录最后的 `lineTo` 的点，下次 `lineTo` 的时候就接着这个 `canvas` 只是一个画布，不能直接自己绘图，绘图需要使用工具sssss点继续画\n\n\n## closePath\n\n将最后一次 `lineTo` 的点 和最后一次 `moveTo` 的点连起来的\n两条线的交界处，如果使用的是 `closePath` 会补全缺口\n\n```js\nctx.moveTo( 100, 100 );\nctx.lineTo( 300, 100 );\nctx.lineTo( 300, 200 );\nctx.closePath();\nctx.stroke();\n```\n\n## fill\n\n可以将闭合的图形进行填充\n\n## 非零填充原则\n\n从一个闭合空间引出一条直线，如果该直线两边的箭头数量不相等，则要填充，如果相等则不填充\n\n一边有一个箭头就+1\n另一边有一个箭头就-1\n\n## 如何绘制曲线？\n\n使用 `for` 循环给每一个 `x` 对应一个 `y` 值，`x` 和 `y` 的关系需要是个多次幂的方程\n\n## 路径概念\n\n路径就是一次绘图，包含该次绘图中的所有的状态，线宽  颜色  是否虚线\n\n如果想要改变状态，就需要开启新的路径\n\n## beginPath\n\n可以用来开启新的路径\n\n## 线型相关属性\n\n|名称|描述|\n|:--:|:--:|\n|lineWidth|画线的时候的线的宽度|\n|setLineDash()|设置虚线各个线段的长度,参数是一个数组，会将数组中的数字循环使用|\n|getLineDash()|获取虚线各个线段的长度，如果是实线，获取到的是空数组|\n|lineDashOffset|设置虚线的偏移量，正值往左，负值往右|\n|strokeStyle|设置描边的，画线的颜色，颜色值可以为css中任意一种|\n|fillStyle|设置填充颜色，颜色值可以为css中任意一种|\n\n## 渐变色\n\n将线划分为 `256` 份，每一份为一个颜色，新画一条线，依次递增，就形成了一个颜色渐变的线段","slug":"canvas-part1","published":1,"updated":"2016-11-24T01:33:33.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3l0005csg7n9qcupi6"},{"title":"Canvas知识整理part2","date":"2016-11-14T11:42:44.000Z","_content":"Html5Canvas笔记整理，接part1篇！！\n\n绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法!\n1. 绘制矩形\n2. 绘制圆弧\n3. 绘制文本\n4. 绘制图片\n5. 绘制动画\n\n<!-- more -->\n\n## 绘制矩形\n\n1. strokeRect();\n\n```js\nstrokeRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，并描边\n- 用来绘制一个矩形. 比起直接使用 `moveTo` 和 `lineTo` 方法要简单许多.\n- 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.\n- 使用该方法不需要使用 `moveTo` 方法设置起始点, 也不需要调用 `stroke` 等绘画方法.\n- 绘制的矩形支持 `strokeStyle` 设置颜色样式.\n\n```js\nctx.strokeStyle = 'red';\nctx.strokeRect( 100, 100, 200, 100 );\n```\n\n2. fillRect();\n\n```js\nfillRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，并填充\n- 用来绘制一个矩形. 比起直接使用 `moveTo` 和 `lineTo` 方法要简单许多.\n- 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.\n- 使用该方法不需要使用 `moveTo` 方法设置起始点, 也不需要调用 `stroke` 等绘画方法.\n- 绘制的矩形支持 `fillStyle` 设置颜色样式.\n\n```js\nctx.fillStyle = 'green';\nctx.fillRect( 100, 100, 200, 100 );\n```\n\n3. rect();\n\n```js\nrect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, y坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，不描边\n\n4. clearRect();\n\n```js\nclearRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：清除指定的矩形区域\n- 用于清除画布中的矩形区域的内容.\n- 参数 `x`, `y` 表示矩形区域左上角的坐标,`width` 与 `height` 表示矩形区域的宽高.\n\n```js\nctx.fillRect( 100, 100, 200, 100 );\nctx.clearRect( 110, 110, 50, 50 );\n```\n\n* save restore\n\tsave 保存当前的路径状态\n\trestore 恢复上一次保存的路径状态( `restore` 是与之对应的,先 `save` 的,后被 `restore` )\n\t\n```js\nvar x = 10, y = 10, oldx = 10, oldy = 10;\nvar width = 100, height = 50;     \nvar intervalId = setInterval(function () {\n\tctx.clearRect( oldx - 1, oldy - 1, width + 2, height + 2 );\n\n\tctx.strokeRect( x, y, width, height );\n\n\toldx = x;\n\toldy = y;\n\n\tx += 4;\n\ty += 2;\n\n\tif ( oldy >= 200 ) {\n\t\t// clearInterval( intervalId );\n\t\tx = 10, y = 10;\n\t}\n}, 20);\n```\n\n## 绘制圆弧\n\n```js\narc(x, y, r, startAngle, endAngle, anticlockwise)\n```\n\n* `x,y` 圆心坐标\n* `r `  圆的半径\n* `startAngle` 起始角度（弧度表示）\n* `endAngle` 结束角度（弧度表示）\n* `anticlockwise` 是否逆时针绘制，注意找角的时候还是顺时针找\n\n注意事项，每次画完弧之后，都会保存点，下次绘图会从该点开始\n\n```js\n// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4\n...\nctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );\nctx.stroke();\n\n// 为了方便看清楚结构, 绘制坐标轴\nctx.beginPath();\nctx.strokeStyle = 'red';\nctx.moveTo( 50, 200 );\nctx.lineTo( 350, 200 );\n\nctx.moveTo( 200, 50 );\nctx.lineTo( 200, 350 );\n\nctx.moveTo( 200, 200 );\nctx.lineTo( 300, 300 );\n\nctx.stroke();\n```\n\n## 绘制扇形\n\n先 `moveTo` 圆心，然后画弧 ，然后 `closePath` 弧就有了\n\n```js\nctx.strokeStyle = 'red';\nctx.fillStyle = 'pink';\n\nctx.moveTo( 100, 200 );\nctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );\nctx.closePath();\nctx.stroke();\n\nctx.beginPath();\nctx.moveTo( 300, 200 );\nctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );\nctx.closePath();\nctx.fill();\n```\n\n## 绘制扇形动画\n\n绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 `-Math.PI / 2` 开始绘制. 那么每次角度都 `+0.1` , 直到 绘制到 `Math.PI * 3 / 2 `为止.\n\n```js\nctx.fillStyle = 'green';\nvar startAngle = -Math.PI / 2,\n\tangle = startAngle,\n\tx = 200, y = 200,\n\tr = 100;\nvar intervalId = setInterval(function () {\n\t// 清除之前绘制的内容\n\tctx.clearRect( 0, 0, cas.width, cas.height );\n\t// 角度增量\n\tangle += 0.1;\n\t// 判断是否停止计时器\n\tif ( angle >= Math.PI * 3 / 2 ) {\n\t\tclearInterval( intervalId);\n\t\tangle = Math.PI * 3 / 2; \n\t\tconsole.log( '绘制完成' );\n\t}\n\t// 绘制\n\tctx.moveTo( x, y );\n\tctx.arc( x, y, r, startAngle, angle );\n\tctx.fill();\n}, 20);\n```\n\n## 绘制饼形图\n\n\t等分的饼图,饼图的起始位置在\t`-90°` .\n绘制饼形图最大的特点是角度是叠加的. 开始从 `-Math.PI/2` 开始绘制, 达到执行角 `x` 后, 下一个区域从 `x` 开始绘制, 然后有到一个角 `y` 停下来. 如此反复到 `Math.PI * 3 / 2` 结束.\n\n```js\nvar x = 200, y = 200,\n\tr = 100,\n\tstep = Math.PI * 2 / 3,     // 120 度一个区域\n\tstart = -Math.PI / 2,       // 起始角度\n\tcolors = [ 'red', 'green', 'blue' ];\n\nfor ( var i = 0; i < 3; i++ ) {\n\tctx.beginPath();\n\tctx.moveTo( x, y );\n\tctx.fillStyle = colors[ i ];\n\tctx.arc( x, y, r, start, start+=step );\n\tctx.fill();\n}\n```","source":"_posts/canvas-part2.md","raw":"---\ntitle: Canvas知识整理part2\ndate: 2016-11-14 19:42:44\ntags: \n\t- Canvas\n\t- HTML5\n\t- 画布\ncategories: Canvas\n---\nHtml5Canvas笔记整理，接part1篇！！\n\n绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法!\n1. 绘制矩形\n2. 绘制圆弧\n3. 绘制文本\n4. 绘制图片\n5. 绘制动画\n\n<!-- more -->\n\n## 绘制矩形\n\n1. strokeRect();\n\n```js\nstrokeRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，并描边\n- 用来绘制一个矩形. 比起直接使用 `moveTo` 和 `lineTo` 方法要简单许多.\n- 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.\n- 使用该方法不需要使用 `moveTo` 方法设置起始点, 也不需要调用 `stroke` 等绘画方法.\n- 绘制的矩形支持 `strokeStyle` 设置颜色样式.\n\n```js\nctx.strokeStyle = 'red';\nctx.strokeRect( 100, 100, 200, 100 );\n```\n\n2. fillRect();\n\n```js\nfillRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，并填充\n- 用来绘制一个矩形. 比起直接使用 `moveTo` 和 `lineTo` 方法要简单许多.\n- 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.\n- 使用该方法不需要使用 `moveTo` 方法设置起始点, 也不需要调用 `stroke` 等绘画方法.\n- 绘制的矩形支持 `fillStyle` 设置颜色样式.\n\n```js\nctx.fillStyle = 'green';\nctx.fillRect( 100, 100, 200, 100 );\n```\n\n3. rect();\n\n```js\nrect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, y坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：绘制一个矩形路径，不描边\n\n4. clearRect();\n\n```js\nclearRect(x, y, w, h)\n```\n\n`x`, `x`坐标\n`y`, `y`坐标\n`w`, 矩形宽\n`h`, 矩形高\n功能：清除指定的矩形区域\n- 用于清除画布中的矩形区域的内容.\n- 参数 `x`, `y` 表示矩形区域左上角的坐标,`width` 与 `height` 表示矩形区域的宽高.\n\n```js\nctx.fillRect( 100, 100, 200, 100 );\nctx.clearRect( 110, 110, 50, 50 );\n```\n\n* save restore\n\tsave 保存当前的路径状态\n\trestore 恢复上一次保存的路径状态( `restore` 是与之对应的,先 `save` 的,后被 `restore` )\n\t\n```js\nvar x = 10, y = 10, oldx = 10, oldy = 10;\nvar width = 100, height = 50;     \nvar intervalId = setInterval(function () {\n\tctx.clearRect( oldx - 1, oldy - 1, width + 2, height + 2 );\n\n\tctx.strokeRect( x, y, width, height );\n\n\toldx = x;\n\toldy = y;\n\n\tx += 4;\n\ty += 2;\n\n\tif ( oldy >= 200 ) {\n\t\t// clearInterval( intervalId );\n\t\tx = 10, y = 10;\n\t}\n}, 20);\n```\n\n## 绘制圆弧\n\n```js\narc(x, y, r, startAngle, endAngle, anticlockwise)\n```\n\n* `x,y` 圆心坐标\n* `r `  圆的半径\n* `startAngle` 起始角度（弧度表示）\n* `endAngle` 结束角度（弧度表示）\n* `anticlockwise` 是否逆时针绘制，注意找角的时候还是顺时针找\n\n注意事项，每次画完弧之后，都会保存点，下次绘图会从该点开始\n\n```js\n// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4\n...\nctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );\nctx.stroke();\n\n// 为了方便看清楚结构, 绘制坐标轴\nctx.beginPath();\nctx.strokeStyle = 'red';\nctx.moveTo( 50, 200 );\nctx.lineTo( 350, 200 );\n\nctx.moveTo( 200, 50 );\nctx.lineTo( 200, 350 );\n\nctx.moveTo( 200, 200 );\nctx.lineTo( 300, 300 );\n\nctx.stroke();\n```\n\n## 绘制扇形\n\n先 `moveTo` 圆心，然后画弧 ，然后 `closePath` 弧就有了\n\n```js\nctx.strokeStyle = 'red';\nctx.fillStyle = 'pink';\n\nctx.moveTo( 100, 200 );\nctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );\nctx.closePath();\nctx.stroke();\n\nctx.beginPath();\nctx.moveTo( 300, 200 );\nctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );\nctx.closePath();\nctx.fill();\n```\n\n## 绘制扇形动画\n\n绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 `-Math.PI / 2` 开始绘制. 那么每次角度都 `+0.1` , 直到 绘制到 `Math.PI * 3 / 2 `为止.\n\n```js\nctx.fillStyle = 'green';\nvar startAngle = -Math.PI / 2,\n\tangle = startAngle,\n\tx = 200, y = 200,\n\tr = 100;\nvar intervalId = setInterval(function () {\n\t// 清除之前绘制的内容\n\tctx.clearRect( 0, 0, cas.width, cas.height );\n\t// 角度增量\n\tangle += 0.1;\n\t// 判断是否停止计时器\n\tif ( angle >= Math.PI * 3 / 2 ) {\n\t\tclearInterval( intervalId);\n\t\tangle = Math.PI * 3 / 2; \n\t\tconsole.log( '绘制完成' );\n\t}\n\t// 绘制\n\tctx.moveTo( x, y );\n\tctx.arc( x, y, r, startAngle, angle );\n\tctx.fill();\n}, 20);\n```\n\n## 绘制饼形图\n\n\t等分的饼图,饼图的起始位置在\t`-90°` .\n绘制饼形图最大的特点是角度是叠加的. 开始从 `-Math.PI/2` 开始绘制, 达到执行角 `x` 后, 下一个区域从 `x` 开始绘制, 然后有到一个角 `y` 停下来. 如此反复到 `Math.PI * 3 / 2` 结束.\n\n```js\nvar x = 200, y = 200,\n\tr = 100,\n\tstep = Math.PI * 2 / 3,     // 120 度一个区域\n\tstart = -Math.PI / 2,       // 起始角度\n\tcolors = [ 'red', 'green', 'blue' ];\n\nfor ( var i = 0; i < 3; i++ ) {\n\tctx.beginPath();\n\tctx.moveTo( x, y );\n\tctx.fillStyle = colors[ i ];\n\tctx.arc( x, y, r, start, start+=step );\n\tctx.fill();\n}\n```","slug":"canvas-part2","published":1,"updated":"2016-11-24T01:34:33.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3q0006csg7hx3iu5xh"},{"title":"js高级与面向对象之函数","date":"2016-07-22T11:40:39.000Z","_content":"\n## 函数声明\n\n```js\nfunction func(){\n    //函数体\n}\n//2.函数表达式\nvar func1 = function(){\n\n}\n//3.通过Function构造函数来创建\nvar func2 = new Function();\n```\n<!-- more -->\n\n### 函数的name属性\n\n```js\nfunction Person(){\n\n}\nvar p = new Person();\n//p.constructor\nconsole.log(typeof p);  //object\nconsole.log(p.constructor.toString());\nconsole.log(Person.name);\nconsole.log(p.constructor.name);\n```\n\n函数都会有一个 `name` 属性，所以我们可以通过对象先找到构造函数，然后直接访问构造函数的 `name` ，就拿到了具体类型\n\n## Function的使用\n\n### 语法:\n\n```js\n//Function函数所有的参数全都是字符串\n//Function函数的作用就是将所有的参数组合起来，变成一个函数\n//1、如果只传一个参数，那么这个函数必然是函数体\n//2、如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数\n//3、如果不传参数，表示创建一个空函数\nnew Function(arg1, arg2, arg3, ..., argN, body);\n```\n\n### 创建一个打印一句话的函数\n\n```js\n//传统的方式\nfunction foo(){\n    console.log(\"你好\");\n}\n\n//使用Function\nvar func = new Function(\"console.log('你好');\");\n```\n\n### 创建一个空函数\n\n```js\n//传统的方式\nfunction foo(){}\n\n//Function\nvar func = new Function();\n```\n\n### 创建一个有参数的函数\n\n```js\n//传统的方式\nfunction foo(num){\n    console.log(num);\n}\n\n//Function\n\nvar func = new Function(){\"num\", \"console.log(num);\"};\n```\n\n## 静态成员与实例成员的概念\n\n静态成员和实例成员这两个概念其实也是从面相对象的编程语言中引入的，对应到 `JavaScript` 中的理解为：\n\n### 静态成员\n\n* 静态成员是指静态属性和静态方法，所谓静态，就是有构造函数提供的。\n\n### 实例成员\n\n* 实例成员是值实例属性和实例方法，所谓实例，就是由构造函数创建出来的对象。\n\n### 举例说明\n\n```js\nfunction Person(){\n    this.name = \"zs\",\n    this.sayHello = function(){\n        console.log(\"Hello World\");\n    }\n}\n\n//下面这个sayHi方法就是构造函数自己的方法，也就是静态方法\nPerson.sayHi = function(){\n    console.log(\"I'm a Person\");\n}\n\n//原型属性属于构造函数，所以原型属性是静态属性\nPerson.prototype = {};\nvar p = new Person();\n\n//这里的name是构造函数创建出来的实例对象的属性，所以是实例属性\np.name = \"李四\";\n\n\n//这里的sayHello也是构造函数创建出来的实例对象的方法，所以是实例方法\np.sayHello();\n```\n提示：\n\n一般工具型方法都有静态成员提供, 一般与实例对象有关的方法由实例成员表示.\n\n工具方法：比如 `jQuery.Ajax()` 、 `jQuery.trim()` 、 `jQuery.Each()`","source":"_posts/javascript-Function.md","raw":"---\ntitle: js高级与面向对象之函数\ndate: 2016-07-22 19:40:39\ntags:\n\t- Function\ncategories: javascript\n---\n\n## 函数声明\n\n```js\nfunction func(){\n    //函数体\n}\n//2.函数表达式\nvar func1 = function(){\n\n}\n//3.通过Function构造函数来创建\nvar func2 = new Function();\n```\n<!-- more -->\n\n### 函数的name属性\n\n```js\nfunction Person(){\n\n}\nvar p = new Person();\n//p.constructor\nconsole.log(typeof p);  //object\nconsole.log(p.constructor.toString());\nconsole.log(Person.name);\nconsole.log(p.constructor.name);\n```\n\n函数都会有一个 `name` 属性，所以我们可以通过对象先找到构造函数，然后直接访问构造函数的 `name` ，就拿到了具体类型\n\n## Function的使用\n\n### 语法:\n\n```js\n//Function函数所有的参数全都是字符串\n//Function函数的作用就是将所有的参数组合起来，变成一个函数\n//1、如果只传一个参数，那么这个函数必然是函数体\n//2、如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数\n//3、如果不传参数，表示创建一个空函数\nnew Function(arg1, arg2, arg3, ..., argN, body);\n```\n\n### 创建一个打印一句话的函数\n\n```js\n//传统的方式\nfunction foo(){\n    console.log(\"你好\");\n}\n\n//使用Function\nvar func = new Function(\"console.log('你好');\");\n```\n\n### 创建一个空函数\n\n```js\n//传统的方式\nfunction foo(){}\n\n//Function\nvar func = new Function();\n```\n\n### 创建一个有参数的函数\n\n```js\n//传统的方式\nfunction foo(num){\n    console.log(num);\n}\n\n//Function\n\nvar func = new Function(){\"num\", \"console.log(num);\"};\n```\n\n## 静态成员与实例成员的概念\n\n静态成员和实例成员这两个概念其实也是从面相对象的编程语言中引入的，对应到 `JavaScript` 中的理解为：\n\n### 静态成员\n\n* 静态成员是指静态属性和静态方法，所谓静态，就是有构造函数提供的。\n\n### 实例成员\n\n* 实例成员是值实例属性和实例方法，所谓实例，就是由构造函数创建出来的对象。\n\n### 举例说明\n\n```js\nfunction Person(){\n    this.name = \"zs\",\n    this.sayHello = function(){\n        console.log(\"Hello World\");\n    }\n}\n\n//下面这个sayHi方法就是构造函数自己的方法，也就是静态方法\nPerson.sayHi = function(){\n    console.log(\"I'm a Person\");\n}\n\n//原型属性属于构造函数，所以原型属性是静态属性\nPerson.prototype = {};\nvar p = new Person();\n\n//这里的name是构造函数创建出来的实例对象的属性，所以是实例属性\np.name = \"李四\";\n\n\n//这里的sayHello也是构造函数创建出来的实例对象的方法，所以是实例方法\np.sayHello();\n```\n提示：\n\n一般工具型方法都有静态成员提供, 一般与实例对象有关的方法由实例成员表示.\n\n工具方法：比如 `jQuery.Ajax()` 、 `jQuery.trim()` 、 `jQuery.Each()`","slug":"javascript-Function","published":1,"updated":"2016-11-24T01:28:37.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3v0009csg7p7r7eha8"},{"title":"Hexo 最常用的几个命令","date":"2015-08-28T10:29:33.000Z","_content":"Hexo 约有二十个命令，但普通用户经常使用的大概只有下列几个:\n\n<!-- more -->\n\n## hexo s\n\n```bash\n$ hexo s\n```\n\n### 启动本地服务器 ###\n用于预览主题。默认地址： http://localhost:4000/\n\t\n* hexo s 是 hexo server 的缩写，命令效果一致；\n* 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；\n* 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。\n\t\n## hexo new\n\n\n``` bash\n$ hexo new \"学习笔记  六\"\n```\n\n### 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。\n\t\n* 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些，纯字母一般不加引号。\n\n## hexo d\n\n```bash\n$ hexo d\n```\n\n### 自动生成网站静态文件，并部署到设定的仓库。\n\n* hexo d 是 hexo deploy 的缩写，命令效果一致。\n\n## hexo clean\n\n``` bash\n$ hexo clean\n```\n\n### 清除缓存文件 db.json 和已生成的静态文件 public 。\n\t\n* 网站显示异常时可以执行这条命令试试。\n\n## hexo g\n\n``` bash\n$ hexo g\n```\n\n### 生成网站静态文件到默认设置的 public 文件夹。\n\t\n* 便于查看网站生成的静态文件或者手动部署网站；\n* 如果使用自动部署，不需要先执行该命令；\n* hexo g 是 hexo generate 的缩写，命令效果一致。\n\n## hexo new page\n\n``` bash\n$ hexo new page aboutme\n```\n\n### 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/\n\n* 标题可以为中文，但一般习惯用英文；\n* 页面标题和文章一样可以随意修改；\n* 页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。","source":"_posts/hello-world.md","raw":"---\ntitle: Hexo 最常用的几个命令\ndate: 2015-08-28 18:29:33\ntags: \n\t- hexo\n\t- 梦魇小栈\n\t- 梦魇\n\t- houyi1121\ncategories: Hexo\n---\nHexo 约有二十个命令，但普通用户经常使用的大概只有下列几个:\n\n<!-- more -->\n\n## hexo s\n\n```bash\n$ hexo s\n```\n\n### 启动本地服务器 ###\n用于预览主题。默认地址： http://localhost:4000/\n\t\n* hexo s 是 hexo server 的缩写，命令效果一致；\n* 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；\n* 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。\n\t\n## hexo new\n\n\n``` bash\n$ hexo new \"学习笔记  六\"\n```\n\n### 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。\n\t\n* 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些，纯字母一般不加引号。\n\n## hexo d\n\n```bash\n$ hexo d\n```\n\n### 自动生成网站静态文件，并部署到设定的仓库。\n\n* hexo d 是 hexo deploy 的缩写，命令效果一致。\n\n## hexo clean\n\n``` bash\n$ hexo clean\n```\n\n### 清除缓存文件 db.json 和已生成的静态文件 public 。\n\t\n* 网站显示异常时可以执行这条命令试试。\n\n## hexo g\n\n``` bash\n$ hexo g\n```\n\n### 生成网站静态文件到默认设置的 public 文件夹。\n\t\n* 便于查看网站生成的静态文件或者手动部署网站；\n* 如果使用自动部署，不需要先执行该命令；\n* hexo g 是 hexo generate 的缩写，命令效果一致。\n\n## hexo new page\n\n``` bash\n$ hexo new page aboutme\n```\n\n### 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/\n\n* 标题可以为中文，但一般习惯用英文；\n* 页面标题和文章一样可以随意修改；\n* 页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。","slug":"hello-world","published":1,"updated":"2016-11-24T01:16:30.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw3y000bcsg77f63obcr"},{"title":"js高级与面向对象之继承","date":"2016-06-15T05:43:28.000Z","_content":"\n一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承\n\n<!-- more -->\n\n## 继承的实现方式\n\n### 混入式继承\n\n```js\nvar obj = {};\nvar obj1 = {\n    money : 10000000,\n    car : 100,\n    brand: \"布加迪威航\",\n    huaqian: function(){\n        console.log(\"不差钱，随便花\");\n    }\n};\nconsole.log(obj);\n\nfor(var k in obj1){\n    //money\n    //car\n    //brand\n    //huaqian\n    obj[k] = obj1[k];\n}\n\nconsole.log(obj);\n```\n\n### 原型继承\n\n* 通过修改原型实现的继承 就是原型继承\n\t通过构造函数创建出来的对象继承自构造函数的原型对象\n\n```js\nvar human = {\n    gender:\"female\",\n    height: 170,\n    weight: 50\n}\nfunction Person(){\n\n}\n//Person.prototype.name = \"王莉莉\";\n```\n\n#### 原型继承的方式\n\n1. 通过混入的方式给原型添加属性和方法\n\n```js\n//Person.prototype\nvar human = {\n    gender:\"female\",\n    height: 170,\n    weight: 50\n}\nfunction Person(){\n\n}\nPerson.prototype.name = \"王莉莉\";\n\nfor(var k in human){\n    Person.prototype[k] = human[k];\n}\nvar p = new Person();\nconsole.log(p.name,p.gender,p.height,p.weight);\n```\n\n2. 修改原型对象\n\n```js\nPerson.prototype.maimeng = function (){\n    console.log(\"感觉自己萌萌哒\");\n}\n\np.maimeng();\n```\n\n3. 替换原型对象\n\n```js\nPerson.prototype = human;\nvar p = new Person();\nconsole.log(p.gender);\n```\n\n### 经典继承\n\n《JavaScript语言精粹》\n* 调用一个方法，就能实现继承\n`var obj1 = Object.create(obj)`\n* 创建出来一个新的继承自参数 `obj` 的对象 `obj1` \n* 其实内部使用的就是原型继承\n* ES5才支持的这个方法 需要考虑兼容性问题\n\n```js\nvar human = {\n    name: \"王莉莉\",\n    gender: \"female\",\n    dance :function(){\n        console.log(\"二人转，转转转\")\n    }\n}\n\nvar obj = Object.create(human);\n\nconsole.log(obj);\n```\n\n## 处理经典继承的兼容性问题\n\n```js\nif(Object.create){\n    var obj = Object.create({name:\"李狗二\",age:18});\n}else{\n    Object.create = function(obj){\n\n\t\t//在这个函数中要实现的功能\n\t\t//就是，创建一个对象，将obj设置为该对象的原型\n\n\t\t//要设置原型，只能通过两种方式，\n\t\t// 一种是 对象.__proto__  另外一种是 构造函数.prototype\n\t\t//由于__proto__这个属性有兼容性问题，所以不使用\n\t\t//就只能使用 构造函数.prototype 去替换原型对象了\n\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n\n//不推荐直接修改内置对象，因为在多人开发的时候，会产生冲突\n\nObject.creat = function () {\n    console.log(\"我是李二狗，我的create方法就是用来输出这句话的，哈哈哈\");\n}\n\nfunction hanyingxinCreate(obj){\n    if(Object.create){\n        return Object.creat(obj);\n    }else{\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n\n```\n\n## 继承的实际应用\n\n* 扩展内置对象\n\n* 扩展 `string` 的方法  `trim()`\n\n```js\n//$.trim()\n\nArray.prototype.sayHello = function () {\n   console.log(\"Hello, i'm a Array\")\n}\n\nvar arr = new Array();\narr.sayHello();\n\nvar arr1 = [];\narr1.sayHello();\n\n//需求分析\n//1.创建出来的对象得有数组的所有的方法和属性\n//2.创建输出来的对象得有sayHello方法\n//3.不能修改原生的内置对象\n\n\nfunction MyArray(){\n\n}\n\nMyArray.prototype = [];\nMyArray.prototype.sayHello = function () {\n    console.log(\"相加就加，随心所欲，为所欲为\");\n}\n\nvar myArr = new MyArray();\nmyArr.push(1,2,3,4,4,5);\nconsole.log(myArr);\nmyArr.sayHello();\n```","source":"_posts/javascript-inherit.md","raw":"---\ntitle: js高级与面向对象之继承\ndate: 2016-06-15 13:43:28\ntags: \n\t- javascript\n\t- js面向对象\n\t- 继承\n\t- 继承的实现方式\ncategories: javascript\n---\n\n一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承\n\n<!-- more -->\n\n## 继承的实现方式\n\n### 混入式继承\n\n```js\nvar obj = {};\nvar obj1 = {\n    money : 10000000,\n    car : 100,\n    brand: \"布加迪威航\",\n    huaqian: function(){\n        console.log(\"不差钱，随便花\");\n    }\n};\nconsole.log(obj);\n\nfor(var k in obj1){\n    //money\n    //car\n    //brand\n    //huaqian\n    obj[k] = obj1[k];\n}\n\nconsole.log(obj);\n```\n\n### 原型继承\n\n* 通过修改原型实现的继承 就是原型继承\n\t通过构造函数创建出来的对象继承自构造函数的原型对象\n\n```js\nvar human = {\n    gender:\"female\",\n    height: 170,\n    weight: 50\n}\nfunction Person(){\n\n}\n//Person.prototype.name = \"王莉莉\";\n```\n\n#### 原型继承的方式\n\n1. 通过混入的方式给原型添加属性和方法\n\n```js\n//Person.prototype\nvar human = {\n    gender:\"female\",\n    height: 170,\n    weight: 50\n}\nfunction Person(){\n\n}\nPerson.prototype.name = \"王莉莉\";\n\nfor(var k in human){\n    Person.prototype[k] = human[k];\n}\nvar p = new Person();\nconsole.log(p.name,p.gender,p.height,p.weight);\n```\n\n2. 修改原型对象\n\n```js\nPerson.prototype.maimeng = function (){\n    console.log(\"感觉自己萌萌哒\");\n}\n\np.maimeng();\n```\n\n3. 替换原型对象\n\n```js\nPerson.prototype = human;\nvar p = new Person();\nconsole.log(p.gender);\n```\n\n### 经典继承\n\n《JavaScript语言精粹》\n* 调用一个方法，就能实现继承\n`var obj1 = Object.create(obj)`\n* 创建出来一个新的继承自参数 `obj` 的对象 `obj1` \n* 其实内部使用的就是原型继承\n* ES5才支持的这个方法 需要考虑兼容性问题\n\n```js\nvar human = {\n    name: \"王莉莉\",\n    gender: \"female\",\n    dance :function(){\n        console.log(\"二人转，转转转\")\n    }\n}\n\nvar obj = Object.create(human);\n\nconsole.log(obj);\n```\n\n## 处理经典继承的兼容性问题\n\n```js\nif(Object.create){\n    var obj = Object.create({name:\"李狗二\",age:18});\n}else{\n    Object.create = function(obj){\n\n\t\t//在这个函数中要实现的功能\n\t\t//就是，创建一个对象，将obj设置为该对象的原型\n\n\t\t//要设置原型，只能通过两种方式，\n\t\t// 一种是 对象.__proto__  另外一种是 构造函数.prototype\n\t\t//由于__proto__这个属性有兼容性问题，所以不使用\n\t\t//就只能使用 构造函数.prototype 去替换原型对象了\n\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n\n//不推荐直接修改内置对象，因为在多人开发的时候，会产生冲突\n\nObject.creat = function () {\n    console.log(\"我是李二狗，我的create方法就是用来输出这句话的，哈哈哈\");\n}\n\nfunction hanyingxinCreate(obj){\n    if(Object.create){\n        return Object.creat(obj);\n    }else{\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n\n```\n\n## 继承的实际应用\n\n* 扩展内置对象\n\n* 扩展 `string` 的方法  `trim()`\n\n```js\n//$.trim()\n\nArray.prototype.sayHello = function () {\n   console.log(\"Hello, i'm a Array\")\n}\n\nvar arr = new Array();\narr.sayHello();\n\nvar arr1 = [];\narr1.sayHello();\n\n//需求分析\n//1.创建出来的对象得有数组的所有的方法和属性\n//2.创建输出来的对象得有sayHello方法\n//3.不能修改原生的内置对象\n\n\nfunction MyArray(){\n\n}\n\nMyArray.prototype = [];\nMyArray.prototype.sayHello = function () {\n    console.log(\"相加就加，随心所欲，为所欲为\");\n}\n\nvar myArr = new MyArray();\nmyArr.push(1,2,3,4,4,5);\nconsole.log(myArr);\nmyArr.sayHello();\n```","slug":"javascript-inherit","published":1,"updated":"2016-11-24T01:27:30.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw43000ecsg74refkm7h"},{"title":"JQuery分析及实现part1框架结构","date":"2016-11-18T10:40:35.000Z","_content":"\nJQuery模块分析及其实现第一部分!\n\n<img src=\"https://oisha19l0.qnssl.com/20161119.png\" width=\"100%\">\n\n<!-- more -->\n\n## 案例：获取指定DOM下所有子元素\n\t\n1. 在框架内部，遍历子节点，应该使用 `firstChild` 和 `nextSibling` 两种方式实现,代码如下。\n获取 `id` 为 `dv` 的元素下所有的子元素 `nodeType：1 - 12 (1 2 3 8 9 11 --documentFrament)` .\n\n* 第一种方式: `childNodes`\n\n```js\n// 实现思路：\n// 通过childNodes获取到所有的子节点；\n// 将上述所有的子节点中，元素节点获取出来。\n/**\n * [getChildren 获取子元素]\n * @param  {[type]} parent [父节点]\n * @return {[type]}        [返回parent的所有子元素]\n */\nfunction getChildren(parent) {\n\t// 存储结果集\n\tvar ret = [],\n\t\tnodes;\n\t// 获取parent所有子节点\n\tnodes = parent.childNodes;\n\n\t// 遍历nodes\n\tfor(var i = 0,l = nodes.length; i < l;i++){\n\t\t// 如果遍历到当前子节点类型为元素，即为所要结果。存储在ret内。\n\t\tif(nodes[i].nodeType === 1) {\n\t\t\tret.push(nodes[i]);\n\t\t}\n\t}\n\t// 返回结果\n\treturn ret;\n}\nconsole.log(getChildren(document.getElementById('dv')));\n```\n\n* 第二种方式：`firstChild nextSibling（推荐）`\n\n```js\n//使用while方式\nfunction getChildren(parent) {\n\tvar ret = [],\n\t\telem = parent.firstChild;\n\t// 遍历parent所有子节点\n\t// 如果有子节点\n\twhile(elem){\n\t\t// 并且节点类型为元素。存储在ret内\n\t\tif(elem.nodeType === 1) ret.push(elem);\n\t\t// 更新循环标量\n\t\t// 赋值为下一个兄弟节点\n\t\telem = elem.nextSibling;\n\t}\n\t// 返回结果\n\treturn ret;\n} \n\n\n//使用for循环\nfunction getChildren(parent) {\n\tvar ret = [],\n\t\telem = parent.firstChild;\n\tfor(; elem ; elem = elem.nextSibling){\n\t\tif(elem.nodeType === 1) ret.push(elem);\n\t}\t\t\t\n\treturn ret;\n}\n\nconsole.log(getChildren(document.getElementById('dv')));\n```\n\n## 框架结构\n\n1. 在编写框架的时候，为了防止变量污染，尽量使用沙箱模式 封装框架\n\t+ 在沙箱内部，如果经常使用全局变量或全局对象的话，最好的做法就是将它们当做实参传入沙箱内。\n\n2. 核心函数为 `itcast` ，相当于 `jQuery` 。最终要暴露给用户使用的\n\n3. 实现 `itcast` 函数，使用的是 工厂模式 来 创建对象。好处：用户 `new` 或 不 `new` 都可以得到正确的对象\n\n4.  `init` 构造函数 的 位置\n\n\t+ 如果放在沙箱内部，用户是无法修改或重写的。所以要容纳更改用户，尽量将构造函数暴露给用户\n\t+ 可以把构造函数放在 `itcast` 函数上，也可以放在 `itcast` 函数原型上。\n\t+ 处于 `jQuery` 之父，在写简单继承模式时，将构造函数放在其原型上。那么在编写框架时，即延续下来了\n\n5.  `init` 创建出来的对象，最终继承自 `itcast.prototype` 。所以可以将 `init` 对象称为 `itcast` 对象。\n\n6. 由于暴露给用户 的 是 `itcast` 和 其原型。所以在扩展成员时，只能在这两个对象上扩展。而在函数对象上扩展的成员 为 静态成员。可以直接通过函数名字来访问。但是，在原型上的成员，必须创建实例来访问。因此为了实现 `init` 对象可以访问 `itcast` 原型上的成员，就基于原型来实现继承。\n\n```js\n(function(global) {\n\tvar init;\n\t// 核心函数（工厂函数）\n\tvar itcast = function(selector) {\n\t\treturn new itcast.fn.init(selector);\n\t};\n\n\t// 核心原型\t\n\titcast.fn = itcast.prototype = {\n\t\tconstructor: itcast\n\t};\n\n\t// 构造函数\n\tinit = itcast.fn.init = function(selector) {};\n\t// 实现init对象继承自itcast原型\n\tinit.prototype = itcast.fn;\n\n\t// 可扩展方法\n\t// 如果target为undefined值，那么就是给this扩展成员\n\t// 否则就是给target对象扩展。\n\titcast.extend = itcast.fn.extend = function(source, target) {\n\t\tvar k;\n\t\t// 如果target为undefined值，就赋值为this\n\t\t// 给this扩展成员\n\t\tif (target == undefined) {\n\t\t\ttarget = this;\n\t\t}\t\n\n\t\t// target = target || this;\n\n\t\tfor(k in source){\n\t\t\ttarget[k] = source[k];\n\t\t}\t\t\n\t};\n\t// 暴露给用户\n\tglobal.$ = global.itcast = itcast;\n}(window));\n\nitcast.fn.addClass = function(className) {};\nitcast.fn.append = function(className) {};\n```\n\n7. 完善`init`构造函数\n\n\t+ `selector` 类型：\n\t\t- 无效值： `null` `undefined` `' '` `false`\n\t\t- 字符串\n\t\t\t* 选择器：\t `div` 根据选择器筛选dom元素，并以伪数组形式 存储在 `this` 上\n\t\t\t*  `html` 字符串 `<p>123</p><p>456</p>` `<p>` 将html字符串 转换成 `html` 元素\n\t\t- `DOM` 节点 \n\t\t- `DOM` 数组（伪数组） \n\t\t- `function`：入口函数 `DOMContentLoaded`\n\t\t\t* 使用静态属性 `isReady` 存储 `dom` 树是否加载完毕\n\t\t\t* 判断 `isReady` 值， 如果为 `true` ，就直接执行传入的函数。\n\t\t\t* 否则，就给 `document` 的 `DOMContentLoaded` 事件绑定处理程序，在处理程序中，先将 `isReady` 赋值为 `true` ，在执行传入的函数。\n\n8. 如何判断字符串为 `html` 字符串，必须满足一下条件：\n\n\t* 以 `<` 开头\n\t* 以 `>` 结尾\n\t* 最小长度为 `3`\n\n9. 如何判断像数组（数组和伪数组）\n\n\t+ 用 `length` 属性去判断，若具有 `length` 属性 表示为 像数组类型\n\t+ 除了 `window` 对象以及函数对象\n\t+  `{length: 1} {4: \"123\", length: 5}` 稀疏数组\n\n\t+ 如果为真数组，返回 `true`\n\t+ 如果 `length` 属性值为 `0` （除了 `window` 对象以及函数对象），返回 `true`\n\t+ 如果 `length` 属性值 `>0`, 如果对象 具有 `length - 1` 索引，返回 `true`\n\n10. 全局对象 `window` 特性：有一个 `window` 属性 引用 自身。\n\n```js\n(function(global) {\n\tvar init,\n\t\tdocument = global.document;\n\n\tvar itcast = function(selector) {\n\t\treturn new itcast.fn.init(selector);\n\t};\n\n\titcast.fn = itcast.prototype = {\n\t\tconstructor: itcast,\n\t\tlength: 0\n\t};\n\tinit = itcast.fn.init = function(selector) {\n\t\t// handle: null undefined '' false\n\t\tif(!selector) return this;\n\t\t// handle: string\n\t\telse if(itcast.isString(selector)){\n\t\t\t// handle: html string '<p>123</p>'\n\t\t\tif(itcast.isHTML(selector)){\t\t\t\t\t\t\n\t\t\t\t// 怎么存储 以伪数组对象形式存储 dom元素\n\t\t\t\tArray.prototype.push.apply(this, itcast.parseHTML(selector));\n\t\t\t}\n\t\t\t// handle: selector\n\t\t\telse {\n\t\t\t\t// 根据选择器获取dom元素\n\t\t\t\tvar nodelist = document.querySelectorAll(selector);\n\t\t\t\t// 将结果伪数组对象 变成 真数组\n\t\t\t\tvar ret = Array.prototype.slice.call(nodelist);\n\t\t\t\t// 借调数组对象的slice方法将数组中的所有元素 以伪数组形式存储在this上\n\t\t\t\tArray.prototype.push.apply(this, ret);\n\t\t\t}\n\t\t}\n\t\t// handle: dom node\n\t\telse if(itcast.isDOM(selector)){\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t}\n\t\t// handle: dom array(伪数组对象)\n\t\telse if(itcast.isArrayLike(selector)){\n\t\t\t// 获取selector类型\n\t\t\tvar _type = Object.prototype.toString.call(selector).\n\t\t\t\t\tslice(8, -1).toLowerCase();\n\t\t\t// 如果不是数组类型,就 将其转换 为 真数组类型\n\t\t\tif(_type !== 'array') \n\t\t\t\tselector = Array.prototype.slice.call(selector);\n\t\t\tArray.prototype.push.apply(this, selector);\n\t\t}\t\n\t\t// handle: function\n\t\telse if(itcast.isFunction(selector)){\n\t\t\tif(itcast.isReady){\n\t\t\t\tselector();\n\t\t\t} else {\n\t\t\t\tdoucment.addEventListener('DOMContentLoaded', function() {\n\t\t\t\t\tselector();\n\t\t\t\t\titcast.isReady = true;\n\t\t\t\t});\t\n\t\t\t}\n\t\t}\n\t};\n\tinit.prototype = itcast.fn;\n\n\titcast.extend = itcast.fn.extend = function(source, target) {\n\t\tvar k;\n\n\t\ttarget = target || this;\n\n\t\tfor(k in source){\n\t\t\ttarget[k] = source[k];\n\t\t}\n\t};\n\n\t// 添加工具类方法\n\titcast.extend({\n\t\tisReady: false,\n\t\tpaseHTML: function(html) {\n\t\t\tvar div = document.createElement('div'),\n\t\t\t\tret = [];\n\t\t\tdiv.innerHTML = html;\n\n\t\t\tfor(var elem = div.firstChild; elem; elem = elem.nextSibling){\n\t\t\t\tif(elem.nodeType === 1) ret.push(elem);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t});\n\t// 类型判断方法\n\titcast.extend({\n\t\t// 判断是否为字符串类型\n\t\tisString: function(obj) {\n\t\t\t// 如果为null或undefined，返回false\n\t\t\t// 如果typeof值为string，返回true否则返回false。\n\t\t\treturn !!obj && typeof obj === 'string';\n\t\t},\n\t\tisHTML: function(obj) {\n\t\t\treturn !!obj && obj.charAt(0) === '<' && \n\t\t\t\tobj.charAt(obj.length - 1) === '>' &&\n\t\t\t\tobj.length >= 3;\n\t\t},\n\t\tisDOM: function(obj) {\n\t\t\treturn !!obj && !!obj.nodeType;\n\t\t},\n\t\tisFunction: function(obj) {\n\t\t\treturn !!obj && typeof obj === 'function';\n\t\t},\n\t\tisGlobal: function(obj) {\n\t\t\treturn !!obj && obj.window === obj;\n\t\t},\n\t\tisArrayLike: function(obj) {\n\t\t\tvar _type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(),\n\t\t\t\tlength = !!obj && 'length' in obj && obj.length;\n\t\t\t// 过滤 window对象和函数对象\n\t\t\tif(itcast.isFunction(obj) || itcast.isGlobal(obj)) return false;\n\t\t\treturn _type === 'array' || length === 0 || \n\t\t\t\ttypeof length === 'number' && length > 0 && (length - 1) in obj;\n\t\t}\n\t});\n\n\tglobal.$ = global.itcast = itcast;\n}(window));\n```\n\n到此,一个完整的 `init` 框架结构就好了!\n","source":"_posts/javascript-jquery-part1.md","raw":"---\ntitle: JQuery分析及实现part1框架结构\ndate: 2016-11-18 18:40:35\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第一部分!\n\n<img src=\"https://oisha19l0.qnssl.com/20161119.png\" width=\"100%\">\n\n<!-- more -->\n\n## 案例：获取指定DOM下所有子元素\n\t\n1. 在框架内部，遍历子节点，应该使用 `firstChild` 和 `nextSibling` 两种方式实现,代码如下。\n获取 `id` 为 `dv` 的元素下所有的子元素 `nodeType：1 - 12 (1 2 3 8 9 11 --documentFrament)` .\n\n* 第一种方式: `childNodes`\n\n```js\n// 实现思路：\n// 通过childNodes获取到所有的子节点；\n// 将上述所有的子节点中，元素节点获取出来。\n/**\n * [getChildren 获取子元素]\n * @param  {[type]} parent [父节点]\n * @return {[type]}        [返回parent的所有子元素]\n */\nfunction getChildren(parent) {\n\t// 存储结果集\n\tvar ret = [],\n\t\tnodes;\n\t// 获取parent所有子节点\n\tnodes = parent.childNodes;\n\n\t// 遍历nodes\n\tfor(var i = 0,l = nodes.length; i < l;i++){\n\t\t// 如果遍历到当前子节点类型为元素，即为所要结果。存储在ret内。\n\t\tif(nodes[i].nodeType === 1) {\n\t\t\tret.push(nodes[i]);\n\t\t}\n\t}\n\t// 返回结果\n\treturn ret;\n}\nconsole.log(getChildren(document.getElementById('dv')));\n```\n\n* 第二种方式：`firstChild nextSibling（推荐）`\n\n```js\n//使用while方式\nfunction getChildren(parent) {\n\tvar ret = [],\n\t\telem = parent.firstChild;\n\t// 遍历parent所有子节点\n\t// 如果有子节点\n\twhile(elem){\n\t\t// 并且节点类型为元素。存储在ret内\n\t\tif(elem.nodeType === 1) ret.push(elem);\n\t\t// 更新循环标量\n\t\t// 赋值为下一个兄弟节点\n\t\telem = elem.nextSibling;\n\t}\n\t// 返回结果\n\treturn ret;\n} \n\n\n//使用for循环\nfunction getChildren(parent) {\n\tvar ret = [],\n\t\telem = parent.firstChild;\n\tfor(; elem ; elem = elem.nextSibling){\n\t\tif(elem.nodeType === 1) ret.push(elem);\n\t}\t\t\t\n\treturn ret;\n}\n\nconsole.log(getChildren(document.getElementById('dv')));\n```\n\n## 框架结构\n\n1. 在编写框架的时候，为了防止变量污染，尽量使用沙箱模式 封装框架\n\t+ 在沙箱内部，如果经常使用全局变量或全局对象的话，最好的做法就是将它们当做实参传入沙箱内。\n\n2. 核心函数为 `itcast` ，相当于 `jQuery` 。最终要暴露给用户使用的\n\n3. 实现 `itcast` 函数，使用的是 工厂模式 来 创建对象。好处：用户 `new` 或 不 `new` 都可以得到正确的对象\n\n4.  `init` 构造函数 的 位置\n\n\t+ 如果放在沙箱内部，用户是无法修改或重写的。所以要容纳更改用户，尽量将构造函数暴露给用户\n\t+ 可以把构造函数放在 `itcast` 函数上，也可以放在 `itcast` 函数原型上。\n\t+ 处于 `jQuery` 之父，在写简单继承模式时，将构造函数放在其原型上。那么在编写框架时，即延续下来了\n\n5.  `init` 创建出来的对象，最终继承自 `itcast.prototype` 。所以可以将 `init` 对象称为 `itcast` 对象。\n\n6. 由于暴露给用户 的 是 `itcast` 和 其原型。所以在扩展成员时，只能在这两个对象上扩展。而在函数对象上扩展的成员 为 静态成员。可以直接通过函数名字来访问。但是，在原型上的成员，必须创建实例来访问。因此为了实现 `init` 对象可以访问 `itcast` 原型上的成员，就基于原型来实现继承。\n\n```js\n(function(global) {\n\tvar init;\n\t// 核心函数（工厂函数）\n\tvar itcast = function(selector) {\n\t\treturn new itcast.fn.init(selector);\n\t};\n\n\t// 核心原型\t\n\titcast.fn = itcast.prototype = {\n\t\tconstructor: itcast\n\t};\n\n\t// 构造函数\n\tinit = itcast.fn.init = function(selector) {};\n\t// 实现init对象继承自itcast原型\n\tinit.prototype = itcast.fn;\n\n\t// 可扩展方法\n\t// 如果target为undefined值，那么就是给this扩展成员\n\t// 否则就是给target对象扩展。\n\titcast.extend = itcast.fn.extend = function(source, target) {\n\t\tvar k;\n\t\t// 如果target为undefined值，就赋值为this\n\t\t// 给this扩展成员\n\t\tif (target == undefined) {\n\t\t\ttarget = this;\n\t\t}\t\n\n\t\t// target = target || this;\n\n\t\tfor(k in source){\n\t\t\ttarget[k] = source[k];\n\t\t}\t\t\n\t};\n\t// 暴露给用户\n\tglobal.$ = global.itcast = itcast;\n}(window));\n\nitcast.fn.addClass = function(className) {};\nitcast.fn.append = function(className) {};\n```\n\n7. 完善`init`构造函数\n\n\t+ `selector` 类型：\n\t\t- 无效值： `null` `undefined` `' '` `false`\n\t\t- 字符串\n\t\t\t* 选择器：\t `div` 根据选择器筛选dom元素，并以伪数组形式 存储在 `this` 上\n\t\t\t*  `html` 字符串 `<p>123</p><p>456</p>` `<p>` 将html字符串 转换成 `html` 元素\n\t\t- `DOM` 节点 \n\t\t- `DOM` 数组（伪数组） \n\t\t- `function`：入口函数 `DOMContentLoaded`\n\t\t\t* 使用静态属性 `isReady` 存储 `dom` 树是否加载完毕\n\t\t\t* 判断 `isReady` 值， 如果为 `true` ，就直接执行传入的函数。\n\t\t\t* 否则，就给 `document` 的 `DOMContentLoaded` 事件绑定处理程序，在处理程序中，先将 `isReady` 赋值为 `true` ，在执行传入的函数。\n\n8. 如何判断字符串为 `html` 字符串，必须满足一下条件：\n\n\t* 以 `<` 开头\n\t* 以 `>` 结尾\n\t* 最小长度为 `3`\n\n9. 如何判断像数组（数组和伪数组）\n\n\t+ 用 `length` 属性去判断，若具有 `length` 属性 表示为 像数组类型\n\t+ 除了 `window` 对象以及函数对象\n\t+  `{length: 1} {4: \"123\", length: 5}` 稀疏数组\n\n\t+ 如果为真数组，返回 `true`\n\t+ 如果 `length` 属性值为 `0` （除了 `window` 对象以及函数对象），返回 `true`\n\t+ 如果 `length` 属性值 `>0`, 如果对象 具有 `length - 1` 索引，返回 `true`\n\n10. 全局对象 `window` 特性：有一个 `window` 属性 引用 自身。\n\n```js\n(function(global) {\n\tvar init,\n\t\tdocument = global.document;\n\n\tvar itcast = function(selector) {\n\t\treturn new itcast.fn.init(selector);\n\t};\n\n\titcast.fn = itcast.prototype = {\n\t\tconstructor: itcast,\n\t\tlength: 0\n\t};\n\tinit = itcast.fn.init = function(selector) {\n\t\t// handle: null undefined '' false\n\t\tif(!selector) return this;\n\t\t// handle: string\n\t\telse if(itcast.isString(selector)){\n\t\t\t// handle: html string '<p>123</p>'\n\t\t\tif(itcast.isHTML(selector)){\t\t\t\t\t\t\n\t\t\t\t// 怎么存储 以伪数组对象形式存储 dom元素\n\t\t\t\tArray.prototype.push.apply(this, itcast.parseHTML(selector));\n\t\t\t}\n\t\t\t// handle: selector\n\t\t\telse {\n\t\t\t\t// 根据选择器获取dom元素\n\t\t\t\tvar nodelist = document.querySelectorAll(selector);\n\t\t\t\t// 将结果伪数组对象 变成 真数组\n\t\t\t\tvar ret = Array.prototype.slice.call(nodelist);\n\t\t\t\t// 借调数组对象的slice方法将数组中的所有元素 以伪数组形式存储在this上\n\t\t\t\tArray.prototype.push.apply(this, ret);\n\t\t\t}\n\t\t}\n\t\t// handle: dom node\n\t\telse if(itcast.isDOM(selector)){\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t}\n\t\t// handle: dom array(伪数组对象)\n\t\telse if(itcast.isArrayLike(selector)){\n\t\t\t// 获取selector类型\n\t\t\tvar _type = Object.prototype.toString.call(selector).\n\t\t\t\t\tslice(8, -1).toLowerCase();\n\t\t\t// 如果不是数组类型,就 将其转换 为 真数组类型\n\t\t\tif(_type !== 'array') \n\t\t\t\tselector = Array.prototype.slice.call(selector);\n\t\t\tArray.prototype.push.apply(this, selector);\n\t\t}\t\n\t\t// handle: function\n\t\telse if(itcast.isFunction(selector)){\n\t\t\tif(itcast.isReady){\n\t\t\t\tselector();\n\t\t\t} else {\n\t\t\t\tdoucment.addEventListener('DOMContentLoaded', function() {\n\t\t\t\t\tselector();\n\t\t\t\t\titcast.isReady = true;\n\t\t\t\t});\t\n\t\t\t}\n\t\t}\n\t};\n\tinit.prototype = itcast.fn;\n\n\titcast.extend = itcast.fn.extend = function(source, target) {\n\t\tvar k;\n\n\t\ttarget = target || this;\n\n\t\tfor(k in source){\n\t\t\ttarget[k] = source[k];\n\t\t}\n\t};\n\n\t// 添加工具类方法\n\titcast.extend({\n\t\tisReady: false,\n\t\tpaseHTML: function(html) {\n\t\t\tvar div = document.createElement('div'),\n\t\t\t\tret = [];\n\t\t\tdiv.innerHTML = html;\n\n\t\t\tfor(var elem = div.firstChild; elem; elem = elem.nextSibling){\n\t\t\t\tif(elem.nodeType === 1) ret.push(elem);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t});\n\t// 类型判断方法\n\titcast.extend({\n\t\t// 判断是否为字符串类型\n\t\tisString: function(obj) {\n\t\t\t// 如果为null或undefined，返回false\n\t\t\t// 如果typeof值为string，返回true否则返回false。\n\t\t\treturn !!obj && typeof obj === 'string';\n\t\t},\n\t\tisHTML: function(obj) {\n\t\t\treturn !!obj && obj.charAt(0) === '<' && \n\t\t\t\tobj.charAt(obj.length - 1) === '>' &&\n\t\t\t\tobj.length >= 3;\n\t\t},\n\t\tisDOM: function(obj) {\n\t\t\treturn !!obj && !!obj.nodeType;\n\t\t},\n\t\tisFunction: function(obj) {\n\t\t\treturn !!obj && typeof obj === 'function';\n\t\t},\n\t\tisGlobal: function(obj) {\n\t\t\treturn !!obj && obj.window === obj;\n\t\t},\n\t\tisArrayLike: function(obj) {\n\t\t\tvar _type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(),\n\t\t\t\tlength = !!obj && 'length' in obj && obj.length;\n\t\t\t// 过滤 window对象和函数对象\n\t\t\tif(itcast.isFunction(obj) || itcast.isGlobal(obj)) return false;\n\t\t\treturn _type === 'array' || length === 0 || \n\t\t\t\ttypeof length === 'number' && length > 0 && (length - 1) in obj;\n\t\t}\n\t});\n\n\tglobal.$ = global.itcast = itcast;\n}(window));\n```\n\n到此,一个完整的 `init` 框架结构就好了!\n","slug":"javascript-jquery-part1","published":1,"updated":"2016-12-26T11:38:22.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw44000hcsg7g69g3rco"},{"title":"js高级与面向对象之构造函数","date":"2016-05-20T05:39:33.000Z","_content":"\n首先，什么是_声明_、_初始化_、_赋值_、_定义_?\n* 声明：告诉解析器有这个东西存在\n* 初始化：就理解为第一次赋值\n* 定义：不需要去理解\n* 赋值：改变变量的值，就是赋值\n\n<!-- more -->\n\n## 什么是构造函数？\n\n* 构造函数其实就是一个函数，只是用途跟普通函数不太一样\n* 构造函数一般用于初始化对象\n\n## 构造函数的特点\n\n* 首字母大写\n* 构造函数一般情况下和 `new` 关键字结合使用\n* 构造函数不需要写返回值\n\n构造函数的返回值默认为创建出来的对象，如果手动的去设置返回值\n\n* 设置返回值为基本类型，不会对默认返回值有任何的影响\n* 设置返回值为对象类型，就会替换掉默认的返回值\n\n## 构造函数的执行顺序\n\n* 使用 `new` 关键字创建对象\n* 调用构造函数，并且将构造函数内的 `this` 赋值为新创建的对象\n* 在构造函数内部，使用 `this` 为新创建出来的对象新增成员\n* 默认的返回新创建的这个对象\n\n返回值代码\n\n```js\nfunction Person(){\n    this.name = \"范冰冰\";\n    //初始化对象的代码\n\t//return \"范冰冰\";\n\t//return 123;\n\t//return true;\n\t//return null;\n    return {};\n}\nvar p = new Person();\nconsole.log(p);\n```\n自定义构造函数代码\n\n```js\n//自定义构造函数，就是自己创建的构造函数s\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.kanren = function(){\n        console.log(\"上课再闲聊，我就砍死你\");\n    }\n}\n\nvar p = new Person(\"大飞\", 50);\nconsole.log(p);\np.kanren();\n\nvar p1 = new Person(\"陈浩南\", 30);\nconsole.log(p1);\np1.kanren();\n```\n构造函数补充\n\n```js\n//因为构造函数也是函数\n//所以构造函数可以使用函数的使用方式\n//但是如果把构造函数当做普通函数来使用的话\n//该构造函数内的this就指向了window对象\n//返回值为undefined\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.kanren = function(){\n        console.log(\"上课再闲聊，我就砍死你\");\n    }\n}\n\nvar p = Person(\"谢文东\", 30);\nconsole.log(p);\nwindow.kanren();\n```\n\n## 传统构造函数存在的问题\n\n如果在构造函数内部声明函数，并为新创建的对象方法赋值的话每次创建对象，调用构造函数，都会新创建一个函数出来，每个对象独占一份函数 但是，所有的对象中的方法的代码是一模一样的，没有必要每人一份所以就造成了资源的浪费\n\n### 解决方案一\n\n将构造函数内部给对象的方法赋值的时候的函数声明提出来放到构造函外面，这样，在每次创建对象的时候，就不会再重新声明函数而是直接拿外面的函数地址进行赋值，所以，这样子创建出来的所有的对象都会共享构造函数外面的声明的这个函数\n\n### 解决方案一存在的问题\n\n1. 如果方法过多，会造成全局变量污染\n2. 代码结构会变得混乱不堪，不利于维护\n\n```js\n//解决方案一存在的问题\nfunction eat(){\n    console.log(\"吃个红烧鸡屁股\");\n}\n\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.eat = eat;\n//\t\tthis.eat = function (){\n//\t\tconsole.log(\"吃个红烧鸡屁股\");\n//     }\n}\n\nvar p = new Person(\"唐伯虎\",500);\np.eat();\nvar p1 = new Person(\"李二狗\",81);\np1.eat();\n\nconsole.log(p.eat == p1.eat);\n```\n\n这个问题我们可以通过原型来处理","source":"_posts/javascript-constructor.md","raw":"---\ntitle: js高级与面向对象之构造函数\ndate: 2016-05-20 13:39:33\ntags: \n\t- javascript\n\t- js构造函数\ncategories: javascript\n---\n\n首先，什么是_声明_、_初始化_、_赋值_、_定义_?\n* 声明：告诉解析器有这个东西存在\n* 初始化：就理解为第一次赋值\n* 定义：不需要去理解\n* 赋值：改变变量的值，就是赋值\n\n<!-- more -->\n\n## 什么是构造函数？\n\n* 构造函数其实就是一个函数，只是用途跟普通函数不太一样\n* 构造函数一般用于初始化对象\n\n## 构造函数的特点\n\n* 首字母大写\n* 构造函数一般情况下和 `new` 关键字结合使用\n* 构造函数不需要写返回值\n\n构造函数的返回值默认为创建出来的对象，如果手动的去设置返回值\n\n* 设置返回值为基本类型，不会对默认返回值有任何的影响\n* 设置返回值为对象类型，就会替换掉默认的返回值\n\n## 构造函数的执行顺序\n\n* 使用 `new` 关键字创建对象\n* 调用构造函数，并且将构造函数内的 `this` 赋值为新创建的对象\n* 在构造函数内部，使用 `this` 为新创建出来的对象新增成员\n* 默认的返回新创建的这个对象\n\n返回值代码\n\n```js\nfunction Person(){\n    this.name = \"范冰冰\";\n    //初始化对象的代码\n\t//return \"范冰冰\";\n\t//return 123;\n\t//return true;\n\t//return null;\n    return {};\n}\nvar p = new Person();\nconsole.log(p);\n```\n自定义构造函数代码\n\n```js\n//自定义构造函数，就是自己创建的构造函数s\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.kanren = function(){\n        console.log(\"上课再闲聊，我就砍死你\");\n    }\n}\n\nvar p = new Person(\"大飞\", 50);\nconsole.log(p);\np.kanren();\n\nvar p1 = new Person(\"陈浩南\", 30);\nconsole.log(p1);\np1.kanren();\n```\n构造函数补充\n\n```js\n//因为构造函数也是函数\n//所以构造函数可以使用函数的使用方式\n//但是如果把构造函数当做普通函数来使用的话\n//该构造函数内的this就指向了window对象\n//返回值为undefined\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.kanren = function(){\n        console.log(\"上课再闲聊，我就砍死你\");\n    }\n}\n\nvar p = Person(\"谢文东\", 30);\nconsole.log(p);\nwindow.kanren();\n```\n\n## 传统构造函数存在的问题\n\n如果在构造函数内部声明函数，并为新创建的对象方法赋值的话每次创建对象，调用构造函数，都会新创建一个函数出来，每个对象独占一份函数 但是，所有的对象中的方法的代码是一模一样的，没有必要每人一份所以就造成了资源的浪费\n\n### 解决方案一\n\n将构造函数内部给对象的方法赋值的时候的函数声明提出来放到构造函外面，这样，在每次创建对象的时候，就不会再重新声明函数而是直接拿外面的函数地址进行赋值，所以，这样子创建出来的所有的对象都会共享构造函数外面的声明的这个函数\n\n### 解决方案一存在的问题\n\n1. 如果方法过多，会造成全局变量污染\n2. 代码结构会变得混乱不堪，不利于维护\n\n```js\n//解决方案一存在的问题\nfunction eat(){\n    console.log(\"吃个红烧鸡屁股\");\n}\n\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.eat = eat;\n//\t\tthis.eat = function (){\n//\t\tconsole.log(\"吃个红烧鸡屁股\");\n//     }\n}\n\nvar p = new Person(\"唐伯虎\",500);\np.eat();\nvar p1 = new Person(\"李二狗\",81);\np1.eat();\n\nconsole.log(p.eat == p1.eat);\n```\n\n这个问题我们可以通过原型来处理","slug":"javascript-constructor","published":1,"updated":"2016-11-24T01:25:58.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw47000lcsg76d07a2jc"},{"title":"JQuery分析及实现part4之DOM操作模块功能及实现","date":"2016-11-21T11:08:10.000Z","_content":"\nJQuery模块分析及其实现第四部分属性部分功能及实现,接第三部分!\n\n<!-- more -->\n\n## appendTo 方法\n\n1. 功能:将结果集中的元素 追加到指定的 `dom` 元素上.\n2. 语法:`<target对象>.appendTo(target)`\n3. 实现思路\n\t* 定义 `appendTo` 方法,声明一个形参 `target` .追加到目标 `dom` 元素\n\t\t* 选择器\n\t\t* `dom` 元素\n\t\t* `dom` 数组\n\t* 为了操作方便,将 `target` 类型统一为 `itcast` 对象,去 `itcast` 函数走一圈,出来就是 `itcast` 对象.\n\t* 遍历 `this` 上的每一个 `dom` 元素,再遍历 `target` 上的每一个 `dom` 元素\n\t* 将 `this` 上的 `dom` 元素追加到 `target` 上\n\t* 注意:\n\t\t在追加节点时,如果遍历的是第一个目标 `dom` 元素,不需要拷贝节点;否则要深拷贝节点,并将上述得到的节点储存到 `ret` 内\n\t* 将 `ret` 数组转换成 `itcast` 对象,作为 `appendTo` 方法的返回值\n\t\t* 如果不这样做的话,就会在添加样式时,只有没拷贝的节点有样式\n\n```js\nappendTo: function(target) {\n\tvar node, \n\t\tret = [];\n\t// 统一target类型 为itcast对象（为了方便操作）\n\ttarget = itcast(target);\n\t// 遍历this上的每一个dom元素\n\tthis.each(function(v) {\n\t\t// 在遍历目标dom元素\n\t\ttarget.each(function(t, i) {\n\t\t\t// 如果当前dom元素为 目标上的第一个.不拷贝节点\n\t\t\t// 否则拷贝节点\n\t\t\tnode = i === 0 ? v : v.cloneNode(true);\n\t\t\t// 将被追加的节点,添加到ret内\n\t\t\tret.push(node);\n\t\t\t// 将节点追加到指定的目标dom元素上.\n\t\t\tt.appendChild(node);\n\t\t});\n\t});\n\t// 将每一个添加的dom元素,转换成itcast对象返回,实现链式编程\n\t// 原因:在添加样式时,如果不这样做的话,只会给没克隆的节点添加样式.\n\treturn itcast(ret);\n}\n```\n\n## append 方法\n\n1. 语法: `<itcast对象>.append(source)` ;\n2. 功能: 将 `source` 上的所有 `dom` 元素,追加到 `itcast` 对象上\n2. 实现思路\n\t* 统一 `source` 类型,为 `itcast` 对象.\n\t* `source.appendTo(this)`\n\t* `return this;`\n\n```js\nappend: function(source) {\n\t//统一source类型,为itcast对象\n\tsource = itcast(source);\n\tsource.appendTo(this);\n\treturn this;\n},\n```\n\n## prependTo 方法\n\n1. 语法: `<itcast对象>.prependTo(target);`\n2. 功能:将 `itcast` 对象上的每一个 `dom` 元素,追加到 `target` 最前边 `insertBefore`\n3. 实现思路\n\t* 统一 `target` 类型,为 `itcast` 对象\n\t* 定义 `node` 变量,临时存储被追加的结点.定义 `ret` 数组,存储所有被追加的节点\n\t* 先遍历 `target` 上的每一个 `dom` 元素\n\t* 定义变量 `firstChild` ,临时存储当前目标 `dom` 元素的第一个子节点,再遍历 `this` 上的每一个 `dom` 元素\n\t* 判断当前遍历的 `dom` 是否为 `target` 上的第一个 `dom` 元素\n\t* 如果为真,此时不需要克隆节点\n\t* 否则,要深克隆节点\n\t* 将上述的到的节点, `push` 到 `ret` 内\n\t* 调用 `insertBefore` 方法追加节点,此时第一个参数为追加新的节点,第二个参数为 `firstChild` ,在 `firstChild` 之前追加新节点.\n\t* 两层循环结束,操作完成\n\t* 将 `ret` 转换成 `itcast` 对象,作为 `prependTo` 方法的返回值,实现链式编程.\n\n```js\nprependTo: function(target) {\n\t//定义变量node,临时存储被追加的节点\n\tvar node,\n\t//定义变量firstChild,临时存储当前dom元素的第一个子节点\n\t\tfirstChild,\n\t\tself = this,\n\t\t//定义ret数组,存储所有被追加的节点\n\t\tret = [];\n   //统一类型为itcast对象\n\ttarget = itcast(target);\n\t//遍历target上的每一个dom元素\n\ttarget.each(function(elem, i) {\n\t\t// 缓存当前目标dom元素的第一个子节点\n\t\tfirstChild = elem.firstChild;\n\t\t//遍历this上的每一个dom元素\n\t\tself.each(function(dom) {\n\t\t\t//判断当前遍历的dom是否为target上的每一个dom元素\n\t\t\t//若为真,则不需要克隆节点,否则,要深克隆节点\n\t\t\t// 将得到的节点赋值给node\n\t\t\tnode = i === 0 ? dom : dom.cloneNode(true);\n\t\t\t//将节点push到ret内\n\t\t\tret.push(node);\n\t\t\t//调用insertBefore方法,追加节点(追加的新节点,firstChild)\n\t\t\telem.insertBefore(node, firstChild);\n\t\t});\n\t});\n    //将ret作为itcast对象,并且返回\n\treturn itcast(ret);\n}\n```\n\n## prepend 方法\n\n1. 语法: `<itcast对象>.prepend(source);`\n2. 功能:把 `source` 上的所有的 `dom` 元素,添加到 `this` 上的最前边\n3. 实现思路: \n\t* 统一 `source` 类型,为 `itcast` 对象\n\t* 通过 `source` 调用 `prependTo` 方法,将 `source` 上的所有 `dom` 添加到 `this` 上的最前边\n\t*  `return this` 实现链式编程\n\n```js\nprepend: function(source) {\n\tsource = itcast(source);\n\tsource.prependTo(this);\n\treturn this;\n}\n```\n\n## next 方法\n\n1. 功能:获取 `itcast` 对象上所有 `dom` 元素的下一个兄弟元素 `(nextSiling)`\n2. 语法: `<itcast对象>.next();` 返回值类型, `itcast` 对象\n3. 实现思路\n\t* 定义 `ret` 数组，存储所有 `dom` 的下一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素下面的所有兄弟，如果类型为 元素，将此元素存储 `ret` 内，结束循环。\n\t* 两层循环结束，将 `ret` 转换成 `itcast` 对象，作为 `next` 方法的返回值。\n\n```js\nnext: function() {\n\t// 存储所用dom的下一个兄弟元素\n\tvar ret = [];\n\t// 遍历this上的所有dom元素\n\tthis.each(function() {\n\t\t// 在遍历当前dom元素下面所有的兄弟元素\n\t\tfor(var node = this.nextSibling; node ; node = node.nextSibling){\n\t\t\t// 如果当前兄弟节点,为元素节点\n\t\t\t// 即为结果,将其添加ret内,并结束循环\n\t\t\tif(node.nodeType === 1){\n\t\t\t\tret.push(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\t// 将ret转换成itcast对象,返回\n\treturn itcast(ret);\n},\n```\n\n## nextAll  \n\n1. 功能:获取 `itcast` 对象上所有 `dom` 元素下面的所有兄弟元素 `(nextSiling)`\n2. 语法: `<itcast对象>.nextAll();` 返回值类型, `itcast` 对象\n3. 实现思路\n\t* 定义 `ret` 数组，存储所有 `dom` 的下一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素下面的所有兄弟，如果类型为 元素，将此元素存储 `ret` 内，结束循环。\n\t* 两层循环结束，将 `ret` 转换成 `itcast` 对象，作为 `nextAll` 方法的返回值。\n\n```js\nnextAll: function() {\n\tvar ret = [],\n\t\tnode;\n\tthis.each(function() {\n\t\tfor(node = this.nextSibling; node ; node = node.nextSibling){\n\t\t\tif(node.nodeType === 1) ret.push(node);\n\t\t}\n\t});\n\treturn itcast(itcast.unique(ret));\n}\n```\n\n## before 方法\n\n1. 功能:\n2. 语法: `<itcast对象>.before(source)`\n3. 实现思路\n\t* 统一 `source` 类型为 `itcast` 对象\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 再遍历 `source` 上的每一个 `dom` 元素\n\t* 判断当前遍历 `this`的 `dom` 元素的索引是否为0\n\t* 如果是 `0` ,不需要拷贝节点\n\t* 否则要深拷贝节点\n\t* 先拿到当前遍历 `this` 的 `dom` 元素的父节点,调用 `insertBefore` 方法在其前面添加上面的到的新节点\n\t* 两层循环完毕,操作完成\n\t*  `return this` 实现链式编程\n\n```js\nbefore: function(source) {\n\tvar node;\n\tsource = itcast(source);\n\tthis.each(function(dom, i) {\n\t\tsource.each(function(elem) {\n\t\t\tnode = i === 0 ? elem : elem.cloneNode(true);\n\t\t\t// 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node\n\t\t\tdom.parentNode.insertBefore(node, dom);\n\t\t});\n\t});\n\treturn this;\n},\n```\n\n## after 方法\n\n1. 功能:\n2. 语法: `<itcast对象>.after(source)`\n3. 实现思路\n\t* 定义 `nextSiling` 变量,存储 `dom` 元素的下一个兄弟节点\n\t* 统一 `source` 类型为 `itcast` 对象\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 再遍历`source` 上的每一个 `dom` 元素\n\t* 判断当前遍历 `this` 的 `dom` 元素的索引是否为 `0`\n\t* 如果是 `0` ,不需要拷贝节点\n\t* 否则要深拷贝节点\n\t* 先拿到当前遍历 `this` 的 `dom` 元素的父节点,调用 `insertBefore` 方法在其前面添加上面的到的新节点\n\t* 两层循环完毕,操作完成\n\t*  `return this` 实现链式编程\n\n```js\nafter: function(source) {\n\tvar node,\n\t\tnextSibling;\n\tsource = itcast(source);\n\tthis.each(function(dom, i) {\n\t\tnextSibling = dom.nextSibling;\n\t\tsource.each(function(elem) {\n\t\t\tnode = i === 0 ? elem : elem.cloneNode(true);\n\t\t\t// 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node\n\t\t\tdom.parentNode.insertBefore(node, nextSibling);\n\t\t});\n\t});\n\treturn this;\n}\n```\n\n## unique 方法\n\n1. 功能:实现数组元素去重\n2. 语法: `var newRet = itcast.unique(arr);`\n3. 实现思路\n\t* 定义空数组对象 `ret` .存储去重后的元素\n\t* 遍历原数组,如果当前遍历到的元素在 `ret` 中不存在,就添加 `ret` 内\n\t* 循环结束, `ret` 存储的就是去重后的元素\n\t* 返回 `ret`\n4. <a href=\"#code\">兼容IE8 indexof 方法</a>\n\t* 首先判断当前浏览器是否支持 `indexof` 方法\n\t* 如果不支持就给数组对象的原型添加 `indexof` 方法\n\t* 遍历 `this` 上的所有元素\n\t* 如果遍历到的当前元素和指定参数值相同就直接返回其索引值.结束循环\n\t* 如果在整个上述循环都没有返回值,那么表示不存在指定参数值就返回 `-1` .\n\n```js\nunique: function(arr) {\n\t// 存储去重后的结果\n\tvar ret = [];\n\t// 遍历原数组arr\n\titcast.each(arr, function() {\n\t\t// 判断ret是否存在当前遍历到的元素\n\t\t// 如果不存在将其添加到ret中\n\t\tif(ret.indexOf(this) === -1) ret.push(this);\n\t});\n\t// 将ret返回\n\treturn ret;\n}\n```\n\n<p id=\"code\">兼容 `IE8` `indexof` 方法</p>\n\n```js\n// 兼容数组对象的indexOf方法\n(function() {\n\t// 如果浏览器不支持indexOf方法\n\t// 那么就给数组对象的原型添加indexOf方法\n\tif(!Array.prototype.indexOf){\n\t\tArray.prototype.indexOf = function(val) {\n\t\t\t// 遍历this\n\t\t\tfor(var i = 0,l = this.length; i < l; i++){\n\t\t\t\t// 如果遍历到的当前元素和val相同，返回其索引值\n\t\t\t\tif(this[i] == val) return i;\n\t\t\t}\n\t\t\t// 那么表示不存在指定参数值就返回 -1 \n\t\t\treturn -1;\n\t\t};\n\t}\n}());\n```\n\n## prev 方法\n\n1. 功能: 获取 `itcast` 对象上所有 `dom` 元素的前一个兄弟元素 `(previousSibling)`\n2. 语法: `<itcast对象>.prev();` 返回值类型: `itcast对象`\n3. 实现思路\n\t* 定义 `ret` 数组,存储所有 `dom` 的前一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素之前的所有兄弟,如果类型为元素,将此元素存储 `ret` 内,结束循环\n\t* 两层循环结束,将 `ret` 转换成 `itcast` 对象,作为 `next` 方法的返回值\n\n```js\nprev:function(){\n\t//存储所有dom的前一个兄弟元素\n\tvar ret=[];\n\t//遍历this上的所有dom元素\n\tthis.each(function(){\n\t\t//在遍历当前dom元素之前所有的兄弟元素\n\t\tfor(var node=this.previousSibling;node;node=node.previousSibling){\n\t\t\t//如果当前兄弟节点为元素节点\n\t\t\t//即为结果,将其添加到ret内,并结束循环\n\t\t\tif(node.nodeType===1){\n\t\t\t\tret.push(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\t//将ret转换成itcast对象,返回\n\treturn itcast(ret);\n},\n```\n\n## prevAll 方法\n\n1. 功能: 获取 `itcast` 对象上所有 `dom` 元素的之前的所有兄弟元素 `(nextSibling)`\n2. 语法: `<itcast对象>.nextAll();` 返回值类型: `itcast对象`\n3. 实现思路\n\t* 定义 `ret数组` ,存储所有 `dom` 之前的所有兄弟元素\n\t* 遍历 `this` 上的所有 `dom元素`\n\t* 遍历当前 `dom` 元素之前的所有兄弟,如果类型为元素,将此元素存储 `ret` 内,结束循环\n\t* 两层循环结束,将 `ret` 转换成 `itcast对象` ,作为 `nextAll` 方法的返回值\n\n```js\nprevAll:function(){\n\tvar ret=[];\n\tthis.each(function() {\n\t\tfor(var node=this.previousSibling;node;node=node.previousSibling){\n\t\t\tif(node.nodeType===1) ret.push(node);\n\t\t}\n\t\t\n\t});\n\treturn itcast(itcast.unique(ret));\n}\n```","source":"_posts/javascript-jquery-part4.md","raw":"---\ntitle: JQuery分析及实现part4之DOM操作模块功能及实现\ndate: 2016-11-21 19:08:10\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第四部分属性部分功能及实现,接第三部分!\n\n<!-- more -->\n\n## appendTo 方法\n\n1. 功能:将结果集中的元素 追加到指定的 `dom` 元素上.\n2. 语法:`<target对象>.appendTo(target)`\n3. 实现思路\n\t* 定义 `appendTo` 方法,声明一个形参 `target` .追加到目标 `dom` 元素\n\t\t* 选择器\n\t\t* `dom` 元素\n\t\t* `dom` 数组\n\t* 为了操作方便,将 `target` 类型统一为 `itcast` 对象,去 `itcast` 函数走一圈,出来就是 `itcast` 对象.\n\t* 遍历 `this` 上的每一个 `dom` 元素,再遍历 `target` 上的每一个 `dom` 元素\n\t* 将 `this` 上的 `dom` 元素追加到 `target` 上\n\t* 注意:\n\t\t在追加节点时,如果遍历的是第一个目标 `dom` 元素,不需要拷贝节点;否则要深拷贝节点,并将上述得到的节点储存到 `ret` 内\n\t* 将 `ret` 数组转换成 `itcast` 对象,作为 `appendTo` 方法的返回值\n\t\t* 如果不这样做的话,就会在添加样式时,只有没拷贝的节点有样式\n\n```js\nappendTo: function(target) {\n\tvar node, \n\t\tret = [];\n\t// 统一target类型 为itcast对象（为了方便操作）\n\ttarget = itcast(target);\n\t// 遍历this上的每一个dom元素\n\tthis.each(function(v) {\n\t\t// 在遍历目标dom元素\n\t\ttarget.each(function(t, i) {\n\t\t\t// 如果当前dom元素为 目标上的第一个.不拷贝节点\n\t\t\t// 否则拷贝节点\n\t\t\tnode = i === 0 ? v : v.cloneNode(true);\n\t\t\t// 将被追加的节点,添加到ret内\n\t\t\tret.push(node);\n\t\t\t// 将节点追加到指定的目标dom元素上.\n\t\t\tt.appendChild(node);\n\t\t});\n\t});\n\t// 将每一个添加的dom元素,转换成itcast对象返回,实现链式编程\n\t// 原因:在添加样式时,如果不这样做的话,只会给没克隆的节点添加样式.\n\treturn itcast(ret);\n}\n```\n\n## append 方法\n\n1. 语法: `<itcast对象>.append(source)` ;\n2. 功能: 将 `source` 上的所有 `dom` 元素,追加到 `itcast` 对象上\n2. 实现思路\n\t* 统一 `source` 类型,为 `itcast` 对象.\n\t* `source.appendTo(this)`\n\t* `return this;`\n\n```js\nappend: function(source) {\n\t//统一source类型,为itcast对象\n\tsource = itcast(source);\n\tsource.appendTo(this);\n\treturn this;\n},\n```\n\n## prependTo 方法\n\n1. 语法: `<itcast对象>.prependTo(target);`\n2. 功能:将 `itcast` 对象上的每一个 `dom` 元素,追加到 `target` 最前边 `insertBefore`\n3. 实现思路\n\t* 统一 `target` 类型,为 `itcast` 对象\n\t* 定义 `node` 变量,临时存储被追加的结点.定义 `ret` 数组,存储所有被追加的节点\n\t* 先遍历 `target` 上的每一个 `dom` 元素\n\t* 定义变量 `firstChild` ,临时存储当前目标 `dom` 元素的第一个子节点,再遍历 `this` 上的每一个 `dom` 元素\n\t* 判断当前遍历的 `dom` 是否为 `target` 上的第一个 `dom` 元素\n\t* 如果为真,此时不需要克隆节点\n\t* 否则,要深克隆节点\n\t* 将上述的到的节点, `push` 到 `ret` 内\n\t* 调用 `insertBefore` 方法追加节点,此时第一个参数为追加新的节点,第二个参数为 `firstChild` ,在 `firstChild` 之前追加新节点.\n\t* 两层循环结束,操作完成\n\t* 将 `ret` 转换成 `itcast` 对象,作为 `prependTo` 方法的返回值,实现链式编程.\n\n```js\nprependTo: function(target) {\n\t//定义变量node,临时存储被追加的节点\n\tvar node,\n\t//定义变量firstChild,临时存储当前dom元素的第一个子节点\n\t\tfirstChild,\n\t\tself = this,\n\t\t//定义ret数组,存储所有被追加的节点\n\t\tret = [];\n   //统一类型为itcast对象\n\ttarget = itcast(target);\n\t//遍历target上的每一个dom元素\n\ttarget.each(function(elem, i) {\n\t\t// 缓存当前目标dom元素的第一个子节点\n\t\tfirstChild = elem.firstChild;\n\t\t//遍历this上的每一个dom元素\n\t\tself.each(function(dom) {\n\t\t\t//判断当前遍历的dom是否为target上的每一个dom元素\n\t\t\t//若为真,则不需要克隆节点,否则,要深克隆节点\n\t\t\t// 将得到的节点赋值给node\n\t\t\tnode = i === 0 ? dom : dom.cloneNode(true);\n\t\t\t//将节点push到ret内\n\t\t\tret.push(node);\n\t\t\t//调用insertBefore方法,追加节点(追加的新节点,firstChild)\n\t\t\telem.insertBefore(node, firstChild);\n\t\t});\n\t});\n    //将ret作为itcast对象,并且返回\n\treturn itcast(ret);\n}\n```\n\n## prepend 方法\n\n1. 语法: `<itcast对象>.prepend(source);`\n2. 功能:把 `source` 上的所有的 `dom` 元素,添加到 `this` 上的最前边\n3. 实现思路: \n\t* 统一 `source` 类型,为 `itcast` 对象\n\t* 通过 `source` 调用 `prependTo` 方法,将 `source` 上的所有 `dom` 添加到 `this` 上的最前边\n\t*  `return this` 实现链式编程\n\n```js\nprepend: function(source) {\n\tsource = itcast(source);\n\tsource.prependTo(this);\n\treturn this;\n}\n```\n\n## next 方法\n\n1. 功能:获取 `itcast` 对象上所有 `dom` 元素的下一个兄弟元素 `(nextSiling)`\n2. 语法: `<itcast对象>.next();` 返回值类型, `itcast` 对象\n3. 实现思路\n\t* 定义 `ret` 数组，存储所有 `dom` 的下一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素下面的所有兄弟，如果类型为 元素，将此元素存储 `ret` 内，结束循环。\n\t* 两层循环结束，将 `ret` 转换成 `itcast` 对象，作为 `next` 方法的返回值。\n\n```js\nnext: function() {\n\t// 存储所用dom的下一个兄弟元素\n\tvar ret = [];\n\t// 遍历this上的所有dom元素\n\tthis.each(function() {\n\t\t// 在遍历当前dom元素下面所有的兄弟元素\n\t\tfor(var node = this.nextSibling; node ; node = node.nextSibling){\n\t\t\t// 如果当前兄弟节点,为元素节点\n\t\t\t// 即为结果,将其添加ret内,并结束循环\n\t\t\tif(node.nodeType === 1){\n\t\t\t\tret.push(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\t// 将ret转换成itcast对象,返回\n\treturn itcast(ret);\n},\n```\n\n## nextAll  \n\n1. 功能:获取 `itcast` 对象上所有 `dom` 元素下面的所有兄弟元素 `(nextSiling)`\n2. 语法: `<itcast对象>.nextAll();` 返回值类型, `itcast` 对象\n3. 实现思路\n\t* 定义 `ret` 数组，存储所有 `dom` 的下一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素下面的所有兄弟，如果类型为 元素，将此元素存储 `ret` 内，结束循环。\n\t* 两层循环结束，将 `ret` 转换成 `itcast` 对象，作为 `nextAll` 方法的返回值。\n\n```js\nnextAll: function() {\n\tvar ret = [],\n\t\tnode;\n\tthis.each(function() {\n\t\tfor(node = this.nextSibling; node ; node = node.nextSibling){\n\t\t\tif(node.nodeType === 1) ret.push(node);\n\t\t}\n\t});\n\treturn itcast(itcast.unique(ret));\n}\n```\n\n## before 方法\n\n1. 功能:\n2. 语法: `<itcast对象>.before(source)`\n3. 实现思路\n\t* 统一 `source` 类型为 `itcast` 对象\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 再遍历 `source` 上的每一个 `dom` 元素\n\t* 判断当前遍历 `this`的 `dom` 元素的索引是否为0\n\t* 如果是 `0` ,不需要拷贝节点\n\t* 否则要深拷贝节点\n\t* 先拿到当前遍历 `this` 的 `dom` 元素的父节点,调用 `insertBefore` 方法在其前面添加上面的到的新节点\n\t* 两层循环完毕,操作完成\n\t*  `return this` 实现链式编程\n\n```js\nbefore: function(source) {\n\tvar node;\n\tsource = itcast(source);\n\tthis.each(function(dom, i) {\n\t\tsource.each(function(elem) {\n\t\t\tnode = i === 0 ? elem : elem.cloneNode(true);\n\t\t\t// 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node\n\t\t\tdom.parentNode.insertBefore(node, dom);\n\t\t});\n\t});\n\treturn this;\n},\n```\n\n## after 方法\n\n1. 功能:\n2. 语法: `<itcast对象>.after(source)`\n3. 实现思路\n\t* 定义 `nextSiling` 变量,存储 `dom` 元素的下一个兄弟节点\n\t* 统一 `source` 类型为 `itcast` 对象\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 再遍历`source` 上的每一个 `dom` 元素\n\t* 判断当前遍历 `this` 的 `dom` 元素的索引是否为 `0`\n\t* 如果是 `0` ,不需要拷贝节点\n\t* 否则要深拷贝节点\n\t* 先拿到当前遍历 `this` 的 `dom` 元素的父节点,调用 `insertBefore` 方法在其前面添加上面的到的新节点\n\t* 两层循环完毕,操作完成\n\t*  `return this` 实现链式编程\n\n```js\nafter: function(source) {\n\tvar node,\n\t\tnextSibling;\n\tsource = itcast(source);\n\tthis.each(function(dom, i) {\n\t\tnextSibling = dom.nextSibling;\n\t\tsource.each(function(elem) {\n\t\t\tnode = i === 0 ? elem : elem.cloneNode(true);\n\t\t\t// 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node\n\t\t\tdom.parentNode.insertBefore(node, nextSibling);\n\t\t});\n\t});\n\treturn this;\n}\n```\n\n## unique 方法\n\n1. 功能:实现数组元素去重\n2. 语法: `var newRet = itcast.unique(arr);`\n3. 实现思路\n\t* 定义空数组对象 `ret` .存储去重后的元素\n\t* 遍历原数组,如果当前遍历到的元素在 `ret` 中不存在,就添加 `ret` 内\n\t* 循环结束, `ret` 存储的就是去重后的元素\n\t* 返回 `ret`\n4. <a href=\"#code\">兼容IE8 indexof 方法</a>\n\t* 首先判断当前浏览器是否支持 `indexof` 方法\n\t* 如果不支持就给数组对象的原型添加 `indexof` 方法\n\t* 遍历 `this` 上的所有元素\n\t* 如果遍历到的当前元素和指定参数值相同就直接返回其索引值.结束循环\n\t* 如果在整个上述循环都没有返回值,那么表示不存在指定参数值就返回 `-1` .\n\n```js\nunique: function(arr) {\n\t// 存储去重后的结果\n\tvar ret = [];\n\t// 遍历原数组arr\n\titcast.each(arr, function() {\n\t\t// 判断ret是否存在当前遍历到的元素\n\t\t// 如果不存在将其添加到ret中\n\t\tif(ret.indexOf(this) === -1) ret.push(this);\n\t});\n\t// 将ret返回\n\treturn ret;\n}\n```\n\n<p id=\"code\">兼容 `IE8` `indexof` 方法</p>\n\n```js\n// 兼容数组对象的indexOf方法\n(function() {\n\t// 如果浏览器不支持indexOf方法\n\t// 那么就给数组对象的原型添加indexOf方法\n\tif(!Array.prototype.indexOf){\n\t\tArray.prototype.indexOf = function(val) {\n\t\t\t// 遍历this\n\t\t\tfor(var i = 0,l = this.length; i < l; i++){\n\t\t\t\t// 如果遍历到的当前元素和val相同，返回其索引值\n\t\t\t\tif(this[i] == val) return i;\n\t\t\t}\n\t\t\t// 那么表示不存在指定参数值就返回 -1 \n\t\t\treturn -1;\n\t\t};\n\t}\n}());\n```\n\n## prev 方法\n\n1. 功能: 获取 `itcast` 对象上所有 `dom` 元素的前一个兄弟元素 `(previousSibling)`\n2. 语法: `<itcast对象>.prev();` 返回值类型: `itcast对象`\n3. 实现思路\n\t* 定义 `ret` 数组,存储所有 `dom` 的前一个兄弟元素\n\t* 遍历 `this` 上的所有 `dom` 元素\n\t* 遍历当前 `dom` 元素之前的所有兄弟,如果类型为元素,将此元素存储 `ret` 内,结束循环\n\t* 两层循环结束,将 `ret` 转换成 `itcast` 对象,作为 `next` 方法的返回值\n\n```js\nprev:function(){\n\t//存储所有dom的前一个兄弟元素\n\tvar ret=[];\n\t//遍历this上的所有dom元素\n\tthis.each(function(){\n\t\t//在遍历当前dom元素之前所有的兄弟元素\n\t\tfor(var node=this.previousSibling;node;node=node.previousSibling){\n\t\t\t//如果当前兄弟节点为元素节点\n\t\t\t//即为结果,将其添加到ret内,并结束循环\n\t\t\tif(node.nodeType===1){\n\t\t\t\tret.push(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\t//将ret转换成itcast对象,返回\n\treturn itcast(ret);\n},\n```\n\n## prevAll 方法\n\n1. 功能: 获取 `itcast` 对象上所有 `dom` 元素的之前的所有兄弟元素 `(nextSibling)`\n2. 语法: `<itcast对象>.nextAll();` 返回值类型: `itcast对象`\n3. 实现思路\n\t* 定义 `ret数组` ,存储所有 `dom` 之前的所有兄弟元素\n\t* 遍历 `this` 上的所有 `dom元素`\n\t* 遍历当前 `dom` 元素之前的所有兄弟,如果类型为元素,将此元素存储 `ret` 内,结束循环\n\t* 两层循环结束,将 `ret` 转换成 `itcast对象` ,作为 `nextAll` 方法的返回值\n\n```js\nprevAll:function(){\n\tvar ret=[];\n\tthis.each(function() {\n\t\tfor(var node=this.previousSibling;node;node=node.previousSibling){\n\t\t\tif(node.nodeType===1) ret.push(node);\n\t\t}\n\t\t\n\t});\n\treturn itcast(itcast.unique(ret));\n}\n```","slug":"javascript-jquery-part4","published":1,"updated":"2016-11-24T01:37:29.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw49000mcsg76guvtztr"},{"title":"JQuery分析及实现part3之属性模块功能及实现","date":"2016-11-20T03:51:28.000Z","_content":"\nJQuery模块分析及其实现第三部分属性模块功能及实现,接第二部分!\n\n<!-- more -->\n\n## 知识点复习\n\n1.  `css` 方法\n\t* 如果只传入一个参数\n\t\t* 如果参数类型为对象,表示同时设置多个样式\n\t\t* 如果参数类型为字符串,表示获取指定的样式值\n\t* 如果传入的两个参数,表示设置单个样式值\n\n2.  `itcast.each` 方法: 遍历数组或伪数组\n\t* 第一个参数,指定遍历的对象\n\t* 第二个参数,指定的回调函数,对遍历到的每一个元素,进行相关处理\n\n## attr方法( setAttribute 和 getAttribute )\n\n1. 功能: 获取(设置)属性节点值\n2. 实现思路\n\t* 给原型添加 `attr` 方法,定义两个参数:属性节点名字 `name` 以及属性节点值\n\t* 如果只传入一个参数\n\t\t* 如果参数类型为对象,表示设置多个节点值\n\t\t* 否则获取指定的属性节点值(默认获取第一个 `dom` 元素的属性节点值)\n\t* 如果传入两个参数,表示设置单个属性节点值.\n\n```js\nattr: function(name,value){\n\t//只传入一个参数\n\tif(value == undefined){\n\t\t//如果类型为对象,表示设置多个属性\n\t\tif(typeof name ==='object'){\n\t\t\t//遍历itcast上的每一个dom元素,并设置属性节点值\n\t\t\tthis.each(function(v){\n\t\t\t\t//枚举name对象上的每一个属性\n\t\t\t\tfor(var k in name){\n\t\t\t\t\tv.setAttribute(k, name[k]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else { //如果类型为字符串,获取属性节点值\n\t\t\tif(!this[0]) return null;\n\t\t\treturn this[0].getAttribute(name);\n\t\t}\n\t}else { //传入两个参数,表示设置单个属性节点值\n\t\tthis.each(function(v) {\n\t\t\tv.setAttribute(name, value)\n\t\t});\n\t}\n\treturn this\n},\n```\n\n## html方法\n\n1. 功能: \n\t* 不传参数,表示获取指定 `dom` 元素的 `innerHTML` 属性值\n\t* 否则,表示设置指定 `dom` 元素的 `innerHTML` 属性\n2. 实行思路\n\t* 判断是否传入参数\n\t* 如果没穿,获取 `itcast` 对象上的第一个 `dom` 元素的 `innerHTML` 属性值\n\t* 否则,给 `itcast` 对象上的每一个 `dom` 元素设置 `innerHTML` 属性\n\n```js\nhtml: function(html) {\n\t//如果没有给html传值,表示获取\n\tif(html==undefined){\n\t\t//如果icast没有任何dom元素,就返回一个期望值,即空字符串\n\t\t//如果有的话,就返回一个dom元素的innerHTML属性值\n\t\treturn this[0] ? this[0].innerHTML : '';\n\t}else{//如果给html船只,给itcast对象上的每一个dom元素设置innerHTML属性\n\t\treturn this.each(function(v){\n\t\t\tv.innerHTML = html;\n\t\t});\n\t}\n},\n```\n\n## text方法\n\n1. 功能\n\t* 不传值,表示获取文本节点(返回的是后代中所有文本节点值)\n\t* 传值,设置指定 `dom` 元素文本值\n2. 实现思路\n\t* 如果不传值,优先考虑浏览器是否支持 `textContent` 属性\n\t\t* 如果支持,就使用 `textContent` 返回结果集中每一个 `dom` 元素的文本节点值\n\t\t* 否则,就是用 `innerText` 返回结果集中每一个 `dom` 元素的文本节点值\n\t* 如果传值,给 `itcast` 对象上的每一个 `dom` 元素设置文本节点值.\n\t\t* 如果支持 `textContent` 属性,就是用该属性设置文本\n\t\t* 否则,就是用 `innerText` 来设置文本.\n\n```js\ntext: function(text) {\n\t// 如果没有传值，表示获取文本值\n\tif(text == undefined){\n\t\t// 定义结果变量，存储每个dom元素的文本\n\t\tvar ret = '';\n\t\t// 遍历每一个dom元素\n\t\tthis.each(function(v) {\n\t\t\t// 如果支持textContent，使用其获取文本，累加到ret上\n\t\t\tret += 'textContent' in document ?\n\t\t\t\tv.textContent :\n\t\t\t\tv.innerText.replace(/\\r\\n/g, '');\n\t\t});\n\t\t// 返回所有文本\n\t\treturn ret;\n\t} else { // 如果传值了，表示为每个dom设置文本\n\t\treturn this.each(function(v) {\n\t\t\t// 如果支持textContent，就使用该属性为当前dom元素设置文本节点值\n\t\t\t// 否则，使用innerText设置文本节点值。\n\t\t\tif('textContent' in document){\n\t\t\t\tv.textContent = text;\n\t\t\t} else {\n\t\t\t\tv.innerText = text;\n\t\t\t}\n\t\t});\n\t}\n},\n```\n\n## val方法\n\n1. 功能( `value` 属性)\n\t* 如果不传值,表示获取输入框的文本值\n\t* 如果传值, 表示给输入框 设置文本\n2. 实现思路\n\t* 如果不传值，表示获取输入框的文本值（获取第一个文本框值）\n\t* 如果传值，表示给输入框 设置文本\n\t\t* 遍历每一个输入框，同时给其设置文本\n```js\nval: function(value) {\n\t// 如果没有传值，表示获取第一个dom元素的value属性值\n\t// 如果itcast对象上没有任何dom元素，返回空字符串\n\tif(value == undefined){\n\t\treturn this[0] ? this[0].value : '';\n\t} else {// 否则，为每一个dom元素设置value属性值\n\t\treturn this.each(function() {\n\t\t\tthis.value = value;\n\t\t});\n\t}\n}\n```\n\n## prop方法\n\n1. 功能:和 `attr` 相似\n\t* 注意: 有些属性名称,比如 `for` , `class` 是保留字或关键字不能作为对象属性名称,所以要创建一个对象,需要转换这类的属性\n\t* 定义 `propFix` 对象,存储上述属性到这属性名称的映射关系\n\t* 如果只传入一个参数\n\t\t* 类型为对象,同时给  `dom` 对象添加属性\n\t\t* 类型为字符串,获取 `itcast` 对象上的第一个 `dom` 对象的指定属性值\n\t* 如果传入的参数,给所有的 `dom` 对象添加单个属性\n\t* 细节: 无论是设置还是获取属性,在操作之前,先要从 `propFix` 对象拿到映射后的属性名称\n\t\t* 如果拿到的心的属性名称不为 `undefined` ,就用映射后的属性名来操作 `dom` 对象\n\t\t* 否则,那么久使用旧的属性名称来操作 `dom` 对象.\n\n```js\n// 属性模块\nitcast.propFix = {\n\t'for': 'htmlFor',\n\t'class': 'className'\n};\nitcast.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\titcast.propFix[this.toLowerCase()] = this;\n});\nprop: function(name, value) {\n\t// 如果没有给value传值\n\tvar prop;\n\tif (value == undefined) {\n\t\t// 并且name的类型为 对象，表示给每一个dom对象添加多个属性\n\t\tif (typeof name === 'object') {\n\t\t\tthis.each(function() {\n\t\t\t\tfor (var k in name) {\n\t\t\t\t\t// 首先从propFix对象上获取属性名字\n\t\t\t\t\t// 如果有，就使用新的属性名字\n\t\t\t\t\t// 如果没有，就使用原来的属性名字\n\t\t\t\t\tprop = itcast.propFix[k] ? itcast.propFix[k] : k;\n\t\t\t\t\tthis[prop] = name[k];\n\t\t\t\t}\n\t\t\t});\n\t\t} else { // 如果name的类型 为字符串，表示获取第一个dom对象的指定属性值\n\t\t\tprop = itcast.propFix[name] ? itcast.propFix[name]: name;\n\t\t\treturn this.length > 0 ? this[0][prop] : null;\n\t\t}\n\t} else { // 如果传入两个参数，表示给每一个dom对象添加单个属性\n\t\t// 遍历itcast上的每一个dom对象，添加属性\n\t\tprop = itcast.propFix[name] ? itcast.propFix[name]: name;\n\t\tthis.each(function() {\n\t\t\tthis[prop] = value;\n\t\t});\n\t}\n\t// 实现链式编程\n\treturn this;\n}\n```","source":"_posts/javascript-jquery-part3.md","raw":"---\ntitle: JQuery分析及实现part3之属性模块功能及实现\ndate: 2016-11-20 11:51:28\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第三部分属性模块功能及实现,接第二部分!\n\n<!-- more -->\n\n## 知识点复习\n\n1.  `css` 方法\n\t* 如果只传入一个参数\n\t\t* 如果参数类型为对象,表示同时设置多个样式\n\t\t* 如果参数类型为字符串,表示获取指定的样式值\n\t* 如果传入的两个参数,表示设置单个样式值\n\n2.  `itcast.each` 方法: 遍历数组或伪数组\n\t* 第一个参数,指定遍历的对象\n\t* 第二个参数,指定的回调函数,对遍历到的每一个元素,进行相关处理\n\n## attr方法( setAttribute 和 getAttribute )\n\n1. 功能: 获取(设置)属性节点值\n2. 实现思路\n\t* 给原型添加 `attr` 方法,定义两个参数:属性节点名字 `name` 以及属性节点值\n\t* 如果只传入一个参数\n\t\t* 如果参数类型为对象,表示设置多个节点值\n\t\t* 否则获取指定的属性节点值(默认获取第一个 `dom` 元素的属性节点值)\n\t* 如果传入两个参数,表示设置单个属性节点值.\n\n```js\nattr: function(name,value){\n\t//只传入一个参数\n\tif(value == undefined){\n\t\t//如果类型为对象,表示设置多个属性\n\t\tif(typeof name ==='object'){\n\t\t\t//遍历itcast上的每一个dom元素,并设置属性节点值\n\t\t\tthis.each(function(v){\n\t\t\t\t//枚举name对象上的每一个属性\n\t\t\t\tfor(var k in name){\n\t\t\t\t\tv.setAttribute(k, name[k]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else { //如果类型为字符串,获取属性节点值\n\t\t\tif(!this[0]) return null;\n\t\t\treturn this[0].getAttribute(name);\n\t\t}\n\t}else { //传入两个参数,表示设置单个属性节点值\n\t\tthis.each(function(v) {\n\t\t\tv.setAttribute(name, value)\n\t\t});\n\t}\n\treturn this\n},\n```\n\n## html方法\n\n1. 功能: \n\t* 不传参数,表示获取指定 `dom` 元素的 `innerHTML` 属性值\n\t* 否则,表示设置指定 `dom` 元素的 `innerHTML` 属性\n2. 实行思路\n\t* 判断是否传入参数\n\t* 如果没穿,获取 `itcast` 对象上的第一个 `dom` 元素的 `innerHTML` 属性值\n\t* 否则,给 `itcast` 对象上的每一个 `dom` 元素设置 `innerHTML` 属性\n\n```js\nhtml: function(html) {\n\t//如果没有给html传值,表示获取\n\tif(html==undefined){\n\t\t//如果icast没有任何dom元素,就返回一个期望值,即空字符串\n\t\t//如果有的话,就返回一个dom元素的innerHTML属性值\n\t\treturn this[0] ? this[0].innerHTML : '';\n\t}else{//如果给html船只,给itcast对象上的每一个dom元素设置innerHTML属性\n\t\treturn this.each(function(v){\n\t\t\tv.innerHTML = html;\n\t\t});\n\t}\n},\n```\n\n## text方法\n\n1. 功能\n\t* 不传值,表示获取文本节点(返回的是后代中所有文本节点值)\n\t* 传值,设置指定 `dom` 元素文本值\n2. 实现思路\n\t* 如果不传值,优先考虑浏览器是否支持 `textContent` 属性\n\t\t* 如果支持,就使用 `textContent` 返回结果集中每一个 `dom` 元素的文本节点值\n\t\t* 否则,就是用 `innerText` 返回结果集中每一个 `dom` 元素的文本节点值\n\t* 如果传值,给 `itcast` 对象上的每一个 `dom` 元素设置文本节点值.\n\t\t* 如果支持 `textContent` 属性,就是用该属性设置文本\n\t\t* 否则,就是用 `innerText` 来设置文本.\n\n```js\ntext: function(text) {\n\t// 如果没有传值，表示获取文本值\n\tif(text == undefined){\n\t\t// 定义结果变量，存储每个dom元素的文本\n\t\tvar ret = '';\n\t\t// 遍历每一个dom元素\n\t\tthis.each(function(v) {\n\t\t\t// 如果支持textContent，使用其获取文本，累加到ret上\n\t\t\tret += 'textContent' in document ?\n\t\t\t\tv.textContent :\n\t\t\t\tv.innerText.replace(/\\r\\n/g, '');\n\t\t});\n\t\t// 返回所有文本\n\t\treturn ret;\n\t} else { // 如果传值了，表示为每个dom设置文本\n\t\treturn this.each(function(v) {\n\t\t\t// 如果支持textContent，就使用该属性为当前dom元素设置文本节点值\n\t\t\t// 否则，使用innerText设置文本节点值。\n\t\t\tif('textContent' in document){\n\t\t\t\tv.textContent = text;\n\t\t\t} else {\n\t\t\t\tv.innerText = text;\n\t\t\t}\n\t\t});\n\t}\n},\n```\n\n## val方法\n\n1. 功能( `value` 属性)\n\t* 如果不传值,表示获取输入框的文本值\n\t* 如果传值, 表示给输入框 设置文本\n2. 实现思路\n\t* 如果不传值，表示获取输入框的文本值（获取第一个文本框值）\n\t* 如果传值，表示给输入框 设置文本\n\t\t* 遍历每一个输入框，同时给其设置文本\n```js\nval: function(value) {\n\t// 如果没有传值，表示获取第一个dom元素的value属性值\n\t// 如果itcast对象上没有任何dom元素，返回空字符串\n\tif(value == undefined){\n\t\treturn this[0] ? this[0].value : '';\n\t} else {// 否则，为每一个dom元素设置value属性值\n\t\treturn this.each(function() {\n\t\t\tthis.value = value;\n\t\t});\n\t}\n}\n```\n\n## prop方法\n\n1. 功能:和 `attr` 相似\n\t* 注意: 有些属性名称,比如 `for` , `class` 是保留字或关键字不能作为对象属性名称,所以要创建一个对象,需要转换这类的属性\n\t* 定义 `propFix` 对象,存储上述属性到这属性名称的映射关系\n\t* 如果只传入一个参数\n\t\t* 类型为对象,同时给  `dom` 对象添加属性\n\t\t* 类型为字符串,获取 `itcast` 对象上的第一个 `dom` 对象的指定属性值\n\t* 如果传入的参数,给所有的 `dom` 对象添加单个属性\n\t* 细节: 无论是设置还是获取属性,在操作之前,先要从 `propFix` 对象拿到映射后的属性名称\n\t\t* 如果拿到的心的属性名称不为 `undefined` ,就用映射后的属性名来操作 `dom` 对象\n\t\t* 否则,那么久使用旧的属性名称来操作 `dom` 对象.\n\n```js\n// 属性模块\nitcast.propFix = {\n\t'for': 'htmlFor',\n\t'class': 'className'\n};\nitcast.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\titcast.propFix[this.toLowerCase()] = this;\n});\nprop: function(name, value) {\n\t// 如果没有给value传值\n\tvar prop;\n\tif (value == undefined) {\n\t\t// 并且name的类型为 对象，表示给每一个dom对象添加多个属性\n\t\tif (typeof name === 'object') {\n\t\t\tthis.each(function() {\n\t\t\t\tfor (var k in name) {\n\t\t\t\t\t// 首先从propFix对象上获取属性名字\n\t\t\t\t\t// 如果有，就使用新的属性名字\n\t\t\t\t\t// 如果没有，就使用原来的属性名字\n\t\t\t\t\tprop = itcast.propFix[k] ? itcast.propFix[k] : k;\n\t\t\t\t\tthis[prop] = name[k];\n\t\t\t\t}\n\t\t\t});\n\t\t} else { // 如果name的类型 为字符串，表示获取第一个dom对象的指定属性值\n\t\t\tprop = itcast.propFix[name] ? itcast.propFix[name]: name;\n\t\t\treturn this.length > 0 ? this[0][prop] : null;\n\t\t}\n\t} else { // 如果传入两个参数，表示给每一个dom对象添加单个属性\n\t\t// 遍历itcast上的每一个dom对象，添加属性\n\t\tprop = itcast.propFix[name] ? itcast.propFix[name]: name;\n\t\tthis.each(function() {\n\t\t\tthis[prop] = value;\n\t\t});\n\t}\n\t// 实现链式编程\n\treturn this;\n}\n```","slug":"javascript-jquery-part3","published":1,"updated":"2016-11-24T01:36:37.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4a000qcsg7hpl723gm"},{"title":"JQuery分析及实现part2之css部分功能及实现","date":"2016-11-19T11:02:01.000Z","_content":"\nJQuery模块分析及其实现第二部分css部分功能及实现,接第一部分!\n\n<!-- more -->\n\n## hasClass方法\n\n1. 功能:如果结果集里只要有一个 `dom` 元素,具有指定的样式类,就返回 `true` \n2. 实现思路\n\t* 定义结果变量 `ret` ,默认值为 `false`\n\t* 遍历结果集的每一个 `dom` 元素,如果当前 `dom` 元素具有指定的样式类,将 `ret=true` 结束循环\n\t* 返回 `ret` .\n\n\t* 如何判断 `dom` 元素具有指定的样式类?\n\t在 `dom` 元素所有的样式类的 `首位 + 空格` ;在用户指定的样式类 `首位 + 空格` 调用indexOf方法,如果返回值 = -1,表示没有;否则就具有指定样式类\n\n```js\nhasClass: function(className) {\n\t// 默认结果false\n\tvar ret = false;\n\t// 遍历this上的每一个dom元素\t\t\t\t\t\n\t// for(var i = 0, l = this.length;i < l;i++){\n\t// \t// 如果当前dom元素具有指定的样式类\n\t// \t// 返回值为true，结束循环\n\t// if((' ' + this[i].className + ' ')\n\t// \t.indexOf(' ' + className + ' ') !== -1) {\n\t// \tret = true;\n\t// \tbreak;\n\t// }\n\t// }\n\tthis.each(function(v) {\n\t\tif ((' ' + v.className + ' ')\n\t\t\t.indexOf(' ' + className + ' ') !== -1) {\n\t\t\tret = true;\n\t\t\treturn false;\n\t\t}\n\t});\n\n\treturn ret;\n},\n```\n\n## $.each方法\n\n1. 功能:实现遍历数组或者伪数组,通过第二个参数(回调函数)来处理遍历到的每一个元素\n\t在回调函数中, `this` 是指向当前遍历的元素.\n2. 语法: `$.each([数组/伪数组], callback)` ;\n3. 实现思路\n\t* 声明 `each` 函数,定义两个形参,第一个 遍历的(伪)数组;第二: 回调函数\n\t* 使用 `for` 循环,遍历(伪)数组,再循环体内部执行回调函数. 在执行时,给回调函数传实参\n\t* 实现回调函数内部 `this` 指向,当前遍历到的元素\n\t* 通过回调函数的返回值,判断是否结束循环. 规定:当返回值为 `false` ,结束循环\n```js\neach: function(obj, callback) {\n\tvar i = 0,\n\t\tl = obj.length;\n\t// 遍历数组元素\n\tfor (; i < l; i++) {\n\t\t// 执行用户指定回调函数\n\t\t// 将当前遍历到的元素以及索引传入回调函数\n\t\tif (callback.call(obj[i], obj[i], i) === false) break;\n\t}\n}\n```\n\n## itcast中链式编程的实现\n\n1. 返回当前方法的调用者: `return this;`\n\n## get方法\n\n1. 功能:根据参数 `index` ,获取相应 `dom` 元素\n2. 实现思路\n\t* 将字符串类型转换成数字\n\t*  `index < 0 ==> index +length`\n\t*  `return this[index]`\n\n```js\nget: function(index) {\n\tindex = index - 0;\n\tindex = index < 0 ? index + this.length : index;\n\treturn this[index];\n},\n```\n\n## eq方法\n\n1. 功能:根据参数 `index` ,获取相应 `dom` 元素,转换成 `itcast` 对象,并且返回\n\n```js\neq: function(index) {\n\treturn itcast(this.get(index));\n},\n```\n\n## first方法\n\n```js\nfirst: function() {\n\treturn this.eq(0);\n},\n```\n\n## last方法\n\n```js\nlast: function() {\n\treturn this.eq(-1);\n}\n```\n\n## css方法\n\n1. 功能:\n\t* 获取:如果只传一个参数并且类型不为对象,获取相应的样式属性值\n\t* 设置:a,如果只传一个参数并且类型为对象,设置多个样式值; b,传入两个参数,设置单个样式.\n2. 实现思路\n\t* 给 `itcast` 原型添加 `css` 方法,定义两个参数.\n\t* 如果只传入一个参数\n\t\t* 类型为对象的话,同时设置多个样式属性\n\t\t* 类型不为对象,获取指定的样式值\n\t* 如果只传入两个参数,设置单个样式值\n```js\ncss: function(name, value) {\n\t// 只传入一个参数\n\tif (value == undefined) {\n\t\t// 如果name类型为对象，同时设置多个样式\n\t\tif (typeof name === 'object') {\n\t\t\t// 遍历this上的每一个dom元素\n\t\t\tthis.each(function(v) {\n\t\t\t\t// 枚举name上的每个属性值\n\t\t\t\tfor (var k in name) {\n\t\t\t\t\t// 给当前遍历到的dom元素设置样式\n\t\t\t\t\tv.style[k] = name[k];\n\t\t\t\t}\n\t\t\t});\n\t\t} else { // 如果name不为对象\n\t\t\t// 默认获取this上的第一个dom元素的指定样式值\n\t\t\t// 如果浏览器支持getComputedStyle，使用该方法获取指定样式值\n\t\t\t// if(window.getComputedStyle){\n\t\t\t// \treturn window.getComputedStyle(this[0])[name];\n\t\t\t// } else { //否则使用currentStyle获取\n\t\t\t// \treturn this[0].currentStyle[name];\n\t\t\t// }\n\t\t\t// 如果this上没有任何dom元素， 就返回null\n\t\t\tif (!this[0]) return null;\n\t\t\treturn window.getComputedStyle ?\n\t\t\t\twindow.getComputedStyle(this[0])[name] :\n\t\t\t\tthis[0].currentStyle[name];\n\n\t\t}\n\t} else { // 如果传入两个参数\n\t\tthis.each(function(v) {\n\t\t\tv.style[name] = value;\n\t\t});\n\t}\n\t// 实现链式编程\n\treturn this;\n},\n```\n\t\n## addClass方法\n\n1. 功能:给结果集中的每一个 `dom` 元素添加指定样式类.\n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 首先判断当前遍历到的 `dom` 元素是否含有样式类.\n\n```js\naddClass: function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 判断当前dom元素v是否具有className\n\t\t// 如果不具有，给其添加指定的样式类\n\t\tif(!itcast(v).hasClass(className)){\n\t\t\tv.className += ' ' + className;\n\t\t}\n\t});\n},\n```\n\n## removeClass方法\n\n1. 功能:删除结果集中的每一个 `dom` 元素的指定样式类.\n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* `(' ' + v.className + ' ').replace(' ' + className + ' ',' ');`\n```js\nremoveClass:function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 删除当前dom元素的样式类className\n\t\tv.className = (' ' + v.className + ' ').\n\t\t\treplace(' ' + className + ' ', ' ');\n\t});\n}\n```\n\n## toggleClass方法\n\n1. 功能: 切换指定的样式类,如果有,就删除,没有就添加     \n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 判断当前遍历到的 `dom` 元素是否含有指定的样式类\n\t* 如果有,就删除\n\t* 如果没有,就添加\n```js\ntoggleClass: function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 将当前遍历到的元素转换成itcast对象\n\t\tvar $v = itcast(v);\n\t\t// 如果具有指定的样式类，就删除该样式类\n\t\tif($v.hasClass(className)){\t\t\t\t\t\n\t\t\t$v.removeClass(className);\n\t\t} else { // 如果没有指定的样式类，就添加该样式类\n\t\t\t$v.addClass(className);\n\t\t}\n\t});\n}\n```","source":"_posts/javascript-jquery-part2.md","raw":"---\ntitle: JQuery分析及实现part2之css部分功能及实现\ndate: 2016-11-19 19:02:01\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第二部分css部分功能及实现,接第一部分!\n\n<!-- more -->\n\n## hasClass方法\n\n1. 功能:如果结果集里只要有一个 `dom` 元素,具有指定的样式类,就返回 `true` \n2. 实现思路\n\t* 定义结果变量 `ret` ,默认值为 `false`\n\t* 遍历结果集的每一个 `dom` 元素,如果当前 `dom` 元素具有指定的样式类,将 `ret=true` 结束循环\n\t* 返回 `ret` .\n\n\t* 如何判断 `dom` 元素具有指定的样式类?\n\t在 `dom` 元素所有的样式类的 `首位 + 空格` ;在用户指定的样式类 `首位 + 空格` 调用indexOf方法,如果返回值 = -1,表示没有;否则就具有指定样式类\n\n```js\nhasClass: function(className) {\n\t// 默认结果false\n\tvar ret = false;\n\t// 遍历this上的每一个dom元素\t\t\t\t\t\n\t// for(var i = 0, l = this.length;i < l;i++){\n\t// \t// 如果当前dom元素具有指定的样式类\n\t// \t// 返回值为true，结束循环\n\t// if((' ' + this[i].className + ' ')\n\t// \t.indexOf(' ' + className + ' ') !== -1) {\n\t// \tret = true;\n\t// \tbreak;\n\t// }\n\t// }\n\tthis.each(function(v) {\n\t\tif ((' ' + v.className + ' ')\n\t\t\t.indexOf(' ' + className + ' ') !== -1) {\n\t\t\tret = true;\n\t\t\treturn false;\n\t\t}\n\t});\n\n\treturn ret;\n},\n```\n\n## $.each方法\n\n1. 功能:实现遍历数组或者伪数组,通过第二个参数(回调函数)来处理遍历到的每一个元素\n\t在回调函数中, `this` 是指向当前遍历的元素.\n2. 语法: `$.each([数组/伪数组], callback)` ;\n3. 实现思路\n\t* 声明 `each` 函数,定义两个形参,第一个 遍历的(伪)数组;第二: 回调函数\n\t* 使用 `for` 循环,遍历(伪)数组,再循环体内部执行回调函数. 在执行时,给回调函数传实参\n\t* 实现回调函数内部 `this` 指向,当前遍历到的元素\n\t* 通过回调函数的返回值,判断是否结束循环. 规定:当返回值为 `false` ,结束循环\n```js\neach: function(obj, callback) {\n\tvar i = 0,\n\t\tl = obj.length;\n\t// 遍历数组元素\n\tfor (; i < l; i++) {\n\t\t// 执行用户指定回调函数\n\t\t// 将当前遍历到的元素以及索引传入回调函数\n\t\tif (callback.call(obj[i], obj[i], i) === false) break;\n\t}\n}\n```\n\n## itcast中链式编程的实现\n\n1. 返回当前方法的调用者: `return this;`\n\n## get方法\n\n1. 功能:根据参数 `index` ,获取相应 `dom` 元素\n2. 实现思路\n\t* 将字符串类型转换成数字\n\t*  `index < 0 ==> index +length`\n\t*  `return this[index]`\n\n```js\nget: function(index) {\n\tindex = index - 0;\n\tindex = index < 0 ? index + this.length : index;\n\treturn this[index];\n},\n```\n\n## eq方法\n\n1. 功能:根据参数 `index` ,获取相应 `dom` 元素,转换成 `itcast` 对象,并且返回\n\n```js\neq: function(index) {\n\treturn itcast(this.get(index));\n},\n```\n\n## first方法\n\n```js\nfirst: function() {\n\treturn this.eq(0);\n},\n```\n\n## last方法\n\n```js\nlast: function() {\n\treturn this.eq(-1);\n}\n```\n\n## css方法\n\n1. 功能:\n\t* 获取:如果只传一个参数并且类型不为对象,获取相应的样式属性值\n\t* 设置:a,如果只传一个参数并且类型为对象,设置多个样式值; b,传入两个参数,设置单个样式.\n2. 实现思路\n\t* 给 `itcast` 原型添加 `css` 方法,定义两个参数.\n\t* 如果只传入一个参数\n\t\t* 类型为对象的话,同时设置多个样式属性\n\t\t* 类型不为对象,获取指定的样式值\n\t* 如果只传入两个参数,设置单个样式值\n```js\ncss: function(name, value) {\n\t// 只传入一个参数\n\tif (value == undefined) {\n\t\t// 如果name类型为对象，同时设置多个样式\n\t\tif (typeof name === 'object') {\n\t\t\t// 遍历this上的每一个dom元素\n\t\t\tthis.each(function(v) {\n\t\t\t\t// 枚举name上的每个属性值\n\t\t\t\tfor (var k in name) {\n\t\t\t\t\t// 给当前遍历到的dom元素设置样式\n\t\t\t\t\tv.style[k] = name[k];\n\t\t\t\t}\n\t\t\t});\n\t\t} else { // 如果name不为对象\n\t\t\t// 默认获取this上的第一个dom元素的指定样式值\n\t\t\t// 如果浏览器支持getComputedStyle，使用该方法获取指定样式值\n\t\t\t// if(window.getComputedStyle){\n\t\t\t// \treturn window.getComputedStyle(this[0])[name];\n\t\t\t// } else { //否则使用currentStyle获取\n\t\t\t// \treturn this[0].currentStyle[name];\n\t\t\t// }\n\t\t\t// 如果this上没有任何dom元素， 就返回null\n\t\t\tif (!this[0]) return null;\n\t\t\treturn window.getComputedStyle ?\n\t\t\t\twindow.getComputedStyle(this[0])[name] :\n\t\t\t\tthis[0].currentStyle[name];\n\n\t\t}\n\t} else { // 如果传入两个参数\n\t\tthis.each(function(v) {\n\t\t\tv.style[name] = value;\n\t\t});\n\t}\n\t// 实现链式编程\n\treturn this;\n},\n```\n\t\n## addClass方法\n\n1. 功能:给结果集中的每一个 `dom` 元素添加指定样式类.\n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 首先判断当前遍历到的 `dom` 元素是否含有样式类.\n\n```js\naddClass: function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 判断当前dom元素v是否具有className\n\t\t// 如果不具有，给其添加指定的样式类\n\t\tif(!itcast(v).hasClass(className)){\n\t\t\tv.className += ' ' + className;\n\t\t}\n\t});\n},\n```\n\n## removeClass方法\n\n1. 功能:删除结果集中的每一个 `dom` 元素的指定样式类.\n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* `(' ' + v.className + ' ').replace(' ' + className + ' ',' ');`\n```js\nremoveClass:function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 删除当前dom元素的样式类className\n\t\tv.className = (' ' + v.className + ' ').\n\t\t\treplace(' ' + className + ' ', ' ');\n\t});\n}\n```\n\n## toggleClass方法\n\n1. 功能: 切换指定的样式类,如果有,就删除,没有就添加     \n2. 实现思路\n\t* 遍历 `this` 上的每一个 `dom` 元素\n\t* 判断当前遍历到的 `dom` 元素是否含有指定的样式类\n\t* 如果有,就删除\n\t* 如果没有,就添加\n```js\ntoggleClass: function(className) {\n\t// 遍历this上的每一个dom元素，并实现链式编程\n\treturn this.each(function(v) {\n\t\t// 将当前遍历到的元素转换成itcast对象\n\t\tvar $v = itcast(v);\n\t\t// 如果具有指定的样式类，就删除该样式类\n\t\tif($v.hasClass(className)){\t\t\t\t\t\n\t\t\t$v.removeClass(className);\n\t\t} else { // 如果没有指定的样式类，就添加该样式类\n\t\t\t$v.addClass(className);\n\t\t}\n\t});\n}\n```","slug":"javascript-jquery-part2","published":1,"updated":"2016-11-24T01:36:18.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4c000scsg720femnt3"},{"title":"JQuery分析及实现part6之动画模块功能及实现","date":"2016-11-24T01:38:13.000Z","_content":"\nJQuery模块分析及其实现第六部分动画部分功能及实现,接第五部分!\n\n<!-- more -->\n\n## 动画原理\n\n* 根据人眼具有 `0.1` 秒的视觉残留,只有在一秒切换至少 `24` 个画面就会产生动画\n\n## 动画的基本结构\n\n```js\nfunction animate() {\n\tfunction render() {\n\t\t//动画\n\t}\n\twindow.setInterval(render, time);\n}\n```\n\n## 小动画案例\n\n* 奔跑的小矩形\n\n```html\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>奔跑吧矩形</title>\n\t<script src=\"itcast.js\"></script>\n\t<style>\n\t\tdiv {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tborder: 5px solid yellowgreen;\n\t\t\tposition: relative;\n\t\t}\n\t</style>\n\t<script>\n\tvar animate = function(elem, step, target) {\n\t\tvar left,//起始位置\n\t\t\ttimer;//定时器id\n\t\tfunction render() {//用来计算动画当前位移，并制定动画元素的位置\n\t\t\tleft = elem.offsetLeft;\n\t\t\tif( left + step >= target ){\n\t\t\t\telem.style.left = target + 'px';\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t} else {\n\t\t\t\telem.style.left = left + step + 'px';\n\t\t\t}\n\t\t}\n\t\t// 启动定时器 开始动画\n\t\ttimer = window.setInterval(render, 1000 / 60);\n\t};\n\t$(function() {\n\t\t$('#start').click(function() {\n\t\t\tanimate(document.getElementById('dv'), 3, 1000);\n\t\t});\n\t});\n\t</script>\n</head>\n<body>\n\t<div id=\"dv\"></div>\n\t<button id=\"start\">开始动画</button>\n</body>\n</html>\n```\n\n## 匀速直线动画\n\n1. 固定时间\n2. 固定距离\n3. 如何判断动画结束的时机?\n\t* 使用时间来判断是否结束动画\n\t* 如果动画时间到达指定时间,那么就结束动画,并让动画元素到达终点\n4. 实现思路\n\t* 定义动画函数, `animate` 函数. 当调用 `animate` 函数时, 即动画开始的时间\n\t* 定义 `render` 函数. 用来给动画元素设置属性值\n\t\t* 计算当前动画元素所在的位置, 然后累计到其对应属性值上.\n\t\t* 首先计算动画的时间间隔\n\t\t* 如果时间间隔大于或等于指定的总时间, 那么就停止动画并设置动画元素到达终点\n\t\t* 否则, 根据速度, 动画时间间隔计算出位移. 再将其于起始位置累加后赋值给 `elem` \n\t* 定义定时器, 开始动画. \n\n```js\nvar animate = function(elem, target, duration) {\n\tvar timer, // 定时器id\n\t\tspeed, // 速度\n\t\tlocation, // 起始位置\n\t\tdistance, // 动画总距离\n\t\tstartTime,// 动画开始时间\n\t\tcurrentTime,// 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = elem.offsetLeft;\n\tdistance = target - location;\n\tspeed = distance / duration;\n\tstartTime = +new Date;  // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif(time >= duration){\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\telem.style.left = target + 'px';\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\twindow.clearInterval(timer);\n\t\t} else { // 否则，根据速度 和 时间间隔求出动画位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\telem.style.left = speed * time + location + 'px';\n\t\t}\n\t};\n\t// 启动定时器 开始动画\n\ttimer = window.setInterval(render, 1000 / 60);\n};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 2000);\n\t});\n});\n```\n\n## 匀减速直线动画\n\n1. 物理公式\n\t* a：\t加速度\n\t* t：\t时间间隔\n\t* v0：\t初始速度\n\t* vt：\t末速度\n\t* S：\t位移\n\t* 正方向：\tS = v0 * t + a + t * t / 2;\n2. S ==> target - location <br> t ==> duration <br> v0 = 0\n3. 正方向 <br> a = 2 * ( S - v0 * t) / ( t * t) <br> ==> = 2 * S / ( t * t) <br> ==> = 2 * ( target - location ) / ( duration * duration ) <br> vt = 2 * ( target - location ) / duration \n4. time 时间间隔内的 匀减速位移 <br> tween = v0 * t - a * t * t / 2 <br> ==> tween = 2 * ( target - location ) * time / duration <br> - (target - location ) * time * time / ( duration * duration )\n\n```js\nvar animate = function(elem, target, duration) {\n\tvar timer, // 定时器id\n\t\ttween, // 单位时间间隔的位移\n\t\tlocation, // 起始位置\n\t\tdistance, // 动画总距离\n\t\tstartTime, // 动画开始时间\n\t\tcurrentTime, // 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = elem.offsetLeft;\n\tdistance = target - location;\n\tstartTime = +new Date; // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif (time >= duration) {\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\ttween = distance;\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\twindow.clearInterval(timer);\n\t\t} else { // 否则，根据速度 和 时间间隔求出动画位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\ttween = 2 * distance * time / duration - distance * time * time / (duration * duration);\n\t\t}\n\n\t\telem.style.left = tween + location + 'px';\n\t};\n\t// 启动定时器 开始动画\n\ttimer = window.setInterval(render, 1000 / 60);\n};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 1500);\n\t});\n});\n```\n\n## 使用对象封装缓动函数\n\n```js\n/*\n\tx: null,\n\tt: 时间间隔\n\tb: 起始位置\n\tc: 终止位置\n\td: 总时间\n*/\n\nvar easing = {\t\t\n\tlinear: function(x, t, b, c, d) {\n\t\treturn (c - b) * t / d;\n\t},\n\tminusspeed: function(x, t, b, c, d) {\n\t\treturn 2 * (c - b) * t / d - (c - b) * t * t / (d * d);\n\t},\n\teaseInQuad: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t + b;\n\t},\n\teaseOutQuad: function(x, t, b, c, d) {\n\t\treturn -c * (t /= d) * (t - 2) + b;\n\t},\n\teaseInOutQuad: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t + b;\n\t\treturn -c / 2 * ((--t) * (t - 2) - 1) + b;\n\t},\n\teaseInCubic: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t + b;\n\t},\n\teaseOutCubic: function(x, t, b, c, d) {\n\t\treturn c * ((t = t / d - 1) * t * t + 1) + b;\n\t},\n\teaseInOutCubic: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n\t\treturn c / 2 * ((t -= 2) * t * t + 2) + b;\n\t},\n\teaseInQuart: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t * t + b;\n\t},\n\teaseOutQuart: function(x, t, b, c, d) {\n\t\treturn -c * ((t = t / d - 1) * t * t * t - 1) + b;\n\t},\n\teaseInOutQuart: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n\t\treturn -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n\t},\n\teaseInQuint: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t * t * t + b;\n\t},\n\teaseOutQuint: function(x, t, b, c, d) {\n\t\treturn c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n\t},\n\teaseInOutQuint: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n\t\treturn c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n\t},\n\teaseInSine: function(x, t, b, c, d) {\n\t\treturn -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n\t},\n\teaseOutSine: function(x, t, b, c, d) {\n\t\treturn c * Math.sin(t / d * (Math.PI / 2)) + b;\n\t},\n\teaseInOutSine: function(x, t, b, c, d) {\n\t\treturn -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n\t},\n\teaseInExpo: function(x, t, b, c, d) {\n\t\treturn (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n\t},\n\teaseOutExpo: function(x, t, b, c, d) {\n\t\treturn (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n\t},\n\teaseInOutExpo: function(x, t, b, c, d) {\n\t\tif (t == 0) return b;\n\t\tif (t == d) return b + c;\n\t\tif ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n\t\treturn c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n\t},\n\teaseInCirc: function(x, t, b, c, d) {\n\t\treturn -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n\t},\n\teaseOutCirc: function(x, t, b, c, d) {\n\t\treturn c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n\t},\n\teaseInOutCirc: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n\t\treturn c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n\t},\n\teaseInElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d) == 1) return b + c;\n\t\tif (!p) p = d * .3;\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n\t},\n\teaseOutElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d) == 1) return b + c;\n\t\tif (!p) p = d * .3;\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n\t},\n\teaseInOutElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d / 2) == 2) return b + c;\n\t\tif (!p) p = d * (.3 * 1.5);\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\tif (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n\t},\n\teaseInBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\treturn c * (t /= d) * t * ((s + 1) * t - s) + b;\n\t},\n\teaseOutBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\treturn c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n\t},\n\teaseInOutBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\tif ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n\t\treturn c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n\t},\n\teaseOutBounce: function(x, t, b, c, d) {\n\t\tif ((t /= d) < (1 / 2.75)) {\n\t\t\treturn c * (7.5625 * t * t) + b;\n\t\t} else if (t < (2 / 2.75)) {\n\t\t\treturn c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\treturn c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n\t\t} else {\n\t\t\treturn c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n\t\t}\n\t}\n};\n```\n\n## 抽取缓动函数\n\n将缓动函数的可变变量抽取出来,以便于封装\n\n```js\nvar animate = function(elem, target, duration, easingName) {\n\t\tvar timer, // 定时器id\n\t\t\ttween, // 单位时间间隔的位移\n\t\t\tlocation, // 起始位置\n\t\t\tdistance, // 动画总距离\n\t\t\tstartTime,// 动画开始时间\n\t\t\tcurrentTime,// 动画当前时间\n\t\t\ttime; // 当前动画经过总时间间隔\n\n\t\tlocation = elem.offsetLeft;\n\t\tdistance = target - location;\t\t\t\t\n\t\tstartTime = +new Date;  // 转换毫秒值\n\t\t// 用来计算动画当前位移，并制定动画元素的位置\n\t\tvar render = function() {\n\t\t\tcurrentTime = +new Date;\n\t\t\ttime = currentTime - startTime;\n\t\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t\t// 停止动画,并设置动画元素到达终点\n\t\t\tif(time >= duration){\n\t\t\t\t// console.log(time);\n\t\t\t\t// 1 设置动画元素到达终点\n\t\t\t\ttween = distance;\n\t\t\t\t// 2 停止动画，即清楚定时器\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t} else { // 否则, 根据匀减速运动公式来求time时间间隔内的位移\n\t\t\t\t// 指定动画元素的位置\n\t\t\t\t// 注意： 要加上 起始位置\n\t\t\t\ttween = easing[easingName](null, time, location, target, duration);\n\t\t\t}\n\n\t\t\telem.style.left = tween + location + 'px';\n\t\t};\n\t\t// 启动定时器 开始动画\n\t\ttimer = window.setInterval(render, 1000 / 60);\n\t};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 1500, 'easeInOutElastic');\n\t});\n});\n\n```\n\n## 多属性动画的实现\n\n到此我们就可以继续进行框架的封装了\n\n```js\n// 获取所有动画属性的起始值\nvar kv = {\n\t'left': 'offsetLeft',\n\t'top': 'offsetTop',\n\t'width': 'offsetWidth',\n\t'height': 'offsetHeight'\n};\n\nfunction getLocation(elem, target) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = elem[kv[k]];\n\t}\n\treturn obj;\n}\n\nfunction getDistance(location, target) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = parseFloat(target[k]) - location[k];\n\t}\n\treturn obj;\n}\n\nfunction getTween(time, location, target, duration, easingName) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = easing[easingName](null, time, location[k], target[k], duration);\n\t}\n\n\treturn obj;\n}\n\nfunction setStyles(elem, location, tween) {\n\tvar k;\n\tfor (k in location) {\n\t\telem.style[k] = location[k] + tween[k] + 'px';\n\t}\n}\nvar animate = function(elem, target, duration, easingName) {\n\tvar timer, // 定时器id\n\t\ttween, // 单位时间间隔的位移{left: 800, top:400}\n\t\tlocation, // 起始位置{left: 8,top: 8}\n\t\tdistance, // 动画总距离{left: 992, top: 792}\n\t\tstartTime, // 动画开始时间\n\t\tcurrentTime, // 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = getLocation(elem, target);\n\tdistance = getDistance(location, target);\n\tstartTime = +new Date; // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif (time >= duration) {\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\ttween = distance;\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\tglobal.clearInterval(timer);\n\t\t\t// 3 删除动画元素的timerId属性\n\t\t\tdelete elem.timerId;\n\t\t} else { // 否则, 根据匀减速运动公式来求time时间间隔内的位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\ttween = getTween(time, location, target, duration, easingName);\n\t\t}\n\t\t// 设置动画属性值\n\t\tsetStyles(elem, location, tween);\n\t};\n\t// 启动定时器 开始动画\n\ttimer = global.setInterval(render, 1000 / 60);\n\t// 把定时器id存储在动画元素上（以自定义属性）\n\telem.timerId = timer;\n};\n\n```\n\n## 实现animate和stop方法\n\n```js\nitcast.fn.extend({\n\tanimate: function(target, duration, easingName) {\n\t\teasingName = easingName || 'linear';\n\t\treturn this.each(function() {\n\t\t\tif(!('timerId' in this)){\n\t\t\t\tanimate(this, target, duration, easingName);\n\t\t\t}\n\t\t});\n\t},\n\tstop: function() {\n\t\treturn this.each(function() {\n\t\t\tif('timerId' in this){\n\t\t\t\tglobal.clearInterval(this.timerId);\n\t\t\t\tdelete this.timerId;\n\t\t\t}\n\t\t});\n\t}\n});\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>动画模块的实现</title>\n\t<script src=\"itcast.js\"></script>\n\t<style>\n\t\tdiv {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tborder: 5px solid yellowgreen;\n\t\t\tposition: relative;\n\t\t}\n\t</style>\n\t<script>\n\t\t$(function() {\n\t\t\t$('#start').click(function() {\n\t\t\t\t$('#dv').animate({left : 1000}, 1500);\n\t\t\t});\n\t\t\t$('#stop').click(function() {\n\t\t\t\t$('#dv').stop();\n\t\t\t});\n\t\t});\n\t</script>\n</head>\n<body>\n\t<div id=\"dv\"></div>\n\t<button id=\"start\">开始\t动画</button>\n\t<button id=\"stop\">停止\t动画</button>\n</body>\n</html>\n```","source":"_posts/javascript-jquery-part6.md","raw":"---\ntitle: JQuery分析及实现part6之动画模块功能及实现\ndate: 2016-11-24 09:38:13\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第六部分动画部分功能及实现,接第五部分!\n\n<!-- more -->\n\n## 动画原理\n\n* 根据人眼具有 `0.1` 秒的视觉残留,只有在一秒切换至少 `24` 个画面就会产生动画\n\n## 动画的基本结构\n\n```js\nfunction animate() {\n\tfunction render() {\n\t\t//动画\n\t}\n\twindow.setInterval(render, time);\n}\n```\n\n## 小动画案例\n\n* 奔跑的小矩形\n\n```html\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>奔跑吧矩形</title>\n\t<script src=\"itcast.js\"></script>\n\t<style>\n\t\tdiv {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tborder: 5px solid yellowgreen;\n\t\t\tposition: relative;\n\t\t}\n\t</style>\n\t<script>\n\tvar animate = function(elem, step, target) {\n\t\tvar left,//起始位置\n\t\t\ttimer;//定时器id\n\t\tfunction render() {//用来计算动画当前位移，并制定动画元素的位置\n\t\t\tleft = elem.offsetLeft;\n\t\t\tif( left + step >= target ){\n\t\t\t\telem.style.left = target + 'px';\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t} else {\n\t\t\t\telem.style.left = left + step + 'px';\n\t\t\t}\n\t\t}\n\t\t// 启动定时器 开始动画\n\t\ttimer = window.setInterval(render, 1000 / 60);\n\t};\n\t$(function() {\n\t\t$('#start').click(function() {\n\t\t\tanimate(document.getElementById('dv'), 3, 1000);\n\t\t});\n\t});\n\t</script>\n</head>\n<body>\n\t<div id=\"dv\"></div>\n\t<button id=\"start\">开始动画</button>\n</body>\n</html>\n```\n\n## 匀速直线动画\n\n1. 固定时间\n2. 固定距离\n3. 如何判断动画结束的时机?\n\t* 使用时间来判断是否结束动画\n\t* 如果动画时间到达指定时间,那么就结束动画,并让动画元素到达终点\n4. 实现思路\n\t* 定义动画函数, `animate` 函数. 当调用 `animate` 函数时, 即动画开始的时间\n\t* 定义 `render` 函数. 用来给动画元素设置属性值\n\t\t* 计算当前动画元素所在的位置, 然后累计到其对应属性值上.\n\t\t* 首先计算动画的时间间隔\n\t\t* 如果时间间隔大于或等于指定的总时间, 那么就停止动画并设置动画元素到达终点\n\t\t* 否则, 根据速度, 动画时间间隔计算出位移. 再将其于起始位置累加后赋值给 `elem` \n\t* 定义定时器, 开始动画. \n\n```js\nvar animate = function(elem, target, duration) {\n\tvar timer, // 定时器id\n\t\tspeed, // 速度\n\t\tlocation, // 起始位置\n\t\tdistance, // 动画总距离\n\t\tstartTime,// 动画开始时间\n\t\tcurrentTime,// 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = elem.offsetLeft;\n\tdistance = target - location;\n\tspeed = distance / duration;\n\tstartTime = +new Date;  // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif(time >= duration){\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\telem.style.left = target + 'px';\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\twindow.clearInterval(timer);\n\t\t} else { // 否则，根据速度 和 时间间隔求出动画位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\telem.style.left = speed * time + location + 'px';\n\t\t}\n\t};\n\t// 启动定时器 开始动画\n\ttimer = window.setInterval(render, 1000 / 60);\n};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 2000);\n\t});\n});\n```\n\n## 匀减速直线动画\n\n1. 物理公式\n\t* a：\t加速度\n\t* t：\t时间间隔\n\t* v0：\t初始速度\n\t* vt：\t末速度\n\t* S：\t位移\n\t* 正方向：\tS = v0 * t + a + t * t / 2;\n2. S ==> target - location <br> t ==> duration <br> v0 = 0\n3. 正方向 <br> a = 2 * ( S - v0 * t) / ( t * t) <br> ==> = 2 * S / ( t * t) <br> ==> = 2 * ( target - location ) / ( duration * duration ) <br> vt = 2 * ( target - location ) / duration \n4. time 时间间隔内的 匀减速位移 <br> tween = v0 * t - a * t * t / 2 <br> ==> tween = 2 * ( target - location ) * time / duration <br> - (target - location ) * time * time / ( duration * duration )\n\n```js\nvar animate = function(elem, target, duration) {\n\tvar timer, // 定时器id\n\t\ttween, // 单位时间间隔的位移\n\t\tlocation, // 起始位置\n\t\tdistance, // 动画总距离\n\t\tstartTime, // 动画开始时间\n\t\tcurrentTime, // 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = elem.offsetLeft;\n\tdistance = target - location;\n\tstartTime = +new Date; // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif (time >= duration) {\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\ttween = distance;\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\twindow.clearInterval(timer);\n\t\t} else { // 否则，根据速度 和 时间间隔求出动画位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\ttween = 2 * distance * time / duration - distance * time * time / (duration * duration);\n\t\t}\n\n\t\telem.style.left = tween + location + 'px';\n\t};\n\t// 启动定时器 开始动画\n\ttimer = window.setInterval(render, 1000 / 60);\n};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 1500);\n\t});\n});\n```\n\n## 使用对象封装缓动函数\n\n```js\n/*\n\tx: null,\n\tt: 时间间隔\n\tb: 起始位置\n\tc: 终止位置\n\td: 总时间\n*/\n\nvar easing = {\t\t\n\tlinear: function(x, t, b, c, d) {\n\t\treturn (c - b) * t / d;\n\t},\n\tminusspeed: function(x, t, b, c, d) {\n\t\treturn 2 * (c - b) * t / d - (c - b) * t * t / (d * d);\n\t},\n\teaseInQuad: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t + b;\n\t},\n\teaseOutQuad: function(x, t, b, c, d) {\n\t\treturn -c * (t /= d) * (t - 2) + b;\n\t},\n\teaseInOutQuad: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t + b;\n\t\treturn -c / 2 * ((--t) * (t - 2) - 1) + b;\n\t},\n\teaseInCubic: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t + b;\n\t},\n\teaseOutCubic: function(x, t, b, c, d) {\n\t\treturn c * ((t = t / d - 1) * t * t + 1) + b;\n\t},\n\teaseInOutCubic: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n\t\treturn c / 2 * ((t -= 2) * t * t + 2) + b;\n\t},\n\teaseInQuart: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t * t + b;\n\t},\n\teaseOutQuart: function(x, t, b, c, d) {\n\t\treturn -c * ((t = t / d - 1) * t * t * t - 1) + b;\n\t},\n\teaseInOutQuart: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n\t\treturn -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n\t},\n\teaseInQuint: function(x, t, b, c, d) {\n\t\treturn c * (t /= d) * t * t * t * t + b;\n\t},\n\teaseOutQuint: function(x, t, b, c, d) {\n\t\treturn c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n\t},\n\teaseInOutQuint: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n\t\treturn c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n\t},\n\teaseInSine: function(x, t, b, c, d) {\n\t\treturn -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n\t},\n\teaseOutSine: function(x, t, b, c, d) {\n\t\treturn c * Math.sin(t / d * (Math.PI / 2)) + b;\n\t},\n\teaseInOutSine: function(x, t, b, c, d) {\n\t\treturn -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n\t},\n\teaseInExpo: function(x, t, b, c, d) {\n\t\treturn (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n\t},\n\teaseOutExpo: function(x, t, b, c, d) {\n\t\treturn (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n\t},\n\teaseInOutExpo: function(x, t, b, c, d) {\n\t\tif (t == 0) return b;\n\t\tif (t == d) return b + c;\n\t\tif ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n\t\treturn c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n\t},\n\teaseInCirc: function(x, t, b, c, d) {\n\t\treturn -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n\t},\n\teaseOutCirc: function(x, t, b, c, d) {\n\t\treturn c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n\t},\n\teaseInOutCirc: function(x, t, b, c, d) {\n\t\tif ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n\t\treturn c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n\t},\n\teaseInElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d) == 1) return b + c;\n\t\tif (!p) p = d * .3;\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n\t},\n\teaseOutElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d) == 1) return b + c;\n\t\tif (!p) p = d * .3;\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n\t},\n\teaseInOutElastic: function(x, t, b, c, d) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = c;\n\t\tif (t == 0) return b;\n\t\tif ((t /= d / 2) == 2) return b + c;\n\t\tif (!p) p = d * (.3 * 1.5);\n\t\tif (a < Math.abs(c)) {\n\t\t\ta = c;\n\t\t\tvar s = p / 4;\n\t\t} else var s = p / (2 * Math.PI) * Math.asin(c / a);\n\t\tif (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n\t},\n\teaseInBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\treturn c * (t /= d) * t * ((s + 1) * t - s) + b;\n\t},\n\teaseOutBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\treturn c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n\t},\n\teaseInOutBack: function(x, t, b, c, d, s) {\n\t\tif (s == undefined) s = 1.70158;\n\t\tif ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n\t\treturn c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n\t},\n\teaseOutBounce: function(x, t, b, c, d) {\n\t\tif ((t /= d) < (1 / 2.75)) {\n\t\t\treturn c * (7.5625 * t * t) + b;\n\t\t} else if (t < (2 / 2.75)) {\n\t\t\treturn c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\treturn c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n\t\t} else {\n\t\t\treturn c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n\t\t}\n\t}\n};\n```\n\n## 抽取缓动函数\n\n将缓动函数的可变变量抽取出来,以便于封装\n\n```js\nvar animate = function(elem, target, duration, easingName) {\n\t\tvar timer, // 定时器id\n\t\t\ttween, // 单位时间间隔的位移\n\t\t\tlocation, // 起始位置\n\t\t\tdistance, // 动画总距离\n\t\t\tstartTime,// 动画开始时间\n\t\t\tcurrentTime,// 动画当前时间\n\t\t\ttime; // 当前动画经过总时间间隔\n\n\t\tlocation = elem.offsetLeft;\n\t\tdistance = target - location;\t\t\t\t\n\t\tstartTime = +new Date;  // 转换毫秒值\n\t\t// 用来计算动画当前位移，并制定动画元素的位置\n\t\tvar render = function() {\n\t\t\tcurrentTime = +new Date;\n\t\t\ttime = currentTime - startTime;\n\t\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t\t// 停止动画,并设置动画元素到达终点\n\t\t\tif(time >= duration){\n\t\t\t\t// console.log(time);\n\t\t\t\t// 1 设置动画元素到达终点\n\t\t\t\ttween = distance;\n\t\t\t\t// 2 停止动画，即清楚定时器\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t} else { // 否则, 根据匀减速运动公式来求time时间间隔内的位移\n\t\t\t\t// 指定动画元素的位置\n\t\t\t\t// 注意： 要加上 起始位置\n\t\t\t\ttween = easing[easingName](null, time, location, target, duration);\n\t\t\t}\n\n\t\t\telem.style.left = tween + location + 'px';\n\t\t};\n\t\t// 启动定时器 开始动画\n\t\ttimer = window.setInterval(render, 1000 / 60);\n\t};\n$(function() {\n\t$('#start').click(function() {\n\t\tanimate(document.getElementById('dv'), 1000, 1500, 'easeInOutElastic');\n\t});\n});\n\n```\n\n## 多属性动画的实现\n\n到此我们就可以继续进行框架的封装了\n\n```js\n// 获取所有动画属性的起始值\nvar kv = {\n\t'left': 'offsetLeft',\n\t'top': 'offsetTop',\n\t'width': 'offsetWidth',\n\t'height': 'offsetHeight'\n};\n\nfunction getLocation(elem, target) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = elem[kv[k]];\n\t}\n\treturn obj;\n}\n\nfunction getDistance(location, target) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = parseFloat(target[k]) - location[k];\n\t}\n\treturn obj;\n}\n\nfunction getTween(time, location, target, duration, easingName) {\n\tvar obj = {};\n\tfor (var k in target) {\n\t\tobj[k] = easing[easingName](null, time, location[k], target[k], duration);\n\t}\n\n\treturn obj;\n}\n\nfunction setStyles(elem, location, tween) {\n\tvar k;\n\tfor (k in location) {\n\t\telem.style[k] = location[k] + tween[k] + 'px';\n\t}\n}\nvar animate = function(elem, target, duration, easingName) {\n\tvar timer, // 定时器id\n\t\ttween, // 单位时间间隔的位移{left: 800, top:400}\n\t\tlocation, // 起始位置{left: 8,top: 8}\n\t\tdistance, // 动画总距离{left: 992, top: 792}\n\t\tstartTime, // 动画开始时间\n\t\tcurrentTime, // 动画当前时间\n\t\ttime; // 当前动画经过总时间间隔\n\n\tlocation = getLocation(elem, target);\n\tdistance = getDistance(location, target);\n\tstartTime = +new Date; // 转换毫秒值\n\t// 用来计算动画当前位移，并制定动画元素的位置\n\tvar render = function() {\n\t\tcurrentTime = +new Date;\n\t\ttime = currentTime - startTime;\n\t\t// 如果当前动画经过总时间间隔大于或等于 指定总时间\n\t\t// 停止动画,并设置动画元素到达终点\n\t\tif (time >= duration) {\n\t\t\t// console.log(time);\n\t\t\t// 1 设置动画元素到达终点\n\t\t\ttween = distance;\n\t\t\t// 2 停止动画，即清楚定时器\n\t\t\tglobal.clearInterval(timer);\n\t\t\t// 3 删除动画元素的timerId属性\n\t\t\tdelete elem.timerId;\n\t\t} else { // 否则, 根据匀减速运动公式来求time时间间隔内的位移\n\t\t\t// 指定动画元素的位置\n\t\t\t// 注意： 要加上 起始位置\n\t\t\ttween = getTween(time, location, target, duration, easingName);\n\t\t}\n\t\t// 设置动画属性值\n\t\tsetStyles(elem, location, tween);\n\t};\n\t// 启动定时器 开始动画\n\ttimer = global.setInterval(render, 1000 / 60);\n\t// 把定时器id存储在动画元素上（以自定义属性）\n\telem.timerId = timer;\n};\n\n```\n\n## 实现animate和stop方法\n\n```js\nitcast.fn.extend({\n\tanimate: function(target, duration, easingName) {\n\t\teasingName = easingName || 'linear';\n\t\treturn this.each(function() {\n\t\t\tif(!('timerId' in this)){\n\t\t\t\tanimate(this, target, duration, easingName);\n\t\t\t}\n\t\t});\n\t},\n\tstop: function() {\n\t\treturn this.each(function() {\n\t\t\tif('timerId' in this){\n\t\t\t\tglobal.clearInterval(this.timerId);\n\t\t\t\tdelete this.timerId;\n\t\t\t}\n\t\t});\n\t}\n});\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>动画模块的实现</title>\n\t<script src=\"itcast.js\"></script>\n\t<style>\n\t\tdiv {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tborder: 5px solid yellowgreen;\n\t\t\tposition: relative;\n\t\t}\n\t</style>\n\t<script>\n\t\t$(function() {\n\t\t\t$('#start').click(function() {\n\t\t\t\t$('#dv').animate({left : 1000}, 1500);\n\t\t\t});\n\t\t\t$('#stop').click(function() {\n\t\t\t\t$('#dv').stop();\n\t\t\t});\n\t\t});\n\t</script>\n</head>\n<body>\n\t<div id=\"dv\"></div>\n\t<button id=\"start\">开始\t动画</button>\n\t<button id=\"stop\">停止\t动画</button>\n</body>\n</html>\n```","slug":"javascript-jquery-part6","published":1,"updated":"2016-11-24T13:13:53.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4f000xcsg7jf1lyqll"},{"title":"JQuery分析及实现part5之事件模块功能及实现","date":"2016-11-23T02:27:16.000Z","_content":"\nJQuery模块分析及其实现第五部分事件部分功能及实现,接第四部分!\n\n<!-- more -->\n\n## remove 方法\n\n1. 功能:将筛选出来的所有 `dom` 元素删除掉\n2. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素;\n    * 获取当前 `dom` 元素的父节点,调用 `removeChild` 方法删除自己;\n    * 循环结束,返回 `this` .\n\n```js\nremove: function() {\n    return this.each(function() {\n        this.parentNode.removeChild(this);\n    });\n},\n```\n\n## empty 方法\n\n1. 功能:将筛选出来的所有 `dom` 元素,清空后代节点\n2. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素;\n    * 直接给当前 `dom` 元素的 `innerHTML` 属性赋值为空字符串;\n    * 循环结束,返回 `this` ,实现链式编程.\n\n```js\nempty: function() {\n    return this.each(function() {\n        this.innerHTML = '';\n    });\n}\n```\n\n<b>以上接第四部分 `dom` 操作模块</b>\n\n***\n\n<b>事件部分begin</b>\n\n## 事件绑定\n\n1. DOM 0方式\n    * 通过 `dom` 元素的 `on + 事件名` 属性来绑定事件,并且赋值为 一个字符串;\n    * 上述字符串为 执行该事件的代码块(逻辑);\n    * 缺点:可读性以及可维护性不好.\n\n2. DOM 0方式的加强版\n    * 通过 `dom` 元素的 `on + 事件名` 属性来绑定事件,并且赋值为 一个事件处理函数;\n    * 缺点:定义很多的全局函数,容易造成内存过大的损耗,依然没有解决 `js` 代码和 `html` 的耦合度关系;\n\n3. IE标准\n    * 通过 `attachEvent` 来绑定事件;\n    * 语法: `dom.attachEvent(type, callback)`;\n    * 移除事件: `detachEvent(type, callback)`;\n        * 注意:如果想要删除某个事件的处理函数,不能将该处理函数定义为匿名的\n\n4. W3C标准\n    * 通过 `addEventListener` 方法来给dom元素绑定事件;\n    * 语法: `dom.addEventListener(type, callback, useCapture默认值为false)`;\n    * 移除事件: `removEventListener(type, callback)`;\n        * 注意:如果想要删除某个事件的处理函数,不能将该处理函数定义为匿名的\n\n5. 事件流\n    * 概念: 用户在触发某一动作时,页面所做相关反映的过程\n    * 三个阶段:\n        * 事件捕获阶段\n        * 处于事件源阶段\n        * 冒泡阶段\n    * 事件流种类\n        * 捕获型事件流: 事件处理函数是在事件的捕获阶段执行\n        * 冒泡型事件流: 事件处理函数是在事件的冒泡阶段执行\n\n6. attachEvent 和 addEventListener 区别\n    * 参数个数不同\n    * 事件类型传值不同\n        * `IE` 标准需要加 `on` 前缀\n        * `W3C` 标准不加 `on` 前缀\n    * 在绑定多个事件处理函数时，`IE` 在执行事件处理函数时,顺序不定(根据版本),而 `W3C`按照对垒结构来一次执行事件的处理函数\n    * 在事件处理函数内 `this` 指向不同\n        * IE: `window`\n        * W3C: 返回正在执行事件的处理函数的 `dom` 元素\n\n## addEvent 方法\n\n1. 根据浏览器能力,提前返回事件绑定方法\n2. 如果浏览器符合 `W3C` 标准,使用 `addEventListener` 来绑定事件\n3. 否则就使用 `attachEvent` 来绑定事件\n\n```js\n//提前返回\nvar addEvent = function() {\n    // 如果符合W3C标准，使用addEvnetListener绑定事件\n    if (global.addEventListener) {\n        return function(elem, type, callback, useCapture) {\n            elem.addEventListener(type, callback, useCapture || false);\n        };\n    } else { // 否则就使用IE标准的 attachEvent绑定事件\n        return function(elem, type, callback) {\n            elem.attachEvent('on' + type, callback);\n        };\n    }\n}();\n```\n\n## removeEvent 方法\n\n1. 根据浏览器能力,提前返回事件移除方法\n2. 如果浏览器符合 `W3C` 标准,使用 `removeEventListener` 来移除事件处理函数\n3. 否则就使用 `detachEvent` 来移除事件处理函数\n\n```js\n//提前返回\nvar removeEvent = function() {\n    if (global.removeEventListener) {\n        return function(elem, type, callback) {\n            elem.removeEventListener(type, callback);\n        };\n    } else {\n        return function(elem, type, callback) {\n            elem.detachEvent('on' + type, callback);\n        };\n    }\n}();\n```\n\n## on 方法\n\n1. 功能:给 `itcast` 对象上的所有的 `dom` 元素绑定事件\n2. 实现思路\n    * 遍历 `this` 上所有 `dom` 元素\n    * 调用 `addEvent` 给当前遍历到的 `dom` 元素绑定事件\n    * 返回 `this` ，实现链式编程\n\n```js\non: function(type, callback, capture) {\n    return this.each(function() {\n        addEvent(this, type, callback, capture);\n    });\n},\n```\n\n## off 方法\n\n1.  功能：移除 `itcast` 对象上所有 `dom` 元素的事件处理函数\n2. 实现思路\n    * 遍历 `this` 上所有 `dom` 元素\n    * 调用 `removeEvent` 给当前遍历到的 `dom` 元素移除相应事件的处理函数\n    * 返回 `this` ，实现链式编程\n\n```js\noff: function(type, callback) {\n    return this.each(function() {\n        removeEvent(this, type, callback);\n    });\n}\n```\n\n## click 方法\n\n1. 功能: 给 `itcast` 对象上的所有的 `dom` 元素绑定单击事件处理函数的\n2. 语法: `itcast对象.click(callback)`;\n3. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素\n    * 调用 `addEventListener` 分别传值即可\n    * `return this` 实现链式编程\n\n```js\nclick: function(callback, capture) {\n    return this.each(function() {\n        addEvent(this, 'click', callback, capture);\n    });\n}\n```\n\n## 快捷绑定事件方法\n\n```js\nitcast.each(['click', 'dblclick', 'keypress', 'keyup', 'keydown', 'mouseover', 'mouseout',\n'mouseenter', 'mouseleave', 'mousemove', 'mouseup', 'mousedown'], function(type) {\n    itcast.fn[type] = function(callback, capture) {\n        return this.on(type, callback, capture);\n    };\n});\n```\n\n","source":"_posts/javascript-jquery-part5.md","raw":"---\ntitle: JQuery分析及实现part5之事件模块功能及实现\ndate: 2016-11-23 10:27:16\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第五部分事件部分功能及实现,接第四部分!\n\n<!-- more -->\n\n## remove 方法\n\n1. 功能:将筛选出来的所有 `dom` 元素删除掉\n2. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素;\n    * 获取当前 `dom` 元素的父节点,调用 `removeChild` 方法删除自己;\n    * 循环结束,返回 `this` .\n\n```js\nremove: function() {\n    return this.each(function() {\n        this.parentNode.removeChild(this);\n    });\n},\n```\n\n## empty 方法\n\n1. 功能:将筛选出来的所有 `dom` 元素,清空后代节点\n2. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素;\n    * 直接给当前 `dom` 元素的 `innerHTML` 属性赋值为空字符串;\n    * 循环结束,返回 `this` ,实现链式编程.\n\n```js\nempty: function() {\n    return this.each(function() {\n        this.innerHTML = '';\n    });\n}\n```\n\n<b>以上接第四部分 `dom` 操作模块</b>\n\n***\n\n<b>事件部分begin</b>\n\n## 事件绑定\n\n1. DOM 0方式\n    * 通过 `dom` 元素的 `on + 事件名` 属性来绑定事件,并且赋值为 一个字符串;\n    * 上述字符串为 执行该事件的代码块(逻辑);\n    * 缺点:可读性以及可维护性不好.\n\n2. DOM 0方式的加强版\n    * 通过 `dom` 元素的 `on + 事件名` 属性来绑定事件,并且赋值为 一个事件处理函数;\n    * 缺点:定义很多的全局函数,容易造成内存过大的损耗,依然没有解决 `js` 代码和 `html` 的耦合度关系;\n\n3. IE标准\n    * 通过 `attachEvent` 来绑定事件;\n    * 语法: `dom.attachEvent(type, callback)`;\n    * 移除事件: `detachEvent(type, callback)`;\n        * 注意:如果想要删除某个事件的处理函数,不能将该处理函数定义为匿名的\n\n4. W3C标准\n    * 通过 `addEventListener` 方法来给dom元素绑定事件;\n    * 语法: `dom.addEventListener(type, callback, useCapture默认值为false)`;\n    * 移除事件: `removEventListener(type, callback)`;\n        * 注意:如果想要删除某个事件的处理函数,不能将该处理函数定义为匿名的\n\n5. 事件流\n    * 概念: 用户在触发某一动作时,页面所做相关反映的过程\n    * 三个阶段:\n        * 事件捕获阶段\n        * 处于事件源阶段\n        * 冒泡阶段\n    * 事件流种类\n        * 捕获型事件流: 事件处理函数是在事件的捕获阶段执行\n        * 冒泡型事件流: 事件处理函数是在事件的冒泡阶段执行\n\n6. attachEvent 和 addEventListener 区别\n    * 参数个数不同\n    * 事件类型传值不同\n        * `IE` 标准需要加 `on` 前缀\n        * `W3C` 标准不加 `on` 前缀\n    * 在绑定多个事件处理函数时，`IE` 在执行事件处理函数时,顺序不定(根据版本),而 `W3C`按照对垒结构来一次执行事件的处理函数\n    * 在事件处理函数内 `this` 指向不同\n        * IE: `window`\n        * W3C: 返回正在执行事件的处理函数的 `dom` 元素\n\n## addEvent 方法\n\n1. 根据浏览器能力,提前返回事件绑定方法\n2. 如果浏览器符合 `W3C` 标准,使用 `addEventListener` 来绑定事件\n3. 否则就使用 `attachEvent` 来绑定事件\n\n```js\n//提前返回\nvar addEvent = function() {\n    // 如果符合W3C标准，使用addEvnetListener绑定事件\n    if (global.addEventListener) {\n        return function(elem, type, callback, useCapture) {\n            elem.addEventListener(type, callback, useCapture || false);\n        };\n    } else { // 否则就使用IE标准的 attachEvent绑定事件\n        return function(elem, type, callback) {\n            elem.attachEvent('on' + type, callback);\n        };\n    }\n}();\n```\n\n## removeEvent 方法\n\n1. 根据浏览器能力,提前返回事件移除方法\n2. 如果浏览器符合 `W3C` 标准,使用 `removeEventListener` 来移除事件处理函数\n3. 否则就使用 `detachEvent` 来移除事件处理函数\n\n```js\n//提前返回\nvar removeEvent = function() {\n    if (global.removeEventListener) {\n        return function(elem, type, callback) {\n            elem.removeEventListener(type, callback);\n        };\n    } else {\n        return function(elem, type, callback) {\n            elem.detachEvent('on' + type, callback);\n        };\n    }\n}();\n```\n\n## on 方法\n\n1. 功能:给 `itcast` 对象上的所有的 `dom` 元素绑定事件\n2. 实现思路\n    * 遍历 `this` 上所有 `dom` 元素\n    * 调用 `addEvent` 给当前遍历到的 `dom` 元素绑定事件\n    * 返回 `this` ，实现链式编程\n\n```js\non: function(type, callback, capture) {\n    return this.each(function() {\n        addEvent(this, type, callback, capture);\n    });\n},\n```\n\n## off 方法\n\n1.  功能：移除 `itcast` 对象上所有 `dom` 元素的事件处理函数\n2. 实现思路\n    * 遍历 `this` 上所有 `dom` 元素\n    * 调用 `removeEvent` 给当前遍历到的 `dom` 元素移除相应事件的处理函数\n    * 返回 `this` ，实现链式编程\n\n```js\noff: function(type, callback) {\n    return this.each(function() {\n        removeEvent(this, type, callback);\n    });\n}\n```\n\n## click 方法\n\n1. 功能: 给 `itcast` 对象上的所有的 `dom` 元素绑定单击事件处理函数的\n2. 语法: `itcast对象.click(callback)`;\n3. 实现思路\n    * 遍历 `this` 上的所有 `dom` 元素\n    * 调用 `addEventListener` 分别传值即可\n    * `return this` 实现链式编程\n\n```js\nclick: function(callback, capture) {\n    return this.each(function() {\n        addEvent(this, 'click', callback, capture);\n    });\n}\n```\n\n## 快捷绑定事件方法\n\n```js\nitcast.each(['click', 'dblclick', 'keypress', 'keyup', 'keydown', 'mouseover', 'mouseout',\n'mouseenter', 'mouseleave', 'mousemove', 'mouseup', 'mousedown'], function(type) {\n    itcast.fn[type] = function(callback, capture) {\n        return this.on(type, callback, capture);\n    };\n});\n```\n\n","slug":"javascript-jquery-part5","published":1,"updated":"2016-11-24T01:37:37.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4l000ycsg70tuaxfin"},{"title":"JQuery分析及实现part7之 Ajax 模块功能及实现","date":"2016-11-25T13:31:12.000Z","_content":"\nJQuery模块分析及其实现第七部分 Ajax 部分功能及实现,接第六部分!\n\n<!-- more -->\n\n## Ajax 请求流程\n\n1. 创建一个请求对象\n\n```js\nfunction createRequest() {\n\treturn window.XMLHttpRequest ? new window.XMLHttpRequest() : \n\t\tnew ActiveXObject('Microsoft.XMLHTTP');\n}\n\nvar xhr = createRequest();\nconsole.log(xhr);\n```\n\n2. 格式化数据\n\t* 将格式化后的数据,参数与值都要重新编码\n\n```js\nfunction formatData(data){\n    var ret = [];\n    for(var k in data){\n        ret.push(window.encodeURIComponent(k) + '=' + window.encodeURIComponent(data[k]));\n    }\n\t\t// 如果不想从服务器缓存中读取数据\n\tret.push(('_=' + Math.random()).replace('.', ''));\n    return ret.join('&');\n}\nvar data = {name: '梦魇小栈',age: 2,url:'http://blog.ihoey.com'};\nconsole.log(formatData(data));//name=%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88&age=2&url=http%3A%2F%2Fblog.ihoey.com\n```\n\n3. 与服务器建立连接\n4. 监听请求状态\n5. 发送请求\n6. 封装\n\n```js\n<script>\n\t// 默认配置信息\n\tajaxSetting = {\n\t\turl: '',\n\t\ttype: 'GET',\n\t\tdataType: 'text',\n\t\tcontentType: 'application/x-www-form-urlencoded',\n\t\tdata: null,\n\t\tasync: true,\n\t\tsuccess: null,\n\t\tfail: null\n\t};\n\n\tfunction createRequest() {\n\t\treturn window.XMLHttpRequest ? new window.XMLHttpRequest() : \n\t\t\tnew ActiveXObject('Microsoft.XMLHTTP');\n\t}\n\n\tfunction formatData(data) {\n\t\tvar ret = [];\n\t\tfor(var k in data){\n\t\t\tret.push(window.encodeURIComponent(k) + '=' + window.encodeURIComponent(data[k]));\n\t\t}\n\t\t// 如果不想从服务器缓存中读取数据\n\t\tret.push(('_=' + Math.random()).replace('.', ''));\n\t\treturn ret.join('&');\n\t}\n\n\tfunction ajax(config) {\n\t\tvar context = {}, \n\t\t\txhr, \n\t\t\tpostData = '';\n\t\t// 过滤无效参数\n\t\tif(!config || !config.url) {\n\t\t\tconsole.warn(\"参数异常\");\n\t\t\treturn;\n\t\t}\n\t\t// debugger;\n\t\t// 获取默认配置信息\n\t\titcast.extend(ajaxSetting, context);\n\t\t// 用户的配置覆盖默认配置\n\t\titcast.extend(config, context);\n\t\t// 1: 创建请求对象\n\t\txhr = createRequest();\n\t\t// 2：格式化数据\n\t\tif(context.data){\n\t\t\tpostData = formatData(context.data);\n\t\t}\n\t\t// 3：与服务器建立连接\n\t\tif(context.type.toUpperCase() === 'GET'){\n\t\t\txhr.open('GET', context.url + '?' + postData, context.async);\n\t\t\tpostData = null;\n\t\t} else {\n\t\t\t// 模拟表单提交，设置请求头信息\n\t\t\txhr.setRequestHeader('Content-Type', context.contentType);\n\t\t\txhr.open('POST', context.url, context.async);\t\t\t\t\n\t\t}\n\t\t// 4：监听请求状态\n\t\txhr.onreadystatechange = function() {\n\t\t\tif(xhr.readyState === 4){\n\t\t\t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304){\n\t\t\t\t\t// 获取到请求回来的数据\n\t\t\t\t\tvar text = xhr.responseText;\n\t\t\t\t\t// 如果指定的数据格式为 json，那就将其转换为json对象\n\t\t\t\t\ttext = context.dataType.toLowerCase() === 'json' ?\n\t\t\t\t\t\tJSON.parse(text) : text;\n\n\t\t\t\t\tcontext.success && context.success(text);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.fail && context.fail({\"errorCode\": xhr.status, \"message\": \"请求超时.\"});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t// 5: 发送请求\n\t\txhr.send(postData);\n\t\t// context.success && context.success(JSON.parse(xhr.responseText));\n\t}\n</script>\n<script>\n\tajax({\n\t\turl: 'data.json',\n\t\tdataType: 'json',\n\t\tasync: false,\n\t\tsuccess: function(data) {\n\t\t\tdocument.getElementById('content').innerHTML= '<p>' + data.username + '</p>' +\n\t\t\t\t\t'<p>' + data.age + '</p>';\n\t\t},\n\t\tfail: function(er) {\n\t\t\tconsole.log(er.errorCode);\n\t\t}\n\t});\n</script>\n```\n## Jsonp 请求\n\n1. 跨域 只能发送 `GET` 请求 . 一种不安全的请求方式\n2. 原理:由于 `dom` 元素的 `src` 属性,具有跨域功能. 在实现跨域请求时,为了方便就使用 `script` 标签来做.\n3. 流程\n\t* 创建请求对象,就是创建一个 `script` 标签\n\t* 将上述创建的 `script` 标签添加到页面的 `head` 标签下\n\t* 格式化数据\n\t* 创建全局回调函数\n\t* 设置超时时间,如果超过此时间,也没有得到数据,表示请求失败.否则,请求成功\n\t* 发送请求: 指定 `script` 标签的 `src` 属性值\n \n\n","source":"_posts/javascript-jquery-part7.md","raw":"---\ntitle: JQuery分析及实现part7之 Ajax 模块功能及实现\ndate: 2016-11-25 21:31:12\ntags: \n\t- 原生Js\n\t- Js框架\n\t- JQuery\ncategories: javascript\n---\n\nJQuery模块分析及其实现第七部分 Ajax 部分功能及实现,接第六部分!\n\n<!-- more -->\n\n## Ajax 请求流程\n\n1. 创建一个请求对象\n\n```js\nfunction createRequest() {\n\treturn window.XMLHttpRequest ? new window.XMLHttpRequest() : \n\t\tnew ActiveXObject('Microsoft.XMLHTTP');\n}\n\nvar xhr = createRequest();\nconsole.log(xhr);\n```\n\n2. 格式化数据\n\t* 将格式化后的数据,参数与值都要重新编码\n\n```js\nfunction formatData(data){\n    var ret = [];\n    for(var k in data){\n        ret.push(window.encodeURIComponent(k) + '=' + window.encodeURIComponent(data[k]));\n    }\n\t\t// 如果不想从服务器缓存中读取数据\n\tret.push(('_=' + Math.random()).replace('.', ''));\n    return ret.join('&');\n}\nvar data = {name: '梦魇小栈',age: 2,url:'http://blog.ihoey.com'};\nconsole.log(formatData(data));//name=%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88&age=2&url=http%3A%2F%2Fblog.ihoey.com\n```\n\n3. 与服务器建立连接\n4. 监听请求状态\n5. 发送请求\n6. 封装\n\n```js\n<script>\n\t// 默认配置信息\n\tajaxSetting = {\n\t\turl: '',\n\t\ttype: 'GET',\n\t\tdataType: 'text',\n\t\tcontentType: 'application/x-www-form-urlencoded',\n\t\tdata: null,\n\t\tasync: true,\n\t\tsuccess: null,\n\t\tfail: null\n\t};\n\n\tfunction createRequest() {\n\t\treturn window.XMLHttpRequest ? new window.XMLHttpRequest() : \n\t\t\tnew ActiveXObject('Microsoft.XMLHTTP');\n\t}\n\n\tfunction formatData(data) {\n\t\tvar ret = [];\n\t\tfor(var k in data){\n\t\t\tret.push(window.encodeURIComponent(k) + '=' + window.encodeURIComponent(data[k]));\n\t\t}\n\t\t// 如果不想从服务器缓存中读取数据\n\t\tret.push(('_=' + Math.random()).replace('.', ''));\n\t\treturn ret.join('&');\n\t}\n\n\tfunction ajax(config) {\n\t\tvar context = {}, \n\t\t\txhr, \n\t\t\tpostData = '';\n\t\t// 过滤无效参数\n\t\tif(!config || !config.url) {\n\t\t\tconsole.warn(\"参数异常\");\n\t\t\treturn;\n\t\t}\n\t\t// debugger;\n\t\t// 获取默认配置信息\n\t\titcast.extend(ajaxSetting, context);\n\t\t// 用户的配置覆盖默认配置\n\t\titcast.extend(config, context);\n\t\t// 1: 创建请求对象\n\t\txhr = createRequest();\n\t\t// 2：格式化数据\n\t\tif(context.data){\n\t\t\tpostData = formatData(context.data);\n\t\t}\n\t\t// 3：与服务器建立连接\n\t\tif(context.type.toUpperCase() === 'GET'){\n\t\t\txhr.open('GET', context.url + '?' + postData, context.async);\n\t\t\tpostData = null;\n\t\t} else {\n\t\t\t// 模拟表单提交，设置请求头信息\n\t\t\txhr.setRequestHeader('Content-Type', context.contentType);\n\t\t\txhr.open('POST', context.url, context.async);\t\t\t\t\n\t\t}\n\t\t// 4：监听请求状态\n\t\txhr.onreadystatechange = function() {\n\t\t\tif(xhr.readyState === 4){\n\t\t\t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304){\n\t\t\t\t\t// 获取到请求回来的数据\n\t\t\t\t\tvar text = xhr.responseText;\n\t\t\t\t\t// 如果指定的数据格式为 json，那就将其转换为json对象\n\t\t\t\t\ttext = context.dataType.toLowerCase() === 'json' ?\n\t\t\t\t\t\tJSON.parse(text) : text;\n\n\t\t\t\t\tcontext.success && context.success(text);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.fail && context.fail({\"errorCode\": xhr.status, \"message\": \"请求超时.\"});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t// 5: 发送请求\n\t\txhr.send(postData);\n\t\t// context.success && context.success(JSON.parse(xhr.responseText));\n\t}\n</script>\n<script>\n\tajax({\n\t\turl: 'data.json',\n\t\tdataType: 'json',\n\t\tasync: false,\n\t\tsuccess: function(data) {\n\t\t\tdocument.getElementById('content').innerHTML= '<p>' + data.username + '</p>' +\n\t\t\t\t\t'<p>' + data.age + '</p>';\n\t\t},\n\t\tfail: function(er) {\n\t\t\tconsole.log(er.errorCode);\n\t\t}\n\t});\n</script>\n```\n## Jsonp 请求\n\n1. 跨域 只能发送 `GET` 请求 . 一种不安全的请求方式\n2. 原理:由于 `dom` 元素的 `src` 属性,具有跨域功能. 在实现跨域请求时,为了方便就使用 `script` 标签来做.\n3. 流程\n\t* 创建请求对象,就是创建一个 `script` 标签\n\t* 将上述创建的 `script` 标签添加到页面的 `head` 标签下\n\t* 格式化数据\n\t* 创建全局回调函数\n\t* 设置超时时间,如果超过此时间,也没有得到数据,表示请求失败.否则,请求成功\n\t* 发送请求: 指定 `script` 标签的 `src` 属性值\n \n\n","slug":"javascript-jquery-part7","published":1,"updated":"2016-11-27T02:31:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4n0012csg7kbt8ps8i"},{"title":"JavaScript高级篇之part2","date":"2016-05-18T10:29:33.000Z","_content":"\njavascript高级与面向对象笔记整理，接part1篇！！\n\n<!-- more -->\n\n## 面向对象编程举例\n\n### 1.面向过程的思维方式\n\n代码重复性太高，几乎没有复用性。\n\t\n### 2.使用函数进行封装\n\n提升的代码的复用性\n全局变量污染\n结构混乱，后期维护不便\n\n### 3.使用对象进行封装\n\n使用对象进行封装，在外界之暴露一个对象名，不会造成全局污染\n在对象内部使用对象的属性，进行模块的划分，让代码的结构更加的清晰，便于维护\n\t\n## 创建对象的三种方式\n\n### 字面量创建对象\n\n```js\nvar obj = {\n    key: value,\n    key: value\n}\n```\n\n只能创建一次对象，复用性太差\n\n### 内置构造函数创建对象\n\n```js\nvar obj = new Object();\n```\n\n每次创建出来的对象都是空对象，需要手动的去添加成员\n\n### 自定义构造函数创建对象\n\n自己创建的构造函数就是自定构造函数\n\n## 自定义构造函数\n\n### 构造函数的特点\n\n* 函数的首字母大写\n* 一般和 `new` 关键字配合使用\n* 没有 `return` 语句，返回值默认为创建出来的对象\n* 手动添加 `return` 语句的时候\n* 如果 `return` 的是基本类型的数据，则不会对默认的返回有任何的影响\n* 如果 `return` 的是对象类型的数据，则会替换掉默认的返回值\n\n### 构造函数的执行步骤\n\n* 使用 `new` 关键字创建对象\n* 调用构造函数，将 `this` 赋值为 `new` 关键字创建出来的对象\n* 在构造函数中，使用 `this` 为新创建的对象新增成员\n* 默认返回新创建的这个对象\n\n## 面向对象的三大特性\n\n### 封装\n\n将数据和方法进行封装，对外界只提供指定的接口，外部使用只要调用相应的接口，而不需要关心内部的具体实现\n\t\n### 继承\n\n一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承\n\t\n### 多态\n\nJS中没有多态\n父类的指针指向子类的对象\n\t\n## 原型\n\n### 构造函数存在的问题\n\n如果将方法的定义写在构造函数中，每次创建对象的时候，都会重新的创建一个新的方法，每个对象独占一个方法，但是所有对象的该方法都是一样的，会造成资源浪费\n\n* 在外部声明函数，每次创建对象的时候，将外部的函数引用赋值给当前对象的方法，这样就能保证所有的对象都指向构造函数外部的这个函数\n* 使用原型\n\n### 原型是什么\n\n在构造函数创建出来的时候，系统会默认的为构造函数创建并关联一个空对象，这个的对象就是原型\n\n### 原型的作用\n\n所用通过构造函数创建出来的对象，都能访问原型中的成员，也就是说原型中的成员被所有的对象共享\n\n### 如何访问原型对象\n\n* 构造函数 `.prototype` \n* 对象 `.__proto__` (不推荐使用，因为有兼容性问题，调试的时候可以使用)\n\n### 原型的使用方式\n\n* 利用对象的动态特性为原型添加成员\n* 直接替换原型对象\n\n### 原型的使用注意事项\n\n* 一般情况只将方法放在原型中，属性放在对象中\n* 对象在获取属性的时候，会现在自身查找，如果找到了直接使用，如果没有找到，就去原型中查找，如果找到了就使用\n* 对象在设置属性的时候，不会去原型中查找了，只在自身进行查找，如果找到了，就修改，如果没有找到，就新增\n* 在替换原型对象的时候，需要注意：替换之前创建的对象和替换之后创建的对象的原型不一致\n\n## 继承的实现方式\n\n### 混入式继承（ `mix-in` ）\n\n```js\nvar obj = {};\nvar obj1 = {name:\"adsf\",age:18};\nfor(var k in obj1){\n    obj[k] = obj1[k];\n}\n```\n\n### 原型继承\n\n#### 1.使用混入的方式为原型对象添加成员、\n\n```js\nvar human = {name:\"\",age:18}\nfunction Person(){};\n\nfor(var k in human){\n    Person.prototype[k] = human[k];\n}\n```\n\n#### 2.直接修改原型对象\n\n```js\nfunction Person(){}\nPerson.prototype.name = \"\";\nPerson.prototype.age = 18;\n```\n\n#### 3.替换原型对象\n\n```js\nvar human = {name:\"\",age:18}\nfunction Person(){};\nPerson.prototype = human;\n```\n\n### 经典继承\n\n```js\nvar obj = Object.create(obj1);\n//创建出来一个新的对象obj继承自obj1\n//原理就是把obj1设置为obj的原型\n```\n\n#### 经典继承的兼容性问题\n\n```js\nfunction myCreate(obj){\n    //判断浏览器有没有Object.create方法\n    if(Object.create){\n        //如果有，直接调用\n        return Object.create(obj);\n    }else{\n        function F(){}\n        F.prototype = obj;\n        return new F();\n    }\n}\n```\n\n##### 为什么不能修改原生对象?\n\n因为原生对象是公用的，在多人开发的时候，可能会出现冲突，你修改了，他也修改了，谁的生效呢？","source":"_posts/javascript-part2.md","raw":"---\ntitle: JavaScript高级篇之part2\ndate: 2016-05-18 18:29:33\ntags: javascript\ncategories: javascript\n---\n\njavascript高级与面向对象笔记整理，接part1篇！！\n\n<!-- more -->\n\n## 面向对象编程举例\n\n### 1.面向过程的思维方式\n\n代码重复性太高，几乎没有复用性。\n\t\n### 2.使用函数进行封装\n\n提升的代码的复用性\n全局变量污染\n结构混乱，后期维护不便\n\n### 3.使用对象进行封装\n\n使用对象进行封装，在外界之暴露一个对象名，不会造成全局污染\n在对象内部使用对象的属性，进行模块的划分，让代码的结构更加的清晰，便于维护\n\t\n## 创建对象的三种方式\n\n### 字面量创建对象\n\n```js\nvar obj = {\n    key: value,\n    key: value\n}\n```\n\n只能创建一次对象，复用性太差\n\n### 内置构造函数创建对象\n\n```js\nvar obj = new Object();\n```\n\n每次创建出来的对象都是空对象，需要手动的去添加成员\n\n### 自定义构造函数创建对象\n\n自己创建的构造函数就是自定构造函数\n\n## 自定义构造函数\n\n### 构造函数的特点\n\n* 函数的首字母大写\n* 一般和 `new` 关键字配合使用\n* 没有 `return` 语句，返回值默认为创建出来的对象\n* 手动添加 `return` 语句的时候\n* 如果 `return` 的是基本类型的数据，则不会对默认的返回有任何的影响\n* 如果 `return` 的是对象类型的数据，则会替换掉默认的返回值\n\n### 构造函数的执行步骤\n\n* 使用 `new` 关键字创建对象\n* 调用构造函数，将 `this` 赋值为 `new` 关键字创建出来的对象\n* 在构造函数中，使用 `this` 为新创建的对象新增成员\n* 默认返回新创建的这个对象\n\n## 面向对象的三大特性\n\n### 封装\n\n将数据和方法进行封装，对外界只提供指定的接口，外部使用只要调用相应的接口，而不需要关心内部的具体实现\n\t\n### 继承\n\n一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承\n\t\n### 多态\n\nJS中没有多态\n父类的指针指向子类的对象\n\t\n## 原型\n\n### 构造函数存在的问题\n\n如果将方法的定义写在构造函数中，每次创建对象的时候，都会重新的创建一个新的方法，每个对象独占一个方法，但是所有对象的该方法都是一样的，会造成资源浪费\n\n* 在外部声明函数，每次创建对象的时候，将外部的函数引用赋值给当前对象的方法，这样就能保证所有的对象都指向构造函数外部的这个函数\n* 使用原型\n\n### 原型是什么\n\n在构造函数创建出来的时候，系统会默认的为构造函数创建并关联一个空对象，这个的对象就是原型\n\n### 原型的作用\n\n所用通过构造函数创建出来的对象，都能访问原型中的成员，也就是说原型中的成员被所有的对象共享\n\n### 如何访问原型对象\n\n* 构造函数 `.prototype` \n* 对象 `.__proto__` (不推荐使用，因为有兼容性问题，调试的时候可以使用)\n\n### 原型的使用方式\n\n* 利用对象的动态特性为原型添加成员\n* 直接替换原型对象\n\n### 原型的使用注意事项\n\n* 一般情况只将方法放在原型中，属性放在对象中\n* 对象在获取属性的时候，会现在自身查找，如果找到了直接使用，如果没有找到，就去原型中查找，如果找到了就使用\n* 对象在设置属性的时候，不会去原型中查找了，只在自身进行查找，如果找到了，就修改，如果没有找到，就新增\n* 在替换原型对象的时候，需要注意：替换之前创建的对象和替换之后创建的对象的原型不一致\n\n## 继承的实现方式\n\n### 混入式继承（ `mix-in` ）\n\n```js\nvar obj = {};\nvar obj1 = {name:\"adsf\",age:18};\nfor(var k in obj1){\n    obj[k] = obj1[k];\n}\n```\n\n### 原型继承\n\n#### 1.使用混入的方式为原型对象添加成员、\n\n```js\nvar human = {name:\"\",age:18}\nfunction Person(){};\n\nfor(var k in human){\n    Person.prototype[k] = human[k];\n}\n```\n\n#### 2.直接修改原型对象\n\n```js\nfunction Person(){}\nPerson.prototype.name = \"\";\nPerson.prototype.age = 18;\n```\n\n#### 3.替换原型对象\n\n```js\nvar human = {name:\"\",age:18}\nfunction Person(){};\nPerson.prototype = human;\n```\n\n### 经典继承\n\n```js\nvar obj = Object.create(obj1);\n//创建出来一个新的对象obj继承自obj1\n//原理就是把obj1设置为obj的原型\n```\n\n#### 经典继承的兼容性问题\n\n```js\nfunction myCreate(obj){\n    //判断浏览器有没有Object.create方法\n    if(Object.create){\n        //如果有，直接调用\n        return Object.create(obj);\n    }else{\n        function F(){}\n        F.prototype = obj;\n        return new F();\n    }\n}\n```\n\n##### 为什么不能修改原生对象?\n\n因为原生对象是公用的，在多人开发的时候，可能会出现冲突，你修改了，他也修改了，谁的生效呢？","slug":"javascript-part2","published":1,"updated":"2016-11-24T01:25:17.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4p0014csg7kfe6q4dp"},{"title":"JavaScript高级篇之part3","date":"2016-11-08T11:39:35.000Z","_content":"javascript高级与面向对象笔记整理，接part2篇！！\n\n<!-- more -->\n\n## 绘制原型三角\n\n1. 先画构造函数\n2. 因为有构造函数就有原型，所以画原型\n3. 画构造函数和原型之间的关系\n4. 画实例化出来的对象\n5. 画实例和构造函数以及原型之间的关系\n\n## constructor属性\n\n1. 原型中的属性\n2. 是在构造函数创建出来的时候，系统创建原型的时候，默认的让原型中的 `constructor` 属性指向构造函数本身\n3. 这个属性基本用不到\n\t\n## 原型链\n\n对象都有原型，原型也是对象，所以原型也有原型，所以就形成了一条链式结构，这个结构就叫做原型链\n\t\n### 绘制原型链图\n\n1. 先画构造函数\n2. 因为有构造函数就有原型，所以画原型\n3. 画构造函数和原型之间的关系\n4. 画实例化出来的对象\n5. 画实例和构造函数以及原型之间的关系\n6. 把原型当做对象来对待，找到原型的构造函数，将构造函数画出来\n7. 画出上一步中构造函数的原型\n8. 把第6步和第7不步中的构造函数和原型之间的关系画出来\n9. 把第6步中的原型和其构造函数还有原型之间的关系画出来\n10. 重复 `6-9` 直到画到 `Object.prototype` 让其原型指向 `null` 就结束了\n\t\n### 属性搜索原则\n\n1. 现在对象本身中进行查找，如果找到了就直接使用\n2. 如果没有，就去原型中查找，如果找到了就直接使用\n3. 如果没有找到，就去原型的原型中查找，以此往复，直到找到 `null`\n\n### `Array.prototype` 是一个空数组\n\n```js\n//arr---->Array.prototype----->Object.Prototype----->null\nvar arr = [];\n```\n\n## `instanceof` 关键字\n\n```js\n对象  instanceof 构造函数\n//返回值为boolean类型\n//功能： 判断构造函数的原型是不是在该对象的原型链上\n```\n\n## `Object.prototype` 的成员\n\n* `constructor` 原型中的属性指向和原型相关的构造函数\n* `hasOwnProperty`\n\n```js\n对象.hasOwnProperty(属性名)\n//返回值为boolean类型\n//功能：判断属性是否存在对象本身中\n```\n* `isPrototypeOf`\n\n```js\n对象.isPrototypeof(对象1)\n//返回值为boolean\n//功能：判断对象是否是对象1的原型对象\n```\n\n* `propertyIsEnumerable`\n\n```js\n对象.propertyIsEnumberable(属性名)\n//返回值为boolean\n//功能：判断属性是否属于对象本身并且能够被遍历（`for-in`）\n```\n\n* `toString toLocaleString`\n\n都是将对象转换成字符串类型\n`toLocaleString` 会将字符串转换成本地格式的字符串， 本地格式为系统设置\n\n* `valueOf`\n\n    在对象参与运算的时候，会首先调用 `valueOf` 方法，如果获取到的值能够参与运算就直接使用，\n    如果不能参与运算，就调用 `toString` 方法\n\n```js\n    []==![] true\n    {}==!{} false\n```\n\n## Function\n\n用来创建函数的\n\n* 如果不传参数，创建出来的是空函数\n* 如果传一个参数，创建出来的时候有函数体，但是没有形参的函数\n* 如果传多个参数，最后参数会被作为函数体，之前所有的参数都会被作为形参\n\n可以把字符串转换成代码\n\n## eval\n\n也可以将字符串转换成代码并且执行\n\n### `Function`和`eval`的区别\n\n* `Funtion`创建出来的是函数，函数需要手动调用，里面的代码才会执行\n* `eval`直接回将字符串转换成代码，并且执行\n\n### `Function`和`eval`的共同点\n\n* 都可以将字符串转换成代码\n* 都不安全\n\t\n### `eval`处理`JSON`格式字符串的时候\n\n* 会把JSON格式字符串中的{}当做代码段来处理，所以会报错\n* 处理方式两种\n* 给JSON字符串前后拼接小括号()\n* 将变量的声明以及等号 拼接在JSON格式字符串的前面\n\n## 静态成员和实例成员\n\n* 静态成员：通过构造函数去访问的成员就是静态成员\n* 实例成员：通过实例去访问的成员就是实例成员\n\n## arguments对象\n\n`arguments` 对象是函数中的一个对象，在函数调用的时候，会将所有传入的实参依次存入该对象\n\n* `length`  获取传入实参的个数\n* `callee`  指向函数本身   匿名函数的递归","source":"_posts/javascript-part3.md","raw":"---\ntitle: JavaScript高级篇之part3\ndate: 2016-11-08 19:39:35\ntags: javascript\ncategories: javascript\n---\njavascript高级与面向对象笔记整理，接part2篇！！\n\n<!-- more -->\n\n## 绘制原型三角\n\n1. 先画构造函数\n2. 因为有构造函数就有原型，所以画原型\n3. 画构造函数和原型之间的关系\n4. 画实例化出来的对象\n5. 画实例和构造函数以及原型之间的关系\n\n## constructor属性\n\n1. 原型中的属性\n2. 是在构造函数创建出来的时候，系统创建原型的时候，默认的让原型中的 `constructor` 属性指向构造函数本身\n3. 这个属性基本用不到\n\t\n## 原型链\n\n对象都有原型，原型也是对象，所以原型也有原型，所以就形成了一条链式结构，这个结构就叫做原型链\n\t\n### 绘制原型链图\n\n1. 先画构造函数\n2. 因为有构造函数就有原型，所以画原型\n3. 画构造函数和原型之间的关系\n4. 画实例化出来的对象\n5. 画实例和构造函数以及原型之间的关系\n6. 把原型当做对象来对待，找到原型的构造函数，将构造函数画出来\n7. 画出上一步中构造函数的原型\n8. 把第6步和第7不步中的构造函数和原型之间的关系画出来\n9. 把第6步中的原型和其构造函数还有原型之间的关系画出来\n10. 重复 `6-9` 直到画到 `Object.prototype` 让其原型指向 `null` 就结束了\n\t\n### 属性搜索原则\n\n1. 现在对象本身中进行查找，如果找到了就直接使用\n2. 如果没有，就去原型中查找，如果找到了就直接使用\n3. 如果没有找到，就去原型的原型中查找，以此往复，直到找到 `null`\n\n### `Array.prototype` 是一个空数组\n\n```js\n//arr---->Array.prototype----->Object.Prototype----->null\nvar arr = [];\n```\n\n## `instanceof` 关键字\n\n```js\n对象  instanceof 构造函数\n//返回值为boolean类型\n//功能： 判断构造函数的原型是不是在该对象的原型链上\n```\n\n## `Object.prototype` 的成员\n\n* `constructor` 原型中的属性指向和原型相关的构造函数\n* `hasOwnProperty`\n\n```js\n对象.hasOwnProperty(属性名)\n//返回值为boolean类型\n//功能：判断属性是否存在对象本身中\n```\n* `isPrototypeOf`\n\n```js\n对象.isPrototypeof(对象1)\n//返回值为boolean\n//功能：判断对象是否是对象1的原型对象\n```\n\n* `propertyIsEnumerable`\n\n```js\n对象.propertyIsEnumberable(属性名)\n//返回值为boolean\n//功能：判断属性是否属于对象本身并且能够被遍历（`for-in`）\n```\n\n* `toString toLocaleString`\n\n都是将对象转换成字符串类型\n`toLocaleString` 会将字符串转换成本地格式的字符串， 本地格式为系统设置\n\n* `valueOf`\n\n    在对象参与运算的时候，会首先调用 `valueOf` 方法，如果获取到的值能够参与运算就直接使用，\n    如果不能参与运算，就调用 `toString` 方法\n\n```js\n    []==![] true\n    {}==!{} false\n```\n\n## Function\n\n用来创建函数的\n\n* 如果不传参数，创建出来的是空函数\n* 如果传一个参数，创建出来的时候有函数体，但是没有形参的函数\n* 如果传多个参数，最后参数会被作为函数体，之前所有的参数都会被作为形参\n\n可以把字符串转换成代码\n\n## eval\n\n也可以将字符串转换成代码并且执行\n\n### `Function`和`eval`的区别\n\n* `Funtion`创建出来的是函数，函数需要手动调用，里面的代码才会执行\n* `eval`直接回将字符串转换成代码，并且执行\n\n### `Function`和`eval`的共同点\n\n* 都可以将字符串转换成代码\n* 都不安全\n\t\n### `eval`处理`JSON`格式字符串的时候\n\n* 会把JSON格式字符串中的{}当做代码段来处理，所以会报错\n* 处理方式两种\n* 给JSON字符串前后拼接小括号()\n* 将变量的声明以及等号 拼接在JSON格式字符串的前面\n\n## 静态成员和实例成员\n\n* 静态成员：通过构造函数去访问的成员就是静态成员\n* 实例成员：通过实例去访问的成员就是实例成员\n\n## arguments对象\n\n`arguments` 对象是函数中的一个对象，在函数调用的时候，会将所有传入的实参依次存入该对象\n\n* `length`  获取传入实参的个数\n* `callee`  指向函数本身   匿名函数的递归","slug":"javascript-part3","published":1,"updated":"2016-11-24T01:29:36.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4s0017csg79yjhmvg6"},{"title":"JavaScript高级篇之part4","date":"2016-11-09T13:19:05.000Z","_content":"javascript高级与面向对象笔记整理，接part3篇！！\n\n<!-- more -->\n\n## 绘制原型三角\n\n## 原型链\n\n## 原型链图\n\n## 属性搜索原则\n\n只有获取属性的时候会遵守这个原则\n\n## `instanceof`\n\n## `Object.prototype` 的成员\n\n* `constructor` 属性\n\t指向原型相关的构造函数\n* `hasOwnProperty` 方法\n\t对象 `.hasOwnProperty`（属性名）\n* `isPrototypeOf` 方法\n\t对象`.isPrototypeOf`（对象1）判断对象是否是对象1的原型\n* `propertyIsEnmerable` 方法\n\t对象`.propertyIsEnmerable`(属性)\n* `toSting`  `toLocaleSting` 方法\n\t转换成字符串，`toLocaleSting`会将对象转换成\n* `valueOf` 方法\n\t胡i去兑现的值，再回去运算的时候先调用`valueOf`方法\n* `__proto__` 属性\n\t指向对象的原型\n* 双下划线开头的属性都是属于非标准属性\n* 单下划线开头 一般框架中的私有属性\n\n## `.Function`\n\n## `eval`\n\n## 静态成员和实例成员\n\n### 静态成员\n\n* 通过构造函数访问成员的就是静态成员\n* 构造函数 `.prototype`\n* 构造函数 `.name`\n* 构造函数 `.length` （形参的个数）\n\n### 实例成员\n\n通过对象访问的成员就是实例成员\n\n* 只要是通过对象访问到的都是实例成员\n* 比如 `p.name`\t`p.age`\t`p.__proto__`……\n\n## `arguments` 对象\n\n只能在函数内部使用\n\n* 当函数调用的时候会将所有的输惨存入 `arguments` 对象\n*  `arguments.length` （实参的个数）\n*  `arguments.callee` 指向函数本身。用在匿名函数递归\n* 构造函数 `.arguments` 和函数里面的 `arguments` 不是一回事儿\n* 构造函数 `.arguments` 已被弃用","source":"_posts/javascript-part4.md","raw":"---\ntitle: JavaScript高级篇之part4\ndate: 2016-11-09 21:19:05\ntags: javascript\ncategories: javascript\n---\njavascript高级与面向对象笔记整理，接part3篇！！\n\n<!-- more -->\n\n## 绘制原型三角\n\n## 原型链\n\n## 原型链图\n\n## 属性搜索原则\n\n只有获取属性的时候会遵守这个原则\n\n## `instanceof`\n\n## `Object.prototype` 的成员\n\n* `constructor` 属性\n\t指向原型相关的构造函数\n* `hasOwnProperty` 方法\n\t对象 `.hasOwnProperty`（属性名）\n* `isPrototypeOf` 方法\n\t对象`.isPrototypeOf`（对象1）判断对象是否是对象1的原型\n* `propertyIsEnmerable` 方法\n\t对象`.propertyIsEnmerable`(属性)\n* `toSting`  `toLocaleSting` 方法\n\t转换成字符串，`toLocaleSting`会将对象转换成\n* `valueOf` 方法\n\t胡i去兑现的值，再回去运算的时候先调用`valueOf`方法\n* `__proto__` 属性\n\t指向对象的原型\n* 双下划线开头的属性都是属于非标准属性\n* 单下划线开头 一般框架中的私有属性\n\n## `.Function`\n\n## `eval`\n\n## 静态成员和实例成员\n\n### 静态成员\n\n* 通过构造函数访问成员的就是静态成员\n* 构造函数 `.prototype`\n* 构造函数 `.name`\n* 构造函数 `.length` （形参的个数）\n\n### 实例成员\n\n通过对象访问的成员就是实例成员\n\n* 只要是通过对象访问到的都是实例成员\n* 比如 `p.name`\t`p.age`\t`p.__proto__`……\n\n## `arguments` 对象\n\n只能在函数内部使用\n\n* 当函数调用的时候会将所有的输惨存入 `arguments` 对象\n*  `arguments.length` （实参的个数）\n*  `arguments.callee` 指向函数本身。用在匿名函数递归\n* 构造函数 `.arguments` 和函数里面的 `arguments` 不是一回事儿\n* 构造函数 `.arguments` 已被弃用","slug":"javascript-part4","published":1,"updated":"2016-11-24T01:30:05.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4w001bcsg7ydc3ek9s"},{"title":"JavaScript高级篇之part1","date":"2016-05-08T09:31:48.000Z","_content":"\njavascript高级与面向对象笔记整理，第一篇！！\n\n<!-- more -->\n\n## JavaScript基础知识复习\n\n### JavaScript的基本组成\n\n* `ECMAScript`     规定了 `JavaScript` 的语法规范\n* `DOM`            提供了访问页面元素的 `API`\n* `BOM`            提供了访问浏览器相关信息的 `API`\n\n### JavaScript的数据类型\n\n#### 简单类型\n\n* `string`\n* `number`\n* `boolean`\n* `undefined`\n\n#### 复杂类型\n\n* `Object`\n* `function`\n* `Array`\n* `Date`\n* `RegExp`\n* `Math`（对象）\n* `String`\n* `Number`\n* `Boolean`\n* `null(特殊的)`\n\n#### 获取类型的关键字 `typeof`\n\n```js\ntypeof 变量名（表达式）\n//返回值为字符串类型\n```\n\n#### 引用类型 值类型\n\n##### 引用类型\n\n存储的是数据的地址的数据就是引用类型的数据\n\t\n##### 值类型\n\n存储的数据本身的数据就是值类型的数据\n\n##### 赋值特征\n\n* 值类型进行赋值的时候，直接将数据复制一份赋值给新的变量，两份数据互不影响\n* 引用类型进行赋值的时候，将数据的地址复制一份赋值给新的变量，两个变量指向同一个对象，两个互相影响\n\n### `in` 关键字\n\n#### `for-in`\n\n用来遍历对象的属性的，每次遍历到的属性是字符串类型的\n\t\n```js\n\tfor(var k in obj){\n\t\t//这里的k就是每个键\n\t}\n```\n\n#### `in`\n\n检测对象中是否存在某个属性\n\t\n```js\n属性名 in 对象名\n```\n\n### 逻辑中断\n\n#### ||\n\n `表达式1 || 表达式2`\n如果表达式 `1` 为真，就返回表达式 `1` ，如果表达式 `1` 位假，则返回表达式 `2`\n\t\n#### &&\n\n `表达式1 && 表达式2`\n如果表达式 `1` 为真，就返回表达式 `2` ，如果表达式 `1` 为假，则返回表达式 `1`\n\n### delete关键字\n\n* 删除未使用 `var` 声明的变量\n* 删除对象的属性\n*  `window` 有自带的属性 `name` \n\n### `continue` 和 `break`\n\n*  `continue ` 跳出本次循环，继续下次循环\n*  `break` 跳出整个循环，继续执行循环之后的代码\n\n### 对象的动态特性\n\n对象在创建出来之后，可以随时的新增成员（方法和属性），这就是对象的动态特性\n\n### 调试工具的使用\n\n* 普通断点\n* 条件断点\n* `Elements`  审查元素 做 `css`\n* `Console`  跟页面在同一个 `js` 的运行环境中，可以写任何的 `js` 代码，也可以用 `js` 操作页面元素\n* `Sources`  所有的资源文件都在这里，最重要的就是可以在这里对 `js`代码进行断点调试\n\n### 异常处理\n\n```js\ntry{\n    //可能出现异常的代码\n}catch(e){\n    //e 异常对象，异常信息\n    //捕获异常后的处理代码\n}finally{\n    //不论是否发生异常，都会执行的代码\n}\n```\n\n## 面向对象简单介绍\n\n### 面向对象的基本概念\n\n面向对象是一种思维方式，他是将解决问题的关注点放到了解决问题所需要的一些列对象身上\n\n### 面向过程的基本概念\n\n面向过程是一种思维方式，他是将解决问题的关注点放到了解决问题的每一个详细的步骤上\n\n### 面向对象就是对面向过程的封装","source":"_posts/javascript-part1.md","raw":"---\ntitle: JavaScript高级篇之part1\ndate: 2016-05-08 17:31:48\ntags: javascript\ncategories: javascript\n---\n\njavascript高级与面向对象笔记整理，第一篇！！\n\n<!-- more -->\n\n## JavaScript基础知识复习\n\n### JavaScript的基本组成\n\n* `ECMAScript`     规定了 `JavaScript` 的语法规范\n* `DOM`            提供了访问页面元素的 `API`\n* `BOM`            提供了访问浏览器相关信息的 `API`\n\n### JavaScript的数据类型\n\n#### 简单类型\n\n* `string`\n* `number`\n* `boolean`\n* `undefined`\n\n#### 复杂类型\n\n* `Object`\n* `function`\n* `Array`\n* `Date`\n* `RegExp`\n* `Math`（对象）\n* `String`\n* `Number`\n* `Boolean`\n* `null(特殊的)`\n\n#### 获取类型的关键字 `typeof`\n\n```js\ntypeof 变量名（表达式）\n//返回值为字符串类型\n```\n\n#### 引用类型 值类型\n\n##### 引用类型\n\n存储的是数据的地址的数据就是引用类型的数据\n\t\n##### 值类型\n\n存储的数据本身的数据就是值类型的数据\n\n##### 赋值特征\n\n* 值类型进行赋值的时候，直接将数据复制一份赋值给新的变量，两份数据互不影响\n* 引用类型进行赋值的时候，将数据的地址复制一份赋值给新的变量，两个变量指向同一个对象，两个互相影响\n\n### `in` 关键字\n\n#### `for-in`\n\n用来遍历对象的属性的，每次遍历到的属性是字符串类型的\n\t\n```js\n\tfor(var k in obj){\n\t\t//这里的k就是每个键\n\t}\n```\n\n#### `in`\n\n检测对象中是否存在某个属性\n\t\n```js\n属性名 in 对象名\n```\n\n### 逻辑中断\n\n#### ||\n\n `表达式1 || 表达式2`\n如果表达式 `1` 为真，就返回表达式 `1` ，如果表达式 `1` 位假，则返回表达式 `2`\n\t\n#### &&\n\n `表达式1 && 表达式2`\n如果表达式 `1` 为真，就返回表达式 `2` ，如果表达式 `1` 为假，则返回表达式 `1`\n\n### delete关键字\n\n* 删除未使用 `var` 声明的变量\n* 删除对象的属性\n*  `window` 有自带的属性 `name` \n\n### `continue` 和 `break`\n\n*  `continue ` 跳出本次循环，继续下次循环\n*  `break` 跳出整个循环，继续执行循环之后的代码\n\n### 对象的动态特性\n\n对象在创建出来之后，可以随时的新增成员（方法和属性），这就是对象的动态特性\n\n### 调试工具的使用\n\n* 普通断点\n* 条件断点\n* `Elements`  审查元素 做 `css`\n* `Console`  跟页面在同一个 `js` 的运行环境中，可以写任何的 `js` 代码，也可以用 `js` 操作页面元素\n* `Sources`  所有的资源文件都在这里，最重要的就是可以在这里对 `js`代码进行断点调试\n\n### 异常处理\n\n```js\ntry{\n    //可能出现异常的代码\n}catch(e){\n    //e 异常对象，异常信息\n    //捕获异常后的处理代码\n}finally{\n    //不论是否发生异常，都会执行的代码\n}\n```\n\n## 面向对象简单介绍\n\n### 面向对象的基本概念\n\n面向对象是一种思维方式，他是将解决问题的关注点放到了解决问题所需要的一些列对象身上\n\n### 面向过程的基本概念\n\n面向过程是一种思维方式，他是将解决问题的关注点放到了解决问题的每一个详细的步骤上\n\n### 面向对象就是对面向过程的封装","slug":"javascript-part1","published":1,"updated":"2016-11-24T01:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw4x001fcsg7cd5zecj6"},{"title":"JavaScript高级篇之part6","date":"2016-11-11T11:35:55.000Z","_content":"javascript高级与面向对象笔记整理，接part5篇！！\n\n<!-- more -->\n\n## 闭包的练习\n\n### for循环中注册点击事件\n\n### for循环中是用setTimeout\n\n## 缓存\n\n缓存就是将一些数据，剧院，进行临时的存储，以提高访问效率\n\n* 浏览器缓存\n* CDN\n* JS中的缓存\n\n## 使用缓存解决斐波那契数列的性能问题\n\n### 有什么性能问题\n\n使用递归去计算斐波那契数列存在大量的重复的计算，导致计算效率十分底下\n\n### 如何解决性能问题\n\n使用缓存\n\n1. 创建一个数组充当缓存容器\n2. 每次需要计算斐波那契数列的时候，先去缓存中进行查找\n3. 如果有就直接返回\n4. 如果没有，就去计算，算出来结果之后\n5. 将结果存入缓存中\n6. 将结果返回\n\n```js\n//1.创建一个数组充当缓存容器\nvar arr = [];\nfunction fibnacci(n){\n//2.每次需要计算斐波那契数列的时候，先去缓存中进行查找\n\tvar num = arr[n];\n\tif(num){\n\t\t//3.如果有就直接返回\n\t\treturn num;\n\t}else{\n\t\t//4.如果没有，就去计算，算出来结果之后\n\t\tif(n <= 2){\n\t\t\tnum=1;\n\t\t}else{\n\t\tnum = fibnacci(n-1)+fibnacci(n-2);\n\t\t}\n\t\t//5.将结果存入缓存中\n\t\tarr[n] = num;\n\t\t//6.将结果返回\n\t\treturn num;\n\t}\n}\n```\n\n优化后的代码\n\n```js\nfunction createFib(){\n    //1.创建一个数组充当缓存容器\n    var arr = [];\n    function fibnacci(n){\n    //2.每次需要计算斐波那契数字的时候，先去缓存中进行查找\n        var num = arr[n];\n        if(!num){\n            //4.如果没有，就去就算，算出来结果之后，\n            if(n <= 2){\n                num = 1;\n            }else{\n                num = fibnacci(n-1)+fibnacci(n-2);\n            }\n            //5.将结果存入缓存中\n            arr[n] = num;\n        }\n        //6.将结果返回\n        return num;\n    }\n    return fibnacci;\n}\n\n```\n\n## jQuery缓存实现分析\n\n```js\nfunction createCache(){\n\t//需要一个能够存储数据的容器\n\tvar cache = {};\n\t//用来存储 键，并且记录键存入的顺序\n\tvar keys = [];\n\treturn function(key,value){\n\t\tif(value){\n\t\t\tcache[key] = value;\n\t\t\tkeys.push(key);\n\t\t\tif(keys.length > 50){\n\t\t\t\tdelete cache[keys.shift()];\n\t\t\t}\n\t\t}else{\n\t\t\treturn cache[key];\n\t\t}\n\t}\n}\n```\n\n## Jquery缓存源码分析\n\n```js\nfunction createCache(){\n\tvar keys = [];\n\tfunction cache(key,value){\n\t\tif(keys.push(key + \" \") > 10){\n\t\t \tdelete cache[keys.shift()];\n\t\t}\n\t\treturn (cache[key + \" \"] = value);\n\t}\n\treturn cache;\n}\nvar cache = createCache();\ncache(\"name\",\"mengyan\");\ncache[\"name\" + \" \"];\n\n```\n\n## 函数的四种调用形式\n\n### 函数调用模式\n\n形式：函数名（）；\n`this：window`\n\n### 方法调用模式\n\n形式：对项目.方法名（）；\nthis：调用该方法的对象\n\n### 构造函数调用模式\n\n形式 `new` 函数名（）\nthis：new创建出来的对象\n\n#### 工厂模式\n\n```js\nfunction createPerson(){\n    var o = new Object();\n    o.name = \"zs\";\n    o.age = 18;\n    return o;\n}\n\nvar p = createPerson();\n```\n\n#### 寄生模式\n\n```js\nfunction Person(){\n    var o = new Object();\n    o.name = \"zs\";\n    o.age = 18;\n    return o;\n}\n\nvar p = new Person();\n```\n\n### 上下文调用模式\n\n在其他的调用模式中， `this` 不可以赋值，也就不可以改变\n在上下文调用模式中，可以进行手动的设置 `this` 。\n\n#### call\n\n```js\n//函数名.call(对象, 参数1, 参数2, 参数3...)\n```\n\n1. 调用函数\n2. 将函数内的 `this` 指向第一个参数中的对象\n3. 将除第一个参数外的所有参数依次传给函数，做为实参\n\n#### apply\n\n```js\n//函数名.apply(对象, 数组)\n```\n\n1. 调用函数\n2. 将函数内的 `this` 指向第一个参数中的对象\n3. 将第二个参数中的数组拆解开，将数组中的元素依次的传给函数当做实参\n\n#### 借用构造函数继承\n\n```js\nfunction Parent(){\n    this.money = 100000000000000;\n}\n\nfunction Son(){\n    Parent.call(this);\n    this.wife = \"凤姐\";\n}\n\nvar s = new Son();\n```\n\n1. 使用 `new` 关键字创建了一个对象\n2. 调用构造函数 `Son` ，将 `Son` 中的 `this` 指向刚才创建的对象\n3. 在 `Son` 构造函数中，是用上下文调用模式去调用 `Parent` 函数，\n4. 调用 `Person` 函数，将 `Parent` 中的 `this` 指向 `song` 中的 `this` ，也就是用 `new` 创建出来的那个对象\n5.  `Parent` 中会使用 `this` 给对象添加成员\n6.  `Parent` 调用结束， `Son` 中的 `this` 也就有了 `Parent` 中添加的那些个成员\n\n将伪数组转换成数组\n\n```js\nvar fakeArr = {\n    0:\"a\",\n    1:\"b\",\n    2:\"c\",\n    length:3\n}\n\nvar arr = [];\n\nArray.prototype.push.apply(arr, fakeArr);\nArray.prototype.concat.apply(arr, fakeArr);\n\n\narr.concat.apply(arr, fakeArr);\n\n```\n\n求数组的最大值\n\n```js\nvar arr = [1 ,2,3,3,4,4,34,3,43,43,43,4,34,3];\n\nvar max = Math.max.apply(null, arr);\n//Math.max(1,2,3,43,4,3,43,43,43)\n```","source":"_posts/javascript-part6.md","raw":"---\ntitle: JavaScript高级篇之part6\ndate: 2016-11-11 19:35:55\ntags: javascript\ncategories: javascript\n---\njavascript高级与面向对象笔记整理，接part5篇！！\n\n<!-- more -->\n\n## 闭包的练习\n\n### for循环中注册点击事件\n\n### for循环中是用setTimeout\n\n## 缓存\n\n缓存就是将一些数据，剧院，进行临时的存储，以提高访问效率\n\n* 浏览器缓存\n* CDN\n* JS中的缓存\n\n## 使用缓存解决斐波那契数列的性能问题\n\n### 有什么性能问题\n\n使用递归去计算斐波那契数列存在大量的重复的计算，导致计算效率十分底下\n\n### 如何解决性能问题\n\n使用缓存\n\n1. 创建一个数组充当缓存容器\n2. 每次需要计算斐波那契数列的时候，先去缓存中进行查找\n3. 如果有就直接返回\n4. 如果没有，就去计算，算出来结果之后\n5. 将结果存入缓存中\n6. 将结果返回\n\n```js\n//1.创建一个数组充当缓存容器\nvar arr = [];\nfunction fibnacci(n){\n//2.每次需要计算斐波那契数列的时候，先去缓存中进行查找\n\tvar num = arr[n];\n\tif(num){\n\t\t//3.如果有就直接返回\n\t\treturn num;\n\t}else{\n\t\t//4.如果没有，就去计算，算出来结果之后\n\t\tif(n <= 2){\n\t\t\tnum=1;\n\t\t}else{\n\t\tnum = fibnacci(n-1)+fibnacci(n-2);\n\t\t}\n\t\t//5.将结果存入缓存中\n\t\tarr[n] = num;\n\t\t//6.将结果返回\n\t\treturn num;\n\t}\n}\n```\n\n优化后的代码\n\n```js\nfunction createFib(){\n    //1.创建一个数组充当缓存容器\n    var arr = [];\n    function fibnacci(n){\n    //2.每次需要计算斐波那契数字的时候，先去缓存中进行查找\n        var num = arr[n];\n        if(!num){\n            //4.如果没有，就去就算，算出来结果之后，\n            if(n <= 2){\n                num = 1;\n            }else{\n                num = fibnacci(n-1)+fibnacci(n-2);\n            }\n            //5.将结果存入缓存中\n            arr[n] = num;\n        }\n        //6.将结果返回\n        return num;\n    }\n    return fibnacci;\n}\n\n```\n\n## jQuery缓存实现分析\n\n```js\nfunction createCache(){\n\t//需要一个能够存储数据的容器\n\tvar cache = {};\n\t//用来存储 键，并且记录键存入的顺序\n\tvar keys = [];\n\treturn function(key,value){\n\t\tif(value){\n\t\t\tcache[key] = value;\n\t\t\tkeys.push(key);\n\t\t\tif(keys.length > 50){\n\t\t\t\tdelete cache[keys.shift()];\n\t\t\t}\n\t\t}else{\n\t\t\treturn cache[key];\n\t\t}\n\t}\n}\n```\n\n## Jquery缓存源码分析\n\n```js\nfunction createCache(){\n\tvar keys = [];\n\tfunction cache(key,value){\n\t\tif(keys.push(key + \" \") > 10){\n\t\t \tdelete cache[keys.shift()];\n\t\t}\n\t\treturn (cache[key + \" \"] = value);\n\t}\n\treturn cache;\n}\nvar cache = createCache();\ncache(\"name\",\"mengyan\");\ncache[\"name\" + \" \"];\n\n```\n\n## 函数的四种调用形式\n\n### 函数调用模式\n\n形式：函数名（）；\n`this：window`\n\n### 方法调用模式\n\n形式：对项目.方法名（）；\nthis：调用该方法的对象\n\n### 构造函数调用模式\n\n形式 `new` 函数名（）\nthis：new创建出来的对象\n\n#### 工厂模式\n\n```js\nfunction createPerson(){\n    var o = new Object();\n    o.name = \"zs\";\n    o.age = 18;\n    return o;\n}\n\nvar p = createPerson();\n```\n\n#### 寄生模式\n\n```js\nfunction Person(){\n    var o = new Object();\n    o.name = \"zs\";\n    o.age = 18;\n    return o;\n}\n\nvar p = new Person();\n```\n\n### 上下文调用模式\n\n在其他的调用模式中， `this` 不可以赋值，也就不可以改变\n在上下文调用模式中，可以进行手动的设置 `this` 。\n\n#### call\n\n```js\n//函数名.call(对象, 参数1, 参数2, 参数3...)\n```\n\n1. 调用函数\n2. 将函数内的 `this` 指向第一个参数中的对象\n3. 将除第一个参数外的所有参数依次传给函数，做为实参\n\n#### apply\n\n```js\n//函数名.apply(对象, 数组)\n```\n\n1. 调用函数\n2. 将函数内的 `this` 指向第一个参数中的对象\n3. 将第二个参数中的数组拆解开，将数组中的元素依次的传给函数当做实参\n\n#### 借用构造函数继承\n\n```js\nfunction Parent(){\n    this.money = 100000000000000;\n}\n\nfunction Son(){\n    Parent.call(this);\n    this.wife = \"凤姐\";\n}\n\nvar s = new Son();\n```\n\n1. 使用 `new` 关键字创建了一个对象\n2. 调用构造函数 `Son` ，将 `Son` 中的 `this` 指向刚才创建的对象\n3. 在 `Son` 构造函数中，是用上下文调用模式去调用 `Parent` 函数，\n4. 调用 `Person` 函数，将 `Parent` 中的 `this` 指向 `song` 中的 `this` ，也就是用 `new` 创建出来的那个对象\n5.  `Parent` 中会使用 `this` 给对象添加成员\n6.  `Parent` 调用结束， `Son` 中的 `this` 也就有了 `Parent` 中添加的那些个成员\n\n将伪数组转换成数组\n\n```js\nvar fakeArr = {\n    0:\"a\",\n    1:\"b\",\n    2:\"c\",\n    length:3\n}\n\nvar arr = [];\n\nArray.prototype.push.apply(arr, fakeArr);\nArray.prototype.concat.apply(arr, fakeArr);\n\n\narr.concat.apply(arr, fakeArr);\n\n```\n\n求数组的最大值\n\n```js\nvar arr = [1 ,2,3,3,4,4,34,3,43,43,43,4,34,3];\n\nvar max = Math.max.apply(null, arr);\n//Math.max(1,2,3,43,4,3,43,43,43)\n```","slug":"javascript-part6","published":1,"updated":"2016-11-24T01:31:31.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw50001jcsg72u7fjazr"},{"title":"js高级与面向对象之原型链","date":"2016-07-09T11:41:47.000Z","_content":"\n## 原型链是什么？\n\n只要是对象就会有原型，那么所有的原型就会形成一个链式的结构，这个结构就称为原型链\n\n<!-- more -->\n\n```js\nfunction Person(){}\n//p--->Person.prototype----->Object.Prototype----->null\nvar p = new Person();\n\nconsole.log(Person.prototype);\n//原型也是一个对象，是对象，就有构造函数，有构造函数，就有原型\n```\n\n## 修改原型链\n\n* 原型链结构可以进行修改\n* 替换原型对象就可以修改原型链结构\n\n* 原型继承的概念重定义\n* 通过修改原型链的结构实现的继承就是原型继承\n\n* 属性的搜索原则\n* 在对象访问属性的时候，会遵守一个原则\n1. 现在对象本身中进行查找，如果本身中有，就直接使用，\n2. 如果没有，就去原型中查找，如果原型中有，就直接使用\n3. 如果没有，重复步骤2，直到找到 `null`\n\n* 设置属性没有搜索原则，只会在本身中进行搜索\n\n* 由于属性搜索原则的存在，所以对象可以直接访问 `.constructor` 属性找到其构造函数\n\n```js\nfunction Human(){\n\n}\n\nfunction Person(){\n\n}\nPerson.prototype = new Human();\n\n//p---->Person.prototype----->Human.prototype----->Object.prototype----->null\nvar p = new Person();\n```\n\n## 复杂的原型链\n\n```js\nfunction Animal(){\n    this.name = \"123\";\n}\n\nfunction Human(\n\n){}\n\nvar animal = new Animal();\nHuman.prototype = animal;\n\nvar h = new Human();\n//通过h去访问constructor属性的顺序\n//1.现在h自身查找 h中没有\n//2.去Human.prototype 也就是 h.__proto___  也就是animal中去找\n//3.再去anmail这个对象的原型中 也就是 Animal.prototype 也即是 animal.__proto__ 中去找\n//4.找到的就是Animal\nconsole.log(h.constructor);\n\n\nfunction Man(){}\nvar h1 = new Human();\nMan.prototype = h1;\n\nvar m = new Man();\n//1.第一步在m自己中找 没有\n//2.m.__proto__  也就是Man.prototype 也就是 h1中去查找 没有\n//3.h1的原型 也就是 h1.__proto__ 也就是 Human.prototype\n//4.去上面看吧\nconsole.log(m.constructor);\n\n```\n\n## instanceof关键字\n\n* 对象 `instanceof` 构造函数\n* 检测一个对象是不是通过某个构造函数创建出来的(不准确的说法)\n* 检测一个构造函数的原型 `（构造函数.prototype）` 是否在某个对象的原型链上\n\n```js\nfunction Person(){\n\n        }\n//p---->Person.prototype---->Object.prototype---->null\nvar p = new Person();\n\nconsole.log(p instanceof Person);\n\nconsole.log(p instanceof Object);\n```\n\n## Object.prototype成员\n\n1.  `constructor`  指向原型相关的构造函数\n2.  `hasOwnProperty` 判断对象本身是否拥有指定的属性  不包含原型中的成员\n\t`对象.hasOwnProperty(属性名)`\n3.  `isPrototypeOf` 判断一个对象是否某个对象的原型\n\t`对象.isPrototypeOf(另外一个对象)`\n4.  `propertyIsEnumerable`  判断对象自己的属性是不是可以被遍历 `（for-in）` 如果不是自己的或者不能被遍历都会返回 `false`\n\t`对象.propertyIsEnumerable(属性名)`\n\t`Object.defineProperty(对象，属性名，对象（描述信息）)`\n\n5.  `toLocaleString`  `toString`   都是将对象转换为字符串的方法\n\t`tolocalString` 打印本地格式的字符串  本地格式是获取的系统设置\n\t`toString` 直接转换成字符串\n6.  `valueOf` 方法\n\t当对象参与运算的时候，会首先调用对象的 `valuOf` 方法获取对象的值\n\t如果获取到的这个值可以参与运算，就直接拿来使用\n\t如果不能参与运算，就会去调用该对象的 `toString` 方法\n\n```js\nvar obj = {\n    valueOf :function () {\n        return 1;\n    },\n\n    toString:function(){\n        return \"我叫李二狗\";\n    }\n};\n//console.log(obj.valueOf());\nconsole.log(obj.toString());\nconsole.log( obj + 1);\n```\n\n7. __proto__  指向对象的原型  非标准属性\n\n```js\nvar now = new Date();\nconsole.log(now.toString());\nconsole.log(now.toLocaleString());\n\nvar obj = {\n      name:\"\",\n    age:18\n}\n\nconsole.log(obj.toString());\nconsole.log(obj.toLocaleString());\n\nobj.__proto__.name =  \"张三\";\n\nfor(var k in obj){\n    console.log(k);\n}\n\nconsole.log(obj.propertyIsEnumerable(\"name\"));\n\nvar obj = {\n\n}\n\nobj.__proto__ = {\n   beautifulLevel : \"High\"\n}\n\nconsole.log(obj.hasOwnProperty(\"beautifulLevel\"));\nvar obj = {};\n\nvar obj1 = {};\n\nobj.__proto__ = obj1;\nconsole.log(obj1.isPrototypeOf(obj));\n```","source":"_posts/javascript-prototype-chain.md","raw":"---\ntitle: js高级与面向对象之原型链\ndate: 2016-7-09 19:41:47\ntags: \n\t- 原型链\ncategories: javascript\n---\n\n## 原型链是什么？\n\n只要是对象就会有原型，那么所有的原型就会形成一个链式的结构，这个结构就称为原型链\n\n<!-- more -->\n\n```js\nfunction Person(){}\n//p--->Person.prototype----->Object.Prototype----->null\nvar p = new Person();\n\nconsole.log(Person.prototype);\n//原型也是一个对象，是对象，就有构造函数，有构造函数，就有原型\n```\n\n## 修改原型链\n\n* 原型链结构可以进行修改\n* 替换原型对象就可以修改原型链结构\n\n* 原型继承的概念重定义\n* 通过修改原型链的结构实现的继承就是原型继承\n\n* 属性的搜索原则\n* 在对象访问属性的时候，会遵守一个原则\n1. 现在对象本身中进行查找，如果本身中有，就直接使用，\n2. 如果没有，就去原型中查找，如果原型中有，就直接使用\n3. 如果没有，重复步骤2，直到找到 `null`\n\n* 设置属性没有搜索原则，只会在本身中进行搜索\n\n* 由于属性搜索原则的存在，所以对象可以直接访问 `.constructor` 属性找到其构造函数\n\n```js\nfunction Human(){\n\n}\n\nfunction Person(){\n\n}\nPerson.prototype = new Human();\n\n//p---->Person.prototype----->Human.prototype----->Object.prototype----->null\nvar p = new Person();\n```\n\n## 复杂的原型链\n\n```js\nfunction Animal(){\n    this.name = \"123\";\n}\n\nfunction Human(\n\n){}\n\nvar animal = new Animal();\nHuman.prototype = animal;\n\nvar h = new Human();\n//通过h去访问constructor属性的顺序\n//1.现在h自身查找 h中没有\n//2.去Human.prototype 也就是 h.__proto___  也就是animal中去找\n//3.再去anmail这个对象的原型中 也就是 Animal.prototype 也即是 animal.__proto__ 中去找\n//4.找到的就是Animal\nconsole.log(h.constructor);\n\n\nfunction Man(){}\nvar h1 = new Human();\nMan.prototype = h1;\n\nvar m = new Man();\n//1.第一步在m自己中找 没有\n//2.m.__proto__  也就是Man.prototype 也就是 h1中去查找 没有\n//3.h1的原型 也就是 h1.__proto__ 也就是 Human.prototype\n//4.去上面看吧\nconsole.log(m.constructor);\n\n```\n\n## instanceof关键字\n\n* 对象 `instanceof` 构造函数\n* 检测一个对象是不是通过某个构造函数创建出来的(不准确的说法)\n* 检测一个构造函数的原型 `（构造函数.prototype）` 是否在某个对象的原型链上\n\n```js\nfunction Person(){\n\n        }\n//p---->Person.prototype---->Object.prototype---->null\nvar p = new Person();\n\nconsole.log(p instanceof Person);\n\nconsole.log(p instanceof Object);\n```\n\n## Object.prototype成员\n\n1.  `constructor`  指向原型相关的构造函数\n2.  `hasOwnProperty` 判断对象本身是否拥有指定的属性  不包含原型中的成员\n\t`对象.hasOwnProperty(属性名)`\n3.  `isPrototypeOf` 判断一个对象是否某个对象的原型\n\t`对象.isPrototypeOf(另外一个对象)`\n4.  `propertyIsEnumerable`  判断对象自己的属性是不是可以被遍历 `（for-in）` 如果不是自己的或者不能被遍历都会返回 `false`\n\t`对象.propertyIsEnumerable(属性名)`\n\t`Object.defineProperty(对象，属性名，对象（描述信息）)`\n\n5.  `toLocaleString`  `toString`   都是将对象转换为字符串的方法\n\t`tolocalString` 打印本地格式的字符串  本地格式是获取的系统设置\n\t`toString` 直接转换成字符串\n6.  `valueOf` 方法\n\t当对象参与运算的时候，会首先调用对象的 `valuOf` 方法获取对象的值\n\t如果获取到的这个值可以参与运算，就直接拿来使用\n\t如果不能参与运算，就会去调用该对象的 `toString` 方法\n\n```js\nvar obj = {\n    valueOf :function () {\n        return 1;\n    },\n\n    toString:function(){\n        return \"我叫李二狗\";\n    }\n};\n//console.log(obj.valueOf());\nconsole.log(obj.toString());\nconsole.log( obj + 1);\n```\n\n7. __proto__  指向对象的原型  非标准属性\n\n```js\nvar now = new Date();\nconsole.log(now.toString());\nconsole.log(now.toLocaleString());\n\nvar obj = {\n      name:\"\",\n    age:18\n}\n\nconsole.log(obj.toString());\nconsole.log(obj.toLocaleString());\n\nobj.__proto__.name =  \"张三\";\n\nfor(var k in obj){\n    console.log(k);\n}\n\nconsole.log(obj.propertyIsEnumerable(\"name\"));\n\nvar obj = {\n\n}\n\nobj.__proto__ = {\n   beautifulLevel : \"High\"\n}\n\nconsole.log(obj.hasOwnProperty(\"beautifulLevel\"));\nvar obj = {};\n\nvar obj1 = {};\n\nobj.__proto__ = obj1;\nconsole.log(obj1.isPrototypeOf(obj));\n```","slug":"javascript-prototype-chain","published":1,"updated":"2016-11-24T01:28:07.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw52001mcsg752gv0xck"},{"title":"JavaScript高级篇之part5","date":"2016-11-10T13:43:36.000Z","_content":"javascript高级与面向对象笔记整理，接part4篇！！\n\n<!-- more -->\n\n## 词法作用域\n\n### 词法作用域的概念\n\n变量的作用域在代码写好的时候就已经可以确定，这种作用域就是词法作用域\n\n*  `JavaScript` 中没有动态作用域\n*  `JavaScript` 中没有块级作用域\n\n## 变量提升\n\nJS代码执行分两个阶段，首先进行预解析，再执行\n在预解析阶段，系统会将所有的变量声明以及函数声明提升到当前作用域的最顶上\n\n* 当函数同名的时候，都会提升，但是后面的函数会将前面的函数覆盖\n* 当函数和变量同名的时候，只会提升函数声明，变量声明会被忽略\n* 变量提升是分作用域的\n* 变量提升是分段（ `script` 标签）\n* 函数表达式是不会被提升,提升的只是变量的声明。  `var func= function(){};`\n* 条件式函数声明，根据浏览器不同，提升的情况不同，最新的浏览器中都不会进行提升\n\n## 作用域链\n\n在 `js` 中只有函数可以限定作用域，然后，函数中又可以声明函数，这样就形成了一个由内向外进行访问的链式结构，这个结构就叫做作用域链\n\n### 如何绘制作用域链\n\n1. 先画一条直线，表示0级作用域链，也就是全局作用域\n2. 再在全局作用域中查找变量以及函数的声明，将所有找到的这些成员以小方块的形式放在0级作用域链上\n3. 如果全局作用域中有函数成员，那就从该函数中在引出一条线，表示1级作用域链\n4. 再去1级作用域中进行查找变量以及函数的声明，在把他们画出来，\n5. 如果还有函数，就接着去找。。。。直到没有函数为止\n\n### 变量的搜索原则\n\n1. 首先在当前作用域中进行查找，如果找到了就直接使用\n2. 如果没有找到，就去上一级作用域中进行查找，如果找到了就直接使用\n3. 果没有找到，就继续往上查找，直到找到全局作用域为止\n\n### 如何分析面试题\n\n1. 先进行提升处理（把提升后的代码写出来）\n2. 然后根据作用域及作用域链还有变量搜索原则进行分析\n\n## 闭包\n\n* 语文解释：封闭的包裹结构\n* js的解释：函数就是一个闭包\n\n### 闭包要解决的问题是什么？\n\n函数内部的数据无法被外界直接访问！\n\n### 如何解决？\n\n在函数内部返回一个函数，用来操作该函数内部的数据。\n\n### 闭包的原理（作用域）\n\n函数中的变量无法被上一级作用域访问，但是可以被下一级作用域访问。\n\n### 闭包的基本模型\n\n```js\nfunction func(){\n    var name = \"\";\n    return function(){\n        return name;\n    }\n}\n```\n\n### 如何访问多个数据？\n\n返回一个对象，对象中包含对所有数据的设置和访问的方法，在函数外部接收到该对象之后，就可以操作函数内部的数据\n\n### 点击事件的注册问题\n\n如果在`for`循环中使用循环的控制变量i来处理点击事件中的内容，那么这个 `i` 在点击事件触发的时候，循环已经结束，`i` 已经变成了最后一个值，所以会不准确\n\n#### 如何解决\n\n在点击事件的处理函数内部，访问的时候，不要去使用 `i`，而是使用这个函数自己的一个私有的数据。\n所以需要使用一个拥有自己的变量的函数来做点击事件的处理函数。\n\n\t这个函数需要通过闭包来创建。\n\n```js\nfunction f1(j){\n    return function(){\n        console.log(j);  //这里的j就是只有这个函数可以访问的一个私有的变量\n    }\n}\n\n```\n\n\t上面的函数调用之后的返回值，就拥有了自己独立的变量，我们可以使用它来做点击事件的处理函数\n\n### setTimeout的回调函数执行时间问题\n\n`setTimeout` 和 `setInterval` 中的回调函数，会在所有的主逻辑代码执行完之后，才依次检查执行时间是不是到了，到了就会执行\n\n当把 `setTimeout` 放在一个for循环语句中的时候，如果在回调函数中使用了循环中变量i\n那么，当 `setTimeout` 的回调函数执行的时候， `for` 循环已经执行完毕，i已经是最后一个值\n\n#### 解决办法\n\n回调函数不应该去使用 `for` 循环中的 `i` ，而是使用自己的一个私有变量\n\n```js\nfunction f(j){\n    return fucntion(){\n        console.log(j)\n    }\n}\nsetTimeout(f(i),0);\n```","source":"_posts/javascript-part5.md","raw":"---\ntitle: JavaScript高级篇之part5\ndate: 2016-11-10 21:43:36\ntags: javascript\ncategories: javascript\n---\njavascript高级与面向对象笔记整理，接part4篇！！\n\n<!-- more -->\n\n## 词法作用域\n\n### 词法作用域的概念\n\n变量的作用域在代码写好的时候就已经可以确定，这种作用域就是词法作用域\n\n*  `JavaScript` 中没有动态作用域\n*  `JavaScript` 中没有块级作用域\n\n## 变量提升\n\nJS代码执行分两个阶段，首先进行预解析，再执行\n在预解析阶段，系统会将所有的变量声明以及函数声明提升到当前作用域的最顶上\n\n* 当函数同名的时候，都会提升，但是后面的函数会将前面的函数覆盖\n* 当函数和变量同名的时候，只会提升函数声明，变量声明会被忽略\n* 变量提升是分作用域的\n* 变量提升是分段（ `script` 标签）\n* 函数表达式是不会被提升,提升的只是变量的声明。  `var func= function(){};`\n* 条件式函数声明，根据浏览器不同，提升的情况不同，最新的浏览器中都不会进行提升\n\n## 作用域链\n\n在 `js` 中只有函数可以限定作用域，然后，函数中又可以声明函数，这样就形成了一个由内向外进行访问的链式结构，这个结构就叫做作用域链\n\n### 如何绘制作用域链\n\n1. 先画一条直线，表示0级作用域链，也就是全局作用域\n2. 再在全局作用域中查找变量以及函数的声明，将所有找到的这些成员以小方块的形式放在0级作用域链上\n3. 如果全局作用域中有函数成员，那就从该函数中在引出一条线，表示1级作用域链\n4. 再去1级作用域中进行查找变量以及函数的声明，在把他们画出来，\n5. 如果还有函数，就接着去找。。。。直到没有函数为止\n\n### 变量的搜索原则\n\n1. 首先在当前作用域中进行查找，如果找到了就直接使用\n2. 如果没有找到，就去上一级作用域中进行查找，如果找到了就直接使用\n3. 果没有找到，就继续往上查找，直到找到全局作用域为止\n\n### 如何分析面试题\n\n1. 先进行提升处理（把提升后的代码写出来）\n2. 然后根据作用域及作用域链还有变量搜索原则进行分析\n\n## 闭包\n\n* 语文解释：封闭的包裹结构\n* js的解释：函数就是一个闭包\n\n### 闭包要解决的问题是什么？\n\n函数内部的数据无法被外界直接访问！\n\n### 如何解决？\n\n在函数内部返回一个函数，用来操作该函数内部的数据。\n\n### 闭包的原理（作用域）\n\n函数中的变量无法被上一级作用域访问，但是可以被下一级作用域访问。\n\n### 闭包的基本模型\n\n```js\nfunction func(){\n    var name = \"\";\n    return function(){\n        return name;\n    }\n}\n```\n\n### 如何访问多个数据？\n\n返回一个对象，对象中包含对所有数据的设置和访问的方法，在函数外部接收到该对象之后，就可以操作函数内部的数据\n\n### 点击事件的注册问题\n\n如果在`for`循环中使用循环的控制变量i来处理点击事件中的内容，那么这个 `i` 在点击事件触发的时候，循环已经结束，`i` 已经变成了最后一个值，所以会不准确\n\n#### 如何解决\n\n在点击事件的处理函数内部，访问的时候，不要去使用 `i`，而是使用这个函数自己的一个私有的数据。\n所以需要使用一个拥有自己的变量的函数来做点击事件的处理函数。\n\n\t这个函数需要通过闭包来创建。\n\n```js\nfunction f1(j){\n    return function(){\n        console.log(j);  //这里的j就是只有这个函数可以访问的一个私有的变量\n    }\n}\n\n```\n\n\t上面的函数调用之后的返回值，就拥有了自己独立的变量，我们可以使用它来做点击事件的处理函数\n\n### setTimeout的回调函数执行时间问题\n\n`setTimeout` 和 `setInterval` 中的回调函数，会在所有的主逻辑代码执行完之后，才依次检查执行时间是不是到了，到了就会执行\n\n当把 `setTimeout` 放在一个for循环语句中的时候，如果在回调函数中使用了循环中变量i\n那么，当 `setTimeout` 的回调函数执行的时候， `for` 循环已经执行完毕，i已经是最后一个值\n\n#### 解决办法\n\n回调函数不应该去使用 `for` 循环中的 `i` ，而是使用自己的一个私有变量\n\n```js\nfunction f(j){\n    return fucntion(){\n        console.log(j)\n    }\n}\nsetTimeout(f(i),0);\n```","slug":"javascript-part5","published":1,"updated":"2016-11-24T01:30:21.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw55001pcsg7ee1szpca"},{"title":"JavaScript高级篇总结","date":"2016-11-12T11:04:31.000Z","_content":"javascript高级与面向对象笔记总结！！\n\n<!-- more -->\n\n## 递归\n\n递归就是函数自己直接或者间接的调用自己\n\n### 递归的两个要素\n\n* 自己调用自己\n* 递归结束条件\n\n### 化归思想\n\n由难化易，由繁化简，的思想就是化归思想\n\n### 前n项和\n\n```js\nfn(n) = fn(n-1) + n\n```\n\n```js\nfunction sum(n){\n    if(n==1){\n        return 1;\n    }\n    return sum(n - 1) + n;\n}\n```\n\n### 阶乘\n\n```js\nfn(n) = fn(n-1) * n\n```\n\n```js\nfunction sum(n){\n    if(n==1){\n        return 1;\n    }\n    return sum(n - 1) * n;\n}\n```\n\n### 斐波那契数列\n\n```js\nfn(n) = fn(n-1) + fn(n-2)\n```\n```js\nfunction fib(n){\n    if( n <= 2){\n        return 1;\n    }\n    return fib(n-1) + fib(n-2);\n}\n```\n\n### 递归获取指定元素的后代元素\n\n```js\nfunction getChildren(ele){\n    var result = [];\n    var children = ele.children;\n    for(var i = 0; i < children.length; i++){\n        result.push(children[i]);\n        var temp = getChildren(children[i]);\n        result = result.concat(temp);\n    }\n    return result;\n}\n```\n\n## 闭包\n\n一个封闭的包裹结构\n\n一个可以访问独立数据的函数\n\n```js\nfunction outer(){\n    var data = \"\";\n    return function(){\n        //可以操作data数据\n    }\n}\n```\n\n获取和设置数据\n\n```js\nfunction outer(){\n    var data = \"\";\n    return {\n        getData:function(){\n            return data;\n        },\n        setDate:function(value){\n            data = value;\n        }\n    }\n}\n```\n\n### for循环注册点击事件的问题\n\n```js\n\nvar divs = document.getElementsByTagName(\"div\");\nfor(var i = 0; i < divs.length; i++){\n    var div = divs[i];\n    function outer(){\n        var j = i;\n        return function(){\n            console.log(j);\n        }\n    }\n    div.onclick = outer();\n}\n\n```\n\n### for循环中使用setTimeout\n\n```js\nfor( var i = 0; i < 10; i++){\n    setTimeout((function(){\n        var j = i;\n        return function(){\n            console.log(j);\n        }\n    }()),0)\n}\n```\n\n## 缓存\n\n* 硬件缓存\n* 浏览器缓存\n* `CDN`---`Content Delivery Network`  内容分发网络\n\n### 使用缓存解决递归实现的斐波那契数列的性能问题\n\n```js\nfunction createFib(){\n    var arr = [];\n    return function(n){\n        var num = arr[n];\n        if(!num){\n            if(n <= 2){\n                num = 1;\n            }else{\n                num = arguments.callee(n - 1) + arguments.callee(n - 2);\n            }\n            arr[n] = num;\n        }\n        return num;\n    }\n}\n```\n\n### jQuery缓存实现分析\n\n```js\nfunction createCache(){\n    var cache = {};\n    var arr = [];\n    return function(key, value){\n        if(value){\n            cache[key] = value;\n            arr.push(key);\n            if(arr.length > 50){\n                delete cache[arr.shift()];\n            }\n        }else{\n            return cache[key];\n        }\n    }\n}\n```\n\n## 函数的四种调用模式\n\n### 函数调用模式\n\n形式: 函数名();\n`this: window`\n\n### 方法调用模式\n\n形式: 对象名.方法名();\nthis: 调用该方法的对象\n\n### 构造函数调用模式\n\n形式: `new` .构造函数名()\n`this: new`创建出来的对象\n\n#### 工厂模式\n\n```js\nfunction createObject(){\n    var o = new Object();\n    o.xxx = \"xxx\";\n    o.yyy = \"yy\";\n    return o;\n}\n\nvar p  = createObject();\n```\n\n#### 寄生模式\n\n```js\nfunction CObject(){\n    var o = new Object();\n    o.xxx = \"xxx\";\n    o.yyy = \"yy\";\n    return o;\n}\n\nvar p = new CObject();\n```\n\n### 上下文调用模式\n\n#### call\n\n```js\n函数名.call(对象,参数1,参数2,参数3...)\n```\n1. 调用该函数\n2. 将函数内部的`this`赋值为`call`的第一个参数\n3. 将第一个参数之后的所有参数，当做实参传递给函数\n\n#### apply\n\n```js\n函数名.apply(对象,数组)\n```\n1. 调用该函数\n2. 将函数内部的`this`赋值为`apply`的第一个参数\n3. 将第二个参数的数组，依次拆解开，将每一个元素挨个传递给函数做为实参\n\n##### 伪数组转换成数组\n\n```js\nvar arrFake = {\n    0:1,\n    1:2,\n    2:3,\n    length:3\n}\n\nvar arrReal = [];\n\narrReal.push.apply(arrReal, arrFake);\n//arrReal.push(arrFake[0] , arrFake[1], arrFake[2])   相当于这句代码\n\n```\n\n##### 求数组最大值\n\n```js\nvar arr = [1,23,4,4,3,3,34,3,2];\nvar maxNum = Math.max.apply(null, arr);\n```\n\n#### 借用构造函数继承\n\n```js\nfunction Father(){\n    this.name = \"\";\n    this.money = 99999999999999;\n}\n\nfunction Son(){\n    Father.call(this);\n}\n\nvar s = new Son();\n```\n\n## 沙箱模式\n\n一个隔离的安全的环境\n\n```js\n(function(w){\n    //需要隔离的代码\n    //最顶上写 变量函数之类的申明\n    //逻辑代码\n    //如果需要，使用window对象向外界暴露接口\n})(window)\n```\n\n为什么要将 `window` 作为参数传递\n1. 外面无法访问里面，里面也不要去访问外面的东西\n2. 在代码压缩的时候，内置的对象名称无法被压缩，如果使用自己的变量，是可以压缩的\n\n## forEach 和　map\n\n```js\nvar arr = [1, 2, 3, 4, 5 ,6];\n//currentEle 当前正在遍历的元素,\n//currentIndex 当前遍历的元素的索引,\n//currentArray 当前正在被遍历的数组\narr.forEach(function(currentEle, currentIndex, currentArray){\n    currentArray[currentIndex] = currentEle * 2;\n})\n\n//currentEle 当前正在遍历的元素,\n//currentIndex 当前遍历的元素的索引,\n//currentArray 当前正在被遍历的数组\n//map如果回调函数内有返回值，会将所有调用的返回值重新组合成一个数组，作为map方法的返回值\narr.map(function(currentEle, currentIndex, currentArray){\n    return currentEle * 2;\n})\n```\n\n## 严格模式\n\n```js\n\"use strict\"\n```\n* 变量不使用`var`声明会报错\n* 不能删除不允许删除的属性\n* 对象的属性不可以重名\n* 函数的形参不可以重名\n* 不允许使用八进制数据\n\n## 事件兼容性处理\n\n```js\nfunction createRegister(){\n    if(window.addEventListener){\n        return function(target, type, handler){\n            target.addEventListener(type, handler);\n        }\n    }else if(window.attachEvent){\n        return function(target, type, handler){\n            target.attachEvent(\"on\" + type, function(){\n                handler.call(target, window.event);\n            })\n        }\n    }else{\n        return function(target, type, handler){\n            target[\"on\"+type] = handler;\n        }\n    }\n}\n```","source":"_posts/javascript-summary.md","raw":"---\ntitle: JavaScript高级篇总结\ndate: 2016-11-12 19:04:31\ntags: javascript\ncategories: javascript\n---\njavascript高级与面向对象笔记总结！！\n\n<!-- more -->\n\n## 递归\n\n递归就是函数自己直接或者间接的调用自己\n\n### 递归的两个要素\n\n* 自己调用自己\n* 递归结束条件\n\n### 化归思想\n\n由难化易，由繁化简，的思想就是化归思想\n\n### 前n项和\n\n```js\nfn(n) = fn(n-1) + n\n```\n\n```js\nfunction sum(n){\n    if(n==1){\n        return 1;\n    }\n    return sum(n - 1) + n;\n}\n```\n\n### 阶乘\n\n```js\nfn(n) = fn(n-1) * n\n```\n\n```js\nfunction sum(n){\n    if(n==1){\n        return 1;\n    }\n    return sum(n - 1) * n;\n}\n```\n\n### 斐波那契数列\n\n```js\nfn(n) = fn(n-1) + fn(n-2)\n```\n```js\nfunction fib(n){\n    if( n <= 2){\n        return 1;\n    }\n    return fib(n-1) + fib(n-2);\n}\n```\n\n### 递归获取指定元素的后代元素\n\n```js\nfunction getChildren(ele){\n    var result = [];\n    var children = ele.children;\n    for(var i = 0; i < children.length; i++){\n        result.push(children[i]);\n        var temp = getChildren(children[i]);\n        result = result.concat(temp);\n    }\n    return result;\n}\n```\n\n## 闭包\n\n一个封闭的包裹结构\n\n一个可以访问独立数据的函数\n\n```js\nfunction outer(){\n    var data = \"\";\n    return function(){\n        //可以操作data数据\n    }\n}\n```\n\n获取和设置数据\n\n```js\nfunction outer(){\n    var data = \"\";\n    return {\n        getData:function(){\n            return data;\n        },\n        setDate:function(value){\n            data = value;\n        }\n    }\n}\n```\n\n### for循环注册点击事件的问题\n\n```js\n\nvar divs = document.getElementsByTagName(\"div\");\nfor(var i = 0; i < divs.length; i++){\n    var div = divs[i];\n    function outer(){\n        var j = i;\n        return function(){\n            console.log(j);\n        }\n    }\n    div.onclick = outer();\n}\n\n```\n\n### for循环中使用setTimeout\n\n```js\nfor( var i = 0; i < 10; i++){\n    setTimeout((function(){\n        var j = i;\n        return function(){\n            console.log(j);\n        }\n    }()),0)\n}\n```\n\n## 缓存\n\n* 硬件缓存\n* 浏览器缓存\n* `CDN`---`Content Delivery Network`  内容分发网络\n\n### 使用缓存解决递归实现的斐波那契数列的性能问题\n\n```js\nfunction createFib(){\n    var arr = [];\n    return function(n){\n        var num = arr[n];\n        if(!num){\n            if(n <= 2){\n                num = 1;\n            }else{\n                num = arguments.callee(n - 1) + arguments.callee(n - 2);\n            }\n            arr[n] = num;\n        }\n        return num;\n    }\n}\n```\n\n### jQuery缓存实现分析\n\n```js\nfunction createCache(){\n    var cache = {};\n    var arr = [];\n    return function(key, value){\n        if(value){\n            cache[key] = value;\n            arr.push(key);\n            if(arr.length > 50){\n                delete cache[arr.shift()];\n            }\n        }else{\n            return cache[key];\n        }\n    }\n}\n```\n\n## 函数的四种调用模式\n\n### 函数调用模式\n\n形式: 函数名();\n`this: window`\n\n### 方法调用模式\n\n形式: 对象名.方法名();\nthis: 调用该方法的对象\n\n### 构造函数调用模式\n\n形式: `new` .构造函数名()\n`this: new`创建出来的对象\n\n#### 工厂模式\n\n```js\nfunction createObject(){\n    var o = new Object();\n    o.xxx = \"xxx\";\n    o.yyy = \"yy\";\n    return o;\n}\n\nvar p  = createObject();\n```\n\n#### 寄生模式\n\n```js\nfunction CObject(){\n    var o = new Object();\n    o.xxx = \"xxx\";\n    o.yyy = \"yy\";\n    return o;\n}\n\nvar p = new CObject();\n```\n\n### 上下文调用模式\n\n#### call\n\n```js\n函数名.call(对象,参数1,参数2,参数3...)\n```\n1. 调用该函数\n2. 将函数内部的`this`赋值为`call`的第一个参数\n3. 将第一个参数之后的所有参数，当做实参传递给函数\n\n#### apply\n\n```js\n函数名.apply(对象,数组)\n```\n1. 调用该函数\n2. 将函数内部的`this`赋值为`apply`的第一个参数\n3. 将第二个参数的数组，依次拆解开，将每一个元素挨个传递给函数做为实参\n\n##### 伪数组转换成数组\n\n```js\nvar arrFake = {\n    0:1,\n    1:2,\n    2:3,\n    length:3\n}\n\nvar arrReal = [];\n\narrReal.push.apply(arrReal, arrFake);\n//arrReal.push(arrFake[0] , arrFake[1], arrFake[2])   相当于这句代码\n\n```\n\n##### 求数组最大值\n\n```js\nvar arr = [1,23,4,4,3,3,34,3,2];\nvar maxNum = Math.max.apply(null, arr);\n```\n\n#### 借用构造函数继承\n\n```js\nfunction Father(){\n    this.name = \"\";\n    this.money = 99999999999999;\n}\n\nfunction Son(){\n    Father.call(this);\n}\n\nvar s = new Son();\n```\n\n## 沙箱模式\n\n一个隔离的安全的环境\n\n```js\n(function(w){\n    //需要隔离的代码\n    //最顶上写 变量函数之类的申明\n    //逻辑代码\n    //如果需要，使用window对象向外界暴露接口\n})(window)\n```\n\n为什么要将 `window` 作为参数传递\n1. 外面无法访问里面，里面也不要去访问外面的东西\n2. 在代码压缩的时候，内置的对象名称无法被压缩，如果使用自己的变量，是可以压缩的\n\n## forEach 和　map\n\n```js\nvar arr = [1, 2, 3, 4, 5 ,6];\n//currentEle 当前正在遍历的元素,\n//currentIndex 当前遍历的元素的索引,\n//currentArray 当前正在被遍历的数组\narr.forEach(function(currentEle, currentIndex, currentArray){\n    currentArray[currentIndex] = currentEle * 2;\n})\n\n//currentEle 当前正在遍历的元素,\n//currentIndex 当前遍历的元素的索引,\n//currentArray 当前正在被遍历的数组\n//map如果回调函数内有返回值，会将所有调用的返回值重新组合成一个数组，作为map方法的返回值\narr.map(function(currentEle, currentIndex, currentArray){\n    return currentEle * 2;\n})\n```\n\n## 严格模式\n\n```js\n\"use strict\"\n```\n* 变量不使用`var`声明会报错\n* 不能删除不允许删除的属性\n* 对象的属性不可以重名\n* 函数的形参不可以重名\n* 不允许使用八进制数据\n\n## 事件兼容性处理\n\n```js\nfunction createRegister(){\n    if(window.addEventListener){\n        return function(target, type, handler){\n            target.addEventListener(type, handler);\n        }\n    }else if(window.attachEvent){\n        return function(target, type, handler){\n            target.attachEvent(\"on\" + type, function(){\n                handler.call(target, window.event);\n            })\n        }\n    }else{\n        return function(target, type, handler){\n            target[\"on\"+type] = handler;\n        }\n    }\n}\n```","slug":"javascript-summary","published":1,"updated":"2016-11-24T01:32:28.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw57001scsg7o8sqjjiv"},{"title":"工具使用篇之Markdown","date":"2016-11-27T02:35:12.000Z","top":10,"_content":"\n## Markdown 介绍\n\n- *Markdown* 是一个 **轻量级  高效率** 的标记语言\n- 轻量级标记语言，2004 年被 `John Gruber` 创造， 它允许人们“使用易读易写的纯文本格式编写文档”， Markdown 最重要的设计就是可读性， Markdown 可以选择性的转换为 HTML 文档格式， 很多网站目前都使用了 Markdown 或者其变种，例如Github、简书等大型社区。\n\n<!--more-->\n\n## Markdown 使用场景\n\n- 学习笔记\n- 演讲稿\n- 写书（侧重于技术相关的 内容非常适合）\n- 个人笔记\n- 文章博客\n- 教学讲义\n- 说明文档\n- 电子邮件\n\n\n## Markdown 实时预览编辑器\n\n- dillinger\n- 马克飞象\n- 简书\n- MarkdownPad\n- Sublime Text\n    * 配合 Markdown Preview 插件\n- Webstorm\n    * 配合插件\n- gitbook\n\n实时预览工具只是为了达到所见即所得的效果而已， 适合初学者学习 Markdown ， 我们真正在进行写作的时候，其实是不需要实时预览的， 因为 Markdown 标记语言本身已经足够清晰了。\n\n## Markdown 安装和配置编写预览环境\n\n### Webstorm\n\n\n\n### Visual Studio Code\n\n\n\n### Sublime\n\n- MarkdownEditing 主题、自动补齐等功能\n- MarkdownPreview 在浏览器预览\n- MarkdownTOC 自动生成导航\n- Table Editor 自动表格编辑\n- [packagecontrol](https://packagecontrol.io/) Sublime 的插件生态系统网站\n\n只要有写作的地方，都可以使用 Markdown 来书写。\n\n## Markdown 标题书写\n\n```Markdown\n# 一级标题 \n## 二级标题 \n### 三级标题\n...\n###### 六级标签\n一共六级标题\n```\n\n## Markdown 列表书写语法\n\n### 无序列表\n\n- 一级列表建议使用 `-`\n    + 二级列表建议使用 `+`\n        * 三级列表建议使用 `*`\n\n```Markdown\n- 一级标题\n    + 二级标题\n        * 三级列表\n```\n\n### 有序列表\n\n1. 有序列表直接使用序列加一个点开头, 然后加一个\n2. 有序列表嵌套无序列表\n    - 有序列表中嵌套无需列表\n        + 有序列表中嵌套无需列表\n\n```Markdown\n2. 有序列表嵌套无序列表\n    - 有序列表嵌套无序列表\n        + 有序列表嵌套无序列表\n```\n\n3. 有序列表嵌套有序列表\n    1. 有序列表嵌套有序列表\n        1. 有序列表嵌套有序列表\n\n```Markdown\n3. 有序列表嵌套有序列表\n    1. 有序列表嵌套有序列表\n        1. 有序列表嵌套有序列表\n```\n\n#### 使用建议\n\n无论是有序列表还是无序列表,如果就写一级列表不嵌套就可以紧凑写到一起即可,如果嵌套多级列表最好在列表项之间只用空行隔开\n\n## Markdown 图片链接书写语法\n\n### Markdown 图片书写语法\n\n![]()\n\n### Markdown 链接书写语法\n","source":"_posts/use-tools-part1-markdown.md","raw":"---\ntitle: 工具使用篇之Markdown\ndate: 2016-11-27 10:35:12\ntags: \n    - Markdown语法规范\n    - tools\ncategories: Markdown\ntop: 10\n---\n\n## Markdown 介绍\n\n- *Markdown* 是一个 **轻量级  高效率** 的标记语言\n- 轻量级标记语言，2004 年被 `John Gruber` 创造， 它允许人们“使用易读易写的纯文本格式编写文档”， Markdown 最重要的设计就是可读性， Markdown 可以选择性的转换为 HTML 文档格式， 很多网站目前都使用了 Markdown 或者其变种，例如Github、简书等大型社区。\n\n<!--more-->\n\n## Markdown 使用场景\n\n- 学习笔记\n- 演讲稿\n- 写书（侧重于技术相关的 内容非常适合）\n- 个人笔记\n- 文章博客\n- 教学讲义\n- 说明文档\n- 电子邮件\n\n\n## Markdown 实时预览编辑器\n\n- dillinger\n- 马克飞象\n- 简书\n- MarkdownPad\n- Sublime Text\n    * 配合 Markdown Preview 插件\n- Webstorm\n    * 配合插件\n- gitbook\n\n实时预览工具只是为了达到所见即所得的效果而已， 适合初学者学习 Markdown ， 我们真正在进行写作的时候，其实是不需要实时预览的， 因为 Markdown 标记语言本身已经足够清晰了。\n\n## Markdown 安装和配置编写预览环境\n\n### Webstorm\n\n\n\n### Visual Studio Code\n\n\n\n### Sublime\n\n- MarkdownEditing 主题、自动补齐等功能\n- MarkdownPreview 在浏览器预览\n- MarkdownTOC 自动生成导航\n- Table Editor 自动表格编辑\n- [packagecontrol](https://packagecontrol.io/) Sublime 的插件生态系统网站\n\n只要有写作的地方，都可以使用 Markdown 来书写。\n\n## Markdown 标题书写\n\n```Markdown\n# 一级标题 \n## 二级标题 \n### 三级标题\n...\n###### 六级标签\n一共六级标题\n```\n\n## Markdown 列表书写语法\n\n### 无序列表\n\n- 一级列表建议使用 `-`\n    + 二级列表建议使用 `+`\n        * 三级列表建议使用 `*`\n\n```Markdown\n- 一级标题\n    + 二级标题\n        * 三级列表\n```\n\n### 有序列表\n\n1. 有序列表直接使用序列加一个点开头, 然后加一个\n2. 有序列表嵌套无序列表\n    - 有序列表中嵌套无需列表\n        + 有序列表中嵌套无需列表\n\n```Markdown\n2. 有序列表嵌套无序列表\n    - 有序列表嵌套无序列表\n        + 有序列表嵌套无序列表\n```\n\n3. 有序列表嵌套有序列表\n    1. 有序列表嵌套有序列表\n        1. 有序列表嵌套有序列表\n\n```Markdown\n3. 有序列表嵌套有序列表\n    1. 有序列表嵌套有序列表\n        1. 有序列表嵌套有序列表\n```\n\n#### 使用建议\n\n无论是有序列表还是无序列表,如果就写一级列表不嵌套就可以紧凑写到一起即可,如果嵌套多级列表最好在列表项之间只用空行隔开\n\n## Markdown 图片链接书写语法\n\n### Markdown 图片书写语法\n\n![]()\n\n### Markdown 链接书写语法\n","slug":"use-tools-part1-markdown","published":1,"updated":"2016-12-17T12:26:30.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw59001wcsg7qtvjp3fs"},{"title":"js高级与面向对象之原型","date":"2016-06-04T05:41:47.000Z","_content":"\n## 原型的基本概念\n\n在构造函数创建出来的时候，系统会默认的帮构造函数创建并且关联一个空对象，这个对象就成为原型\n\n<!-- more -->\n\n##原型的作用\n\n原型中的所有成员都可以被和其关联的构造函数创建出来的对象访问\n\n```js\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\n```\n\n如何利用原型解决构造函数存在的问题？\n* 利用原型的特性，将方法放到原型中去，供所有的对象访问\n\n## 如何访问原型？\n\n* 构造函数`.prototype`\n\n```js\nconsole.log(typeof Person.prototype);\nconsole.log(Person.prototype);\n```\n\n## 如何使用原型？\n\n* 使用对象的动态特性，为原型对象新增成员\n\n```js\nPerson.prototype.eat = function () {\n    console.log(\"吃个大鸡腿儿\");\n}\n\nvar p  = new Person();\np.eat();\nvar p1 = new Person();\np1.eat();\n\nconsole.log(p.eat == p1.eat);\n```\n\n* 直接替换原型对象\n\n```js\nPerson.prototype = {\n    run:function(){\n        console.log(\"李二狗正在以时速1cm每小时的速度奔向餐厅\");\n    }\n};\n\nconsole.log(Person.prototype);\nvar p2 = new Person();\np2.run();\n```\n\n## 原型使用的注意事项\n\n对象访问属性的时候，会现在自身查找，如果找到了就直接使用如果没有找到，就去构造函数的原型对象中去查找\n\n1. 一般情况下，只会将方法放入原型对象中，属性单独的放在对象中\n2. 在获取对象的属性的时候，会现在对象中进行查找，然后去原型中查找\n3. 在对象进行设置属性的时候，不会去原型中查找属性，而是直接在对象内进行查找，如果找到该属性，就修改，如果没有找到，就新增\n4. 在替换原型对象的时候，要注意：替换之前创建出来的对象的原型和替换之后创建出来的对象的原型会不一致\n\n```js\nfunction Person(){\n\n}\n\n//Person.prototype.name = \"张三\";\nPerson.prototype.sing = function () {\n    console.log(\"Take me to your heart!\");\n}\nvar p = new Person();\n//console.log(p.name);  //张三\np.sing();  //可以\n\n//p.name = \"李四\";\n//console.log(p.name);  //李四\n\nPerson.prototype = {\n\n};\n\nvar p1 = new Person();\n//console.log(p1.name); //张三\np1.sing();//不可以\n\np.sing();//不可以  or  可以\n```\n\n## 原型的访问方式\n\n1. 通过 `构造函数.prototype` 去访问\n2. 通过 `对象.__proto__` 去访问\n\t注：__proto__这个属性 是非标准的！！！ 不推荐在开发过程中使用，只用于调试代码\n\n* __.proto__用法\n\n```js\nfunction Person(){\n}\nPerson.prototype = {\n    name : \"迈克学摇滚\",\n    song : \"Take me to your heart\"\n}\nvar p = new Person();\np.__proto__.count = 100;\nconsole.log(p.__proto__);\n```","source":"_posts/javascript-prototype.md","raw":"---\ntitle: js高级与面向对象之原型\ndate: 2016-06-04 13:41:47\ntags: \n\t- javascript\n\t- 原型\n\t- 原型的基本概念\ncategories: javascript\n---\n\n## 原型的基本概念\n\n在构造函数创建出来的时候，系统会默认的帮构造函数创建并且关联一个空对象，这个对象就成为原型\n\n<!-- more -->\n\n##原型的作用\n\n原型中的所有成员都可以被和其关联的构造函数创建出来的对象访问\n\n```js\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\n```\n\n如何利用原型解决构造函数存在的问题？\n* 利用原型的特性，将方法放到原型中去，供所有的对象访问\n\n## 如何访问原型？\n\n* 构造函数`.prototype`\n\n```js\nconsole.log(typeof Person.prototype);\nconsole.log(Person.prototype);\n```\n\n## 如何使用原型？\n\n* 使用对象的动态特性，为原型对象新增成员\n\n```js\nPerson.prototype.eat = function () {\n    console.log(\"吃个大鸡腿儿\");\n}\n\nvar p  = new Person();\np.eat();\nvar p1 = new Person();\np1.eat();\n\nconsole.log(p.eat == p1.eat);\n```\n\n* 直接替换原型对象\n\n```js\nPerson.prototype = {\n    run:function(){\n        console.log(\"李二狗正在以时速1cm每小时的速度奔向餐厅\");\n    }\n};\n\nconsole.log(Person.prototype);\nvar p2 = new Person();\np2.run();\n```\n\n## 原型使用的注意事项\n\n对象访问属性的时候，会现在自身查找，如果找到了就直接使用如果没有找到，就去构造函数的原型对象中去查找\n\n1. 一般情况下，只会将方法放入原型对象中，属性单独的放在对象中\n2. 在获取对象的属性的时候，会现在对象中进行查找，然后去原型中查找\n3. 在对象进行设置属性的时候，不会去原型中查找属性，而是直接在对象内进行查找，如果找到该属性，就修改，如果没有找到，就新增\n4. 在替换原型对象的时候，要注意：替换之前创建出来的对象的原型和替换之后创建出来的对象的原型会不一致\n\n```js\nfunction Person(){\n\n}\n\n//Person.prototype.name = \"张三\";\nPerson.prototype.sing = function () {\n    console.log(\"Take me to your heart!\");\n}\nvar p = new Person();\n//console.log(p.name);  //张三\np.sing();  //可以\n\n//p.name = \"李四\";\n//console.log(p.name);  //李四\n\nPerson.prototype = {\n\n};\n\nvar p1 = new Person();\n//console.log(p1.name); //张三\np1.sing();//不可以\n\np.sing();//不可以  or  可以\n```\n\n## 原型的访问方式\n\n1. 通过 `构造函数.prototype` 去访问\n2. 通过 `对象.__proto__` 去访问\n\t注：__proto__这个属性 是非标准的！！！ 不推荐在开发过程中使用，只用于调试代码\n\n* __.proto__用法\n\n```js\nfunction Person(){\n}\nPerson.prototype = {\n    name : \"迈克学摇滚\",\n    song : \"Take me to your heart\"\n}\nvar p = new Person();\np.__proto__.count = 100;\nconsole.log(p.__proto__);\n```","slug":"javascript-prototype","published":1,"updated":"2016-11-24T01:26:39.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6tyw5b0020csg76y6x28jm"}],"PostAsset":[],"PostCategory":[{"post_id":"cix6tyw3b0000csg7l7rmci7g","category_id":"cix6tyw3i0002csg70a426las","_id":"cix6tyw3y000acsg7p6jltwk2"},{"post_id":"cix6tyw3f0001csg7ijh18ba6","category_id":"cix6tyw3i0002csg70a426las","_id":"cix6tyw44000gcsg7mvbq4ax2"},{"post_id":"cix6tyw3k0004csg76gn6nw3h","category_id":"cix6tyw41000ccsg72tf9rhr9","_id":"cix6tyw4a000ncsg7dcpfyet7"},{"post_id":"cix6tyw3l0005csg7n9qcupi6","category_id":"cix6tyw41000ccsg72tf9rhr9","_id":"cix6tyw4d000tcsg7optxiy1x"},{"post_id":"cix6tyw3q0006csg7hx3iu5xh","category_id":"cix6tyw41000ccsg72tf9rhr9","_id":"cix6tyw4m000zcsg7tyzxxgp9"},{"post_id":"cix6tyw4f000xcsg7jf1lyqll","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw4o0013csg7p4bnpytw"},{"post_id":"cix6tyw3v0009csg7p7r7eha8","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw4r0015csg7p3v12lmj"},{"post_id":"cix6tyw4l000ycsg70tuaxfin","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw4v0019csg70v5vtcfa"},{"post_id":"cix6tyw4n0012csg7kbt8ps8i","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw4w001ccsg73gndftww"},{"post_id":"cix6tyw3y000bcsg77f63obcr","category_id":"cix6tyw4n0010csg7ipmkvn29","_id":"cix6tyw4z001hcsg7qkquh75t"},{"post_id":"cix6tyw4p0014csg7kfe6q4dp","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw51001kcsg7wy4k8r4u"},{"post_id":"cix6tyw4s0017csg79yjhmvg6","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw54001ocsg7xgfz3ky1"},{"post_id":"cix6tyw43000ecsg74refkm7h","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw57001qcsg7bxdt6nkz"},{"post_id":"cix6tyw4w001bcsg7ydc3ek9s","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw59001ucsg7j8rmz5t8"},{"post_id":"cix6tyw4x001fcsg7cd5zecj6","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5a001xcsg79uq0c83r"},{"post_id":"cix6tyw44000hcsg7g69g3rco","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5c0022csg7ey08sr90"},{"post_id":"cix6tyw50001jcsg72u7fjazr","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5c0024csg76eaw62ef"},{"post_id":"cix6tyw52001mcsg752gv0xck","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5d0027csg7yrli3v2p"},{"post_id":"cix6tyw47000lcsg76d07a2jc","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5d0028csg7l3r0g4rd"},{"post_id":"cix6tyw55001pcsg7ee1szpca","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5e002bcsg75yjsmxcc"},{"post_id":"cix6tyw57001scsg7o8sqjjiv","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5f002dcsg7qle1cfb9"},{"post_id":"cix6tyw49000mcsg76guvtztr","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5g002gcsg7al227oel"},{"post_id":"cix6tyw5b0020csg76y6x28jm","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5h002icsg73pvjbce4"},{"post_id":"cix6tyw4a000qcsg7hpl723gm","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5h002lcsg77h6vc5pv"},{"post_id":"cix6tyw4c000scsg720femnt3","category_id":"cix6tyw4e000vcsg72rg15gzu","_id":"cix6tyw5h002mcsg7rrdfq3zv"},{"post_id":"cix6tyw59001wcsg7qtvjp3fs","category_id":"cix6tyw5d0029csg7u5nt5jlk","_id":"cix6tyw5h002ncsg74x92e8mt"}],"PostTag":[{"post_id":"cix6tyw3b0000csg7l7rmci7g","tag_id":"cix6tyw3j0003csg7wtk7q9jd","_id":"cix6tyw43000fcsg7535wzt80"},{"post_id":"cix6tyw3b0000csg7l7rmci7g","tag_id":"cix6tyw3r0008csg7222edryl","_id":"cix6tyw45000icsg7zkzmx7uz"},{"post_id":"cix6tyw3f0001csg7ijh18ba6","tag_id":"cix6tyw3j0003csg7wtk7q9jd","_id":"cix6tyw4b000rcsg7stxczkc3"},{"post_id":"cix6tyw3f0001csg7ijh18ba6","tag_id":"cix6tyw3r0008csg7222edryl","_id":"cix6tyw4e000ucsg7y41sbzfp"},{"post_id":"cix6tyw3k0004csg76gn6nw3h","tag_id":"cix6tyw4a000pcsg70g4r3q23","_id":"cix6tyw4v001acsg7dv8g7cwj"},{"post_id":"cix6tyw3k0004csg76gn6nw3h","tag_id":"cix6tyw4e000wcsg7v8mi2u2c","_id":"cix6tyw4x001ecsg7yjo59ber"},{"post_id":"cix6tyw3k0004csg76gn6nw3h","tag_id":"cix6tyw4n0011csg7bv9irs86","_id":"cix6tyw4z001icsg73sxamngb"},{"post_id":"cix6tyw3l0005csg7n9qcupi6","tag_id":"cix6tyw4a000pcsg70g4r3q23","_id":"cix6tyw59001vcsg7zvb18php"},{"post_id":"cix6tyw3l0005csg7n9qcupi6","tag_id":"cix6tyw4e000wcsg7v8mi2u2c","_id":"cix6tyw5b001zcsg75ningbpn"},{"post_id":"cix6tyw3l0005csg7n9qcupi6","tag_id":"cix6tyw4n0011csg7bv9irs86","_id":"cix6tyw5c0023csg7uot02999"},{"post_id":"cix6tyw3q0006csg7hx3iu5xh","tag_id":"cix6tyw4a000pcsg70g4r3q23","_id":"cix6tyw5f002ccsg74ady7c2s"},{"post_id":"cix6tyw3q0006csg7hx3iu5xh","tag_id":"cix6tyw4e000wcsg7v8mi2u2c","_id":"cix6tyw5f002ecsg7exj35eza"},{"post_id":"cix6tyw3q0006csg7hx3iu5xh","tag_id":"cix6tyw4n0011csg7bv9irs86","_id":"cix6tyw5g002hcsg73p485wrp"},{"post_id":"cix6tyw3v0009csg7p7r7eha8","tag_id":"cix6tyw5e002acsg77mt4xua3","_id":"cix6tyw5h002jcsg7w5oeasw1"},{"post_id":"cix6tyw3y000bcsg77f63obcr","tag_id":"cix6tyw5g002fcsg7l0jj2600","_id":"cix6tyw5i002rcsg7d1aijymc"},{"post_id":"cix6tyw3y000bcsg77f63obcr","tag_id":"cix6tyw5h002kcsg7i4h5y0bw","_id":"cix6tyw5i002scsg7qp4bo71h"},{"post_id":"cix6tyw3y000bcsg77f63obcr","tag_id":"cix6tyw5h002ocsg74hrxj62c","_id":"cix6tyw5j002ucsg7xi7jd45h"},{"post_id":"cix6tyw3y000bcsg77f63obcr","tag_id":"cix6tyw5i002pcsg7n4kdgawd","_id":"cix6tyw5j002vcsg72wxuja2q"},{"post_id":"cix6tyw43000ecsg74refkm7h","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw5j002zcsg7xywgyx8x"},{"post_id":"cix6tyw43000ecsg74refkm7h","tag_id":"cix6tyw5i002tcsg73fbsqfta","_id":"cix6tyw5k0030csg7167xufnt"},{"post_id":"cix6tyw43000ecsg74refkm7h","tag_id":"cix6tyw5j002wcsg7r1jp1o9x","_id":"cix6tyw5l0032csg79x512n6b"},{"post_id":"cix6tyw43000ecsg74refkm7h","tag_id":"cix6tyw5j002xcsg7f7eb93eu","_id":"cix6tyw5l0033csg7x49fpzfb"},{"post_id":"cix6tyw44000hcsg7g69g3rco","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5m0036csg77tixq9af"},{"post_id":"cix6tyw44000hcsg7g69g3rco","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5m0037csg7jy8l2tbg"},{"post_id":"cix6tyw44000hcsg7g69g3rco","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5m0039csg7jcays7gw"},{"post_id":"cix6tyw47000lcsg76d07a2jc","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw5n003bcsg7r0e220ik"},{"post_id":"cix6tyw47000lcsg76d07a2jc","tag_id":"cix6tyw5m0038csg7jaj6ly9z","_id":"cix6tyw5n003ccsg7k01oowpu"},{"post_id":"cix6tyw49000mcsg76guvtztr","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5p003gcsg7wg5zj8ra"},{"post_id":"cix6tyw49000mcsg76guvtztr","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5q003hcsg7lplogsj4"},{"post_id":"cix6tyw49000mcsg76guvtztr","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5r003jcsg74uqehpt3"},{"post_id":"cix6tyw4a000qcsg7hpl723gm","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5s003mcsg7xa45seby"},{"post_id":"cix6tyw4a000qcsg7hpl723gm","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5s003ncsg74f1aqhj8"},{"post_id":"cix6tyw4a000qcsg7hpl723gm","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5t003pcsg75rqgm9vy"},{"post_id":"cix6tyw4c000scsg720femnt3","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5v003scsg7sgo7e676"},{"post_id":"cix6tyw4c000scsg720femnt3","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5v003tcsg7167jtxdw"},{"post_id":"cix6tyw4c000scsg720femnt3","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5v003vcsg7x7llggup"},{"post_id":"cix6tyw4f000xcsg7jf1lyqll","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5w003ycsg708280tg0"},{"post_id":"cix6tyw4f000xcsg7jf1lyqll","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5w003zcsg7xc8d19in"},{"post_id":"cix6tyw4f000xcsg7jf1lyqll","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5w0041csg7rbea3xlp"},{"post_id":"cix6tyw4l000ycsg70tuaxfin","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5x0044csg70h638n04"},{"post_id":"cix6tyw4l000ycsg70tuaxfin","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw5x0045csg75n69pttq"},{"post_id":"cix6tyw4l000ycsg70tuaxfin","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw5y0047csg7je26mfd1"},{"post_id":"cix6tyw4n0012csg7kbt8ps8i","tag_id":"cix6tyw5j002ycsg74hskpdwz","_id":"cix6tyw5z004acsg77az4mhxc"},{"post_id":"cix6tyw4n0012csg7kbt8ps8i","tag_id":"cix6tyw5k0031csg7y63l2mu5","_id":"cix6tyw60004bcsg7bux8kngg"},{"post_id":"cix6tyw4n0012csg7kbt8ps8i","tag_id":"cix6tyw5l0034csg7ko1pg6l6","_id":"cix6tyw60004dcsg7la07p5vp"},{"post_id":"cix6tyw4p0014csg7kfe6q4dp","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw60004ecsg7l8rzt2q2"},{"post_id":"cix6tyw4s0017csg79yjhmvg6","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw61004gcsg7cf1veo2q"},{"post_id":"cix6tyw4w001bcsg7ydc3ek9s","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw61004icsg7knw0ireg"},{"post_id":"cix6tyw4x001fcsg7cd5zecj6","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw62004kcsg7jgm0auc3"},{"post_id":"cix6tyw50001jcsg72u7fjazr","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw62004mcsg7pqotbnvv"},{"post_id":"cix6tyw52001mcsg752gv0xck","tag_id":"cix6tyw62004lcsg7gg4f4ngx","_id":"cix6tyw63004ocsg7kfjpq1v4"},{"post_id":"cix6tyw55001pcsg7ee1szpca","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw63004qcsg7cgz40r9q"},{"post_id":"cix6tyw57001scsg7o8sqjjiv","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw63004scsg72gwc8q3g"},{"post_id":"cix6tyw59001wcsg7qtvjp3fs","tag_id":"cix6tyw63004rcsg786pkw8wm","_id":"cix6tyw64004vcsg7qejuhv4t"},{"post_id":"cix6tyw59001wcsg7qtvjp3fs","tag_id":"cix6tyw64004tcsg7zp9ka5nq","_id":"cix6tyw65004wcsg7j68zb4d3"},{"post_id":"cix6tyw5b0020csg76y6x28jm","tag_id":"cix6tyw5i002qcsg7xim3c4x9","_id":"cix6tyw65004zcsg7qar4nmzk"},{"post_id":"cix6tyw5b0020csg76y6x28jm","tag_id":"cix6tyw65004xcsg7qwxj0a7o","_id":"cix6tyw650050csg7oq01sj97"},{"post_id":"cix6tyw5b0020csg76y6x28jm","tag_id":"cix6tyw65004ycsg7yis0ns1e","_id":"cix6tyw660051csg7yoye85j0"}],"Tag":[{"name":"Node","_id":"cix6tyw3j0003csg7wtk7q9jd"},{"name":"NodeJs","_id":"cix6tyw3r0008csg7222edryl"},{"name":"Canvas","_id":"cix6tyw4a000pcsg70g4r3q23"},{"name":"HTML5","_id":"cix6tyw4e000wcsg7v8mi2u2c"},{"name":"画布","_id":"cix6tyw4n0011csg7bv9irs86"},{"name":"Function","_id":"cix6tyw5e002acsg77mt4xua3"},{"name":"hexo","_id":"cix6tyw5g002fcsg7l0jj2600"},{"name":"梦魇小栈","_id":"cix6tyw5h002kcsg7i4h5y0bw"},{"name":"梦魇","_id":"cix6tyw5h002ocsg74hrxj62c"},{"name":"houyi1121","_id":"cix6tyw5i002pcsg7n4kdgawd"},{"name":"javascript","_id":"cix6tyw5i002qcsg7xim3c4x9"},{"name":"js面向对象","_id":"cix6tyw5i002tcsg73fbsqfta"},{"name":"继承","_id":"cix6tyw5j002wcsg7r1jp1o9x"},{"name":"继承的实现方式","_id":"cix6tyw5j002xcsg7f7eb93eu"},{"name":"原生Js","_id":"cix6tyw5j002ycsg74hskpdwz"},{"name":"Js框架","_id":"cix6tyw5k0031csg7y63l2mu5"},{"name":"JQuery","_id":"cix6tyw5l0034csg7ko1pg6l6"},{"name":"js构造函数","_id":"cix6tyw5m0038csg7jaj6ly9z"},{"name":"原型链","_id":"cix6tyw62004lcsg7gg4f4ngx"},{"name":"Markdown语法规范","_id":"cix6tyw63004rcsg786pkw8wm"},{"name":"tools","_id":"cix6tyw64004tcsg7zp9ka5nq"},{"name":"原型","_id":"cix6tyw65004xcsg7qwxj0a7o"},{"name":"原型的基本概念","_id":"cix6tyw65004ycsg7yis0ns1e"}]}}